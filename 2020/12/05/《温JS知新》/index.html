

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;light&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#153e90">
  <meta name="description" content="">
  <meta name="author" content="playlife">
  <meta name="keywords" content="">
  <title>《温故而知新》JavaScript - playlife</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/night-owl.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_2101544_ifd43zekazn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>playlife</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                Tag
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/post_page.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-05 14:51" pubdate>
        2020-12-5th 02:51:13 PM
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      53
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">《温故而知新》JavaScript</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="JavaScript-细枝末节的知识"><a href="#JavaScript-细枝末节的知识" class="headerlink" title="JavaScript 细枝末节的知识"></a>JavaScript 细枝末节的知识</h1><blockquote>
<p>总结细小的 JavaScript 知识、以回答面试题的形式巩固</p>
</blockquote>
<h1 id="伪数组和真数组的区别"><a href="#伪数组和真数组的区别" class="headerlink" title="伪数组和真数组的区别"></a>伪数组和真数组的区别</h1><p>伪数组：</p>
<ol>
<li>拥有 <code>length</code> 属性</li>
<li>不具有数组的方法</li>
<li>伪数组是一个 <strong>Object</strong>，真数组是 <strong>Array</strong></li>
<li>伪数组的长度不可变，真数组的长度是可变的</li>
</ol>
<blockquote>
<p>只有数组属性，但没有数组方法</p>
</blockquote>
<h1 id="哪些情况会得到伪数组"><a href="#哪些情况会得到伪数组" class="headerlink" title="哪些情况会得到伪数组"></a>哪些情况会得到伪数组</h1><ol>
<li>函数参数对象 <code>arguments</code></li>
<li><strong>DOM</strong> 对象列表（比如通过<code>document.getElementsByTags</code> 得到的列表）、<code>childNodes</code> 也是伪数组</li>
<li><strong>jQuery</strong> 对象（比如 <code>$(&#39;div&#39;)</code>）</li>
</ol>
<h1 id="伪数组怎么转换为真数组"><a href="#伪数组怎么转换为真数组" class="headerlink" title="伪数组怎么转换为真数组"></a>伪数组怎么转换为真数组</h1><ol>
<li>通过 <code>Array.prototype.slice.call()</code> 方法</li>
<li>使用 ES6 的新方法：<code>Array.from()</code></li>
<li>通过 ES6 的新语法扩展运算符：<code>[...伪数组]</code></li>
</ol>
<h1 id="let、const、var的区别"><a href="#let、const、var的区别" class="headerlink" title="let、const、var的区别"></a>let、const、var的区别</h1><ol>
<li><code>var</code> 声明变量存在提升（提升当前作用域最顶端），<code>let</code> 和 <code>const</code> 是不存在变量提升的情况</li>
<li><code>var</code> 没有块级作用，<code>let</code> 和 <code>const</code> 存在块级作用域</li>
<li><code>var</code> 允许重复声明，<code>let</code> 和 <code>const</code> 在同一作用域不允许重复声明</li>
<li><code>var</code> 和 <code>let</code> 声明变量可以修改，<code>const</code> 是常量不能改变</li>
</ol>
<h1 id="异步函数有哪些"><a href="#异步函数有哪些" class="headerlink" title="异步函数有哪些?"></a>异步函数有哪些?</h1><p>JavaScript 中常见的异步函数有：定时器(<code>setTimeout</code> 、<code>setInterval</code>)，事件和 ajax 等</p>
<h1 id="什么是-Promise，特点是什么"><a href="#什么是-Promise，特点是什么" class="headerlink" title="什么是 Promise，特点是什么?"></a>什么是 Promise，特点是什么?</h1><p><strong>Promise</strong> 是 JavaScript ES5 提出的解决异步任务的新方案。</p>
<p>它是一个对象，它其他 JavaScript 对象的用法，没有什么两样；其次，它起到代理作用（proxy），充当异步操作与回调函数之间的中介。它使得异步操作具备同步操作的效果，使得程序具备正常的同步运行的流程，回调函数不必再一层层嵌套。</p>
<p>简单说，它的思想是，每一个异步任务立刻返回一个 <strong>Promise</strong> 对象，由于是立刻返回，所以可以采用同步操作的流程。这个 <strong>Promise</strong> 对象有一个 <strong>then</strong> 方法，允许指定回调函数，在异步任务完成后调用。</p>
<p>特点：</p>
<ol>
<li><p>Promise 对象只有三种状态。</p>
<ol>
<li><p>异步操作“未完成”（<strong>pending</strong>）</p>
</li>
<li><p>异步操作“已完成”（<strong>resolved</strong>，又称 <strong>fulfilled</strong>）</p>
</li>
<li><p>异步操作“失败”（<strong>rejected</strong>）</p>
</li>
</ol>
<blockquote>
<p>异步操作成功，Promise对象传回一个值，状态变为resolved。</p>
</blockquote>
<blockquote>
<p>异步操作失败，Promise对象抛出一个错误，状态变为rejected。</p>
</blockquote>
</li>
<li><p>Promise 的回调是同步的，then 是异步的</p>
</li>
<li><p>可以链式调用</p>
</li>
</ol>
<h1 id="Promise-的方法有哪些，能说明其作用"><a href="#Promise-的方法有哪些，能说明其作用" class="headerlink" title="Promise 的方法有哪些，能说明其作用"></a>Promise 的方法有哪些，能说明其作用</h1><p>原型方法：</p>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.then()</code></pre></div>

<p>作用:</p>
<ol>
<li><p>为 <strong>Promise</strong> 实例添加状态改变时的回调函数。接受两个回调函数作为参数。第一个回调函数是 <strong>Promise</strong> 对象的状态变为 <code>resolved</code> 时调用，第二个回调函数是 <strong>Promise</strong> 对象的状态变为 <code>rejected</code> 时调用。其中，第二个函数是可选的，不一定要提供。</p>
</li>
<li><p>返回的是另一个 <strong>Promise</strong> 对象，后面还可以接着调用 <code>then</code> 方法。</p>
</li>
</ol>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.catch()</code></pre></div>

<p>作用:</p>
<ol>
<li>用于指定发生错误时的回调函数。</li>
<li>返回的也是一个 <strong>Promise</strong> 对象，因此还可以接着调用 <code>then</code> 方法</li>
</ol>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Promise</span>.prototype.finally()</code></pre></div>

<p>作用:</p>
<ol>
<li><code>finally</code> 方法用于指定不管 <strong>Promise</strong> 对象最后状态如何，都会执行的回调函数。</li>
<li><code>finally</code> 方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 <strong>Promise</strong> 状态到底是 <code>fulfilled</code> 还是 <code>rejected</code>。</li>
</ol>
<p>实例方法：</p>
<div class="hljs"><pre><code class="hljs js">promise.resolve()</code></pre></div>

<p>作用：</p>
<ol>
<li>不带参数传递，返回一个新的状态为 <code>resolve</code> 的 <strong>Promise</strong> 对象</li>
<li>参数是一个 <strong>Promise</strong> 实例，返回当前的 <strong>promise</strong> 实例</li>
</ol>
<div class="hljs"><pre><code class="hljs js">promise.reject()</code></pre></div>

<p>作用：</p>
<ol>
<li>返回的是一个值</li>
<li>返回的值会传递到下一个 <code>then</code> 的 <code>resolve</code> 方法参数中</li>
</ol>
<div class="hljs"><pre><code class="hljs js">promise.all()</code></pre></div>

<ol>
<li>并行执行异步操作的能力</li>
<li>所有异步操作执行完后才执行回调</li>
</ol>
<div class="hljs"><pre><code class="hljs js">promise.race()</code></pre></div>

<p>作用：</p>
<ol>
<li>哪个结果最先返回来的，最后就是那个结果，不管结果是成功还是失败</li>
</ol>
<h1 id="async-和-await-是干什么的"><a href="#async-和-await-是干什么的" class="headerlink" title="async 和 await 是干什么的"></a>async 和 await 是干什么的</h1><p>async、await 是异步的终极解决方案</p>
<p>async/await 就是一个<strong>自执行</strong>的 <em>generator</em>  函数。利用 <em>generator</em>  函数的特性把异步的代码写成“同步”的形式。</p>
<p><strong>生成器函数</strong>在执行时能暂停，后面又能从暂停处继续执行。</p>
<p>调用一个<strong>生成器函数</strong>并不会马上执行它里面的语句，而是返回一个这个生成器的 <strong>迭代器</strong> <strong>（ iterator）对象</strong>。当这个迭代器的 <code>next() </code>方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现<code>yield</code>的位置为止，<code>yield</code>后紧跟迭代器要返回的值。或者如果用的是 <code>yield*</code>)（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p>
<p><strong>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题。async 相比于 Generator内置了执行器，拥有更好的语义化</strong> </p>
<p><strong>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</strong></p>
<h1 id="typeof-返回的数据类型"><a href="#typeof-返回的数据类型" class="headerlink" title="typeof 返回的数据类型"></a>typeof 返回的数据类型</h1><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1.number</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-number">10</span>);
<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">NaN</span>);<span class="hljs-comment">//NaN在JavaScript中代表的是特殊非数字值,它本身是一个数字类型。</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">Infinity</span>);
<span class="hljs-comment">//2.boolean</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">true</span>);
<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">false</span>);
<span class="hljs-comment">//3.string</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-string">&quot;abc&quot;</span>);
<span class="hljs-comment">//4.undefined</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">undefined</span>);
<span class="hljs-keyword">typeof</span>(a);<span class="hljs-comment">//不存在的变量</span>
<span class="hljs-comment">//5.object</span>
<span class="hljs-comment">//对象，数组，null返回object</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">null</span>);
<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">window</span>);
<span class="hljs-comment">//6.function</span>
<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">Array</span>);
<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">Date</span>);
<span class="hljs-comment">//7.symbol</span>
<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Symbol</span>() <span class="hljs-comment">// ES6提供的新的类型</span></code></pre></div>





<h1 id="返回-false-的情况有哪些"><a href="#返回-false-的情况有哪些" class="headerlink" title="返回 false 的情况有哪些"></a>返回 false 的情况有哪些</h1><div class="hljs"><pre><code class="hljs js"><span class="hljs-string">&#x27;&#x27;</span><span class="hljs-comment">//空字符</span>
<span class="hljs-number">0</span>
<span class="hljs-literal">NaN</span>
underfind
<span class="hljs-literal">null</span>
<span class="hljs-literal">false</span></code></pre></div>

<p>还有表达式不成立的情况</p>
<h1 id="对-this-的理解"><a href="#对-this-的理解" class="headerlink" title="对 this 的理解"></a>对 this 的理解</h1><p><strong>「<code>this</code> 是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。」</strong></p>
<p><code>this</code> 指的是，**调用函数的那个对象(执行上下文)**。<code>this</code> 永远指向函数运行时所在的对象。</p>
<p>解析器在调用函数每次都会向函数内部传递进一个隐含的参数，这个隐含的参数就是 <code>this</code>。</p>
<p>根据函数的调用方式的不同，<code>this</code> 会指向不同的对象：</p>
<ul>
<li><p>以函数的形式调用时，<code>this</code> 永远都是 <strong>window</strong>。比如：<code>fun()</code> 相当于  <code>window.fun()</code></p>
</li>
<li><p>以方法的形式调用时，<code>this</code> 是调用方法的那个对象。</p>
</li>
<li><p>以构造函数的形式调用时，<code>this</code> 是新创建的那个对象。</p>
</li>
<li><p>使用 <code>call</code> 和 <code>apply</code> 调用时，<code>this</code> 是指定的那个对象。</p>
</li>
</ul>
<p>需要特别提醒的是：<code>this</code> 的指向在函数定义时无法确认，只有函数执行时才能确定。</p>
<p><code>this</code> 的几种场景：</p>
<ul>
<li>作为「构造函数」执行</li>
<li>作为「对象的属性」执行</li>
<li>作为「普通函数」执行</li>
<li><code>call</code>、<code>apply</code>、<code>bind</code></li>
</ul>
<h1 id="new-操作符做了什么"><a href="#new-操作符做了什么" class="headerlink" title="new 操作符做了什么"></a>new 操作符做了什么</h1><ol>
<li>在创建一个新对象出来 (开辟一块新内存)<ol start="2">
<li><code>this</code> 指向这个新对象</li>
<li>执行构造函数的代码（给 <code>this</code> 添加属性）</li>
<li>会返回这个新对象</li>
</ol>
</li>
</ol>
<h1 id="什么是深拷贝什么是浅拷贝"><a href="#什么是深拷贝什么是浅拷贝" class="headerlink" title="什么是深拷贝什么是浅拷贝"></a>什么是深拷贝什么是浅拷贝</h1><p>浅拷贝是创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p>
<p>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象。</p>
<h1 id="对闭包的理解？并能举出闭包的例子"><a href="#对闭包的理解？并能举出闭包的例子" class="headerlink" title="对闭包的理解？并能举出闭包的例子"></a>对闭包的理解？并能举出闭包的例子</h1><p>闭包（closure）：指有权<strong>访问</strong>另一个函数作用域中<strong>变量</strong>的<strong>函数</strong>。</p>
<p>简单理解就是：如果<strong>这个作用域可以访问另外一个函数内部的局部变量</strong>，那就产生了闭包;而另外那个作用域所在的函数称之为<strong>闭包函数</strong>。</p>
<p>注意，这里强调的是访问<strong>局部变量</strong>。</p>
<p>闭包的形成条件: 至少两个函数，并且是嵌套关系。而且内部函数需要访问外部函数的局部变量。</p>
<p>闭包的作用：</p>
<ol>
<li>保护数据（私有变量）的安全</li>
<li>持久化维持数据</li>
<li>实现模块化</li>
</ol>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn1</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn2</span>(<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(a);
    &#125;
    <span class="hljs-keyword">return</span> fn2;
&#125;
<span class="hljs-keyword">const</span> foo = fn1(); <span class="hljs-comment">// 执行 fn1() 之后，会得到一个返回值。foo 代表的就是 fn2 函数</span>
foo();</code></pre></div>

<p>一般来说，在 fn1 函数执行完毕后，它里面的变量 a 会立即销毁。</p>
<p>但此时由于产生了闭包，所以 <strong>fn1 函数中的变量 a 不会立即销毁，因为 fn2 函数还要继续调用变量 a</strong>。只有等所有函数把变量 a 调用完了，变量 a 才会销毁。</p>
<h1 id="什么是原型和原型链"><a href="#什么是原型和原型链" class="headerlink" title="什么是原型和原型链?"></a>什么是原型和原型链?</h1><p>JavaScript 只有一种结构：对象。</p>
<p>每个实例对象（ object ）都有一个私有属性（称之为 <code>__proto__</code> ）指向它的构造函数的原型对象（<code>prototype</code>）。</p>
<p>该原型对象也有一个自己的原型对象( <code>__proto__</code> ) ，层层向上直到一个对象的原型对象为 <code>null</code>。</p>
<p>根据定义，<code>null</code> 没有原型，并作为这个<strong>原型链</strong>中的最后一个环节。</p>
<p>几乎所有 JavaScript 中的对象都是位于原型链顶端的 <code>Object</code> 的实例。</p>
<h1 id="什么是事件流"><a href="#什么是事件流" class="headerlink" title="什么是事件流"></a>什么是事件流</h1><p><strong>事件流</strong><br>当一个 HTML 元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。</p>
<p>简单地说：事件流就是描述页面中接收事件的顺序。其包含三个阶段：</p>
<ul>
<li>事件捕获：事件从 Document 节点自上而下向目标节点传播的阶段；</li>
<li>目标阶段：真正的目标节点正在处理事件的阶段；</li>
<li>事件冒泡：事件从目标节点自下而上向 Document 节点传播的阶段。</li>
</ul>
<p>在整个事件流的任何位置通过调用事件对象的 <code>stopPropagation()</code> 方法可以停止事件的传播过程。</p>
<p>DOM 同时支持两种事件模型：</p>
<p>捕获型事件(事件句柄在捕获阶段执行) 和 冒泡型事件(事件句柄在冒泡阶段执行) 。现在主流的是冒泡事件。</p>
<h1 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h1><p><strong>防抖</strong> （debounce）：防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。</p>
<p>防抖适用场景：</p>
<ol>
<li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li>
<li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li>
<li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li>
</ol>
<p>可以看出来<strong>防抖重在清零 <code>clearTimeout(timer)</code></strong></p>
<p>代码：</p>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> <span class="hljs-variable">fn</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-variable">wait</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span></span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer;
    <span class="hljs-comment">// 箭头函数始终指向上一层 this</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;
        <span class="hljs-comment">// 使用闭包 timer持久化</span>
        <span class="hljs-built_in">clearTimeout</span>(timer);
        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
            fn(...args);
        &#125;, wait);
    &#125;;
&#125;</code></pre></div>

<p><strong>节流</strong>（throttle）：节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server)及网关(gateway)控制的限流 (Rate Limit) 类似。</p>
<p>节流适用场景：</p>
<ol>
<li><code>scroll</code> 事件，每隔一秒计算一次位置信息等</li>
<li>浏览器播放事件，每个一秒计算一次进度信息等</li>
<li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)</li>
</ol>
<p>可以看出来<strong>节流重在加锁 <code>timer=timeout</code></strong></p>
<p>代码：</p>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/**</span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> <span class="hljs-variable">fn</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-variable">wait</span></span></span>
<span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span> </span></span>
<span class="hljs-comment"> */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;
    <span class="hljs-keyword">let</span> timer;
    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;
        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>;
        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;
            fn(...args);
            timer = <span class="hljs-literal">null</span>;
        &#125;,wait);
    &#125;;
&#125;</code></pre></div>



<h1 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h1><p><strong>浅拷贝:</strong></p>
<p>拷贝对象的一层属性，如果对象里面还有对象，拷贝的是地址，两者之间修改会有影响，适用于对象里面属性的值是简单数据类型的。</p>
<p><strong>深拷贝:</strong></p>
<p>拷贝对象的多层属性，如果对象里面还有对象，会继续拷贝并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变。</p>
<h2 id="深拷贝和浅拷贝的区别："><a href="#深拷贝和浅拷贝的区别：" class="headerlink" title="深拷贝和浅拷贝的区别："></a>深拷贝和浅拷贝的区别：</h2><p>浅拷贝（shallow copy）：只复制指向某个对象的指针，而不复制对象本身，新旧对象共享一块内存；   </p>
<p>深拷贝（deep copy）：复制并创建一个一摸一样的对象，不共享内存，修改新对象，旧对象保持不变.</p>
<h2 id="浅拷贝实现："><a href="#浅拷贝实现：" class="headerlink" title="浅拷贝实现："></a>浅拷贝实现：</h2><h3 id="1、使用-赋值"><a href="#1、使用-赋值" class="headerlink" title="1、使用 = 赋值"></a>1、使用 <code>=</code> 赋值</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//浅拷贝: </span>
<span class="hljs-keyword">var</span> obj = &#123;
    class: &#x27;UI&#x27;,
    age: <span class="hljs-number">20</span>,
    love: <span class="hljs-string">&#x27;eat&#x27;</span>,
&#125;;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getObj</span>(<span class="hljs-params">obj</span>) </span>&#123;
    <span class="hljs-keyword">var</span> newObj = &#123;&#125;;
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> obj) &#123;
        newObj[k] = obj[k];
    &#125;
    <span class="hljs-keyword">return</span> newObj;
&#125;
<span class="hljs-keyword">var</span> obj2 = getObj(obj);
<span class="hljs-built_in">console</span>.log(obj2);</code></pre></div>

<h3 id="2、Object-assign-target-sources"><a href="#2、Object-assign-target-sources" class="headerlink" title="2、Object.assign(target,...sources)"></a>2、<code>Object.assign(target,...sources)</code></h3><blockquote>
<p>Object.assign是ES6的新函数。</p>
</blockquote>
<p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。</p>
<p>但是 Object.assign() 进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p>
<p>参数：</p>
<ul>
<li>target：目标对象。</li>
<li>sources：任意多个源对象。</li>
<li>返回值：目标对象会被返回。</li>
</ul>
<p>需要注意的是：<br><code>Object.assign()</code>可以处理一层的深度拷贝，如下：</p>
<blockquote>
<p>其实是简单类型存储的是具体的数值，本方法还是只拷贝了一层数据</p>
</blockquote>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">30</span> &#125;;
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);
obj2.b = <span class="hljs-number">100</span>;
<span class="hljs-built_in">console</span>.log(obj1);
<span class="hljs-comment">// &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到</span>
<span class="hljs-built_in">console</span>.log(obj2);
<span class="hljs-comment">// &#123; a: 10, b: 100, c: 30 &#125;</span></code></pre></div>

<h2 id="深拷贝实现："><a href="#深拷贝实现：" class="headerlink" title="深拷贝实现："></a>深拷贝实现：</h2><h3 id="1、手动复制"><a href="#1、手动复制" class="headerlink" title="1、手动复制"></a>1、手动复制</h3><blockquote>
<p>笨、效率低下，某些情况下可以，如：临时需要、只需要一个副本，拷贝的对象属性不多</p>
</blockquote>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">20</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">30</span> &#125;;
<span class="hljs-keyword">var</span> obj2 = &#123; <span class="hljs-attr">a</span>: obj1.a, <span class="hljs-attr">b</span>: obj1.b, <span class="hljs-attr">c</span>: obj1.c &#125;;
obj2.b = <span class="hljs-number">100</span>;
<span class="hljs-built_in">console</span>.log(obj1);
<span class="hljs-comment">// &#123; a: 10, b: 20, c: 30 &#125; &lt;-- 沒被改到</span>
<span class="hljs-built_in">console</span>.log(obj2);
<span class="hljs-comment">// &#123; a: 10, b: 100, c: 30 &#125;</span></code></pre></div>

<h2 id="2、JSON-做字符串转换"><a href="#2、JSON-做字符串转换" class="headerlink" title="2、JSON 做字符串转换"></a>2、JSON 做字符串转换</h2><blockquote>
<p>用<code>JSON.stringify()</code>把对象转成字符串，再用<code>JSON.parse()</code>把字符串转成新的对象。</p>
</blockquote>
<div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123; <span class="hljs-attr">body</span>: &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">10</span> &#125; &#125;;
<span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(obj1));
obj2.body.a = <span class="hljs-number">20</span>;
<span class="hljs-built_in">console</span>.log(obj1);
<span class="hljs-comment">// &#123; body: &#123; a: 10 &#125; &#125; &lt;-- 沒被改到</span>
<span class="hljs-built_in">console</span>.log(obj2);
<span class="hljs-comment">// &#123; body: &#123; a: 20 &#125; &#125;</span>
<span class="hljs-built_in">console</span>.log(obj1 === obj2);
<span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(obj1.body === obj2.body);
<span class="hljs-comment">// false</span></code></pre></div>

<p>这样做是真正的Deep Copy，这种方法简单易用。</p>
<p>但是这种方法也有很多的缺点：</p>
<ol>
<li>它会抛弃对象的 <code>constructor</code>，深拷贝之后，不管这个对象原来的构造函数是什么，在深拷贝之后都会变成<code>Object</code>。</li>
<li>只能正确处理 <code>Number</code>, <code>String</code> , <code>Boolean</code> , <code>Array</code> , 扁平对象，即那些能够被 JSON直接表示的数据结构。<code>RegExp</code> 对象是无法通过这种方式深拷贝，只有可以转成 JSON 格式的对象才可以这样用，像 <code>function</code>没办法转成 JSON</li>
</ol>
<h2 id="3、递归拷贝"><a href="#3、递归拷贝" class="headerlink" title="3、递归拷贝"></a>3、递归拷贝</h2><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepClone</span>(<span class="hljs-params">initalObj, finalObj=&#123;&#125;</span>) </span>&#123;    
  <span class="hljs-keyword">var</span> obj = finalObj;    
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i <span class="hljs-keyword">in</span> initalObj) &#123;        
    <span class="hljs-keyword">var</span> prop = initalObj[i];        <span class="hljs-comment">// 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况</span>
    <span class="hljs-keyword">if</span>(prop === obj) &#123;            
      <span class="hljs-keyword">continue</span>;
    &#125;        
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> prop === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;
      obj[i] = (prop.constructor === <span class="hljs-built_in">Array</span>) ? [] : &#123;&#125;;            
      <span class="hljs-built_in">arguments</span>.callee(prop, obj[i]);
    &#125; <span class="hljs-keyword">else</span> &#123;
      obj[i] = prop;
    &#125;
  &#125;    
  <span class="hljs-keyword">return</span> obj;
&#125;
<span class="hljs-keyword">var</span> str = &#123;&#125;;
<span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">21</span>&#125; &#125;;
deepClone(obj, str);
<span class="hljs-built_in">console</span>.log(str.a);</code></pre></div>

<h2 id="4、使用Object-create-方法"><a href="#4、使用Object-create-方法" class="headerlink" title="4、使用Object.create()方法"></a>4、使用<code>Object.create()</code>方法</h2><p>直接使用<code>var newObj = Object.create(oldObj)</code>，可以达到深拷贝的效果。</p>
<h2 id="5、jquery"><a href="#5、jquery" class="headerlink" title="5、jquery"></a>5、jquery</h2><blockquote>
<p>jquery 有提供一个$.extend可以用来做 Deep Copy。</p>
</blockquote>
<h2 id="6、第三方函数"><a href="#6、第三方函数" class="headerlink" title="6、第三方函数"></a>6、第三方函数</h2><blockquote>
<p>还有一些其它的第三方函数库有深拷贝function，如lodash。</p>
</blockquote>
<h1 id="get-和-post-的区别"><a href="#get-和-post-的区别" class="headerlink" title="get 和 post 的区别"></a>get 和 post 的区别</h1><ul>
<li>后退按钮/刷新<ul>
<li>GET 不会重新提交是无害</li>
<li>POST 数据会被重新提交</li>
</ul>
</li>
<li>书签<ul>
<li>GET请求 可以被收藏为书简</li>
<li>POST请求 不可以被收藏为书签</li>
</ul>
</li>
<li>缓存<ul>
<li>GET 请求能被缓存</li>
<li>POST 请求不能缓存</li>
</ul>
</li>
<li>编码类型<ul>
<li>GET 只支持application/x-www-form-urlencoded</li>
<li>POST 不光支持查询字符串的编码还支持 二进制数据 FormDate的编码</li>
</ul>
</li>
<li>历史<ul>
<li>GET 参数会被保存在浏览器历史中</li>
<li>POST 参数不会被保存在浏览器历史中</li>
</ul>
</li>
<li>对数据长度限制<ul>
<li>GET方法向URL添加数据，URL长度是受限制的，为2048个字符</li>
<li>POST没有限制</li>
</ul>
</li>
<li>对数据类型限制<ul>
<li>GET 只允许 ASCII 字符。</li>
<li>POST 没有限制，也允许二进制数据</li>
</ul>
</li>
<li>安全性<ul>
<li>GET安全性差 数据在URL可见</li>
<li>POST安全性比GET好</li>
</ul>
</li>
</ul>
<p>从标准上来看，GET 和 POST 的区别如下：</p>
<ul>
<li>GET 用于获取信息，是无副作用的，是幂等的，且可缓存</li>
<li>POST 用于修改服务器上的数据，有副作用，非幂等，不可缓存</li>
</ul>
<h1 id="HTTP-的状态码有哪些"><a href="#HTTP-的状态码有哪些" class="headerlink" title="HTTP 的状态码有哪些"></a>HTTP 的状态码有哪些</h1><p>常见的HTTP状态码:</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 永久重定向</li>
<li>404 - 客户端请求的语法错误，服务器无法理解</li>
<li>500 - 服务器端在执行时发生错误，无法完成请求</li>
</ul>
<h1 id="JSONP-的原理？以及优缺点"><a href="#JSONP-的原理？以及优缺点" class="headerlink" title="JSONP 的原理？以及优缺点"></a>JSONP 的原理？以及优缺点</h1><p>JSONP 的原理</p>
<p>由于同源策略不会阻止动态脚本的插入到文档中去</p>
<p>JSONP（即 json + padding）动态创建 script 标签利用 script 标签的 src 属性可以获取任何域下的 JS 脚本，通过这个特性服务器端不在返回 json 格式，而是返回一段调用某个函数的 JS 代码，在 src 中进行了调用，这样实现了跨域。</p>
<p>JSONP 优点:</p>
<p>由于JSONP对于老浏览器兼容性方面比较良好，因此，对于那些对IE8以下仍然需要支持的网站来说，仍然被广泛应用。不过，针对高级浏览器，建议还是用CORS 方法。</p>
<p>JSONP缺点:</p>
<ol>
<li><p>首先，它没有关于 JSONP 调用的错误处理，一旦回调函数调用失败，浏览器会以静默失败的方式处理。</p>
</li>
<li><p>其次，它只支持 GET 请求，这是由于该技术本身的特性所决定的。因此，对于一些需要对安全性有要求的跨域请求，JSONP 的使用需要谨慎一点了。</p>
</li>
<li><p>JSONP 不支持用 <code>async:false</code> 的方法设置同步。</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/JavaScript/">JavaScript</a>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-primary">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/30/Vue%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/">
                        <span class="hidden-mobile">Vue 双向数据绑定</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <span>Power by</span>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"
        ><span>Hexo</span></a
      >
      <i class="iconfont icon-love"></i><span>Theme</span>
      <a
        href="https://github.com/fluid-dev/hexo-theme-fluid"
        target="_blank"
        rel="nofollow noopener"
      >
        <span>Fluid</span></a
      >
    </div>
    
 
 
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "《温故而知新》JavaScript&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
