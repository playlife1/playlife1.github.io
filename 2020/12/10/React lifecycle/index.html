

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=&#34;light&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.ico">
  <link rel="icon" type="image/png" href="/img/favicon.ico">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#153e90">
  <meta name="description" content="">
  <meta name="author" content="playlife">
  <meta name="keywords" content="">
  <title>React 组件生命周期 - playlife</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/night-owl.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_pf9vaxs7x7b.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_2101544_ifd43zekazn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>playlife</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                
                Tag
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                
                About
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/post_page.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-12-10 15:38" pubdate>
        2020-12-10th 03:38:23 PM
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      4.6k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      53
       分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">React 组件生命周期</h1>
            
            <div class="markdown-body" id="post-body">
              <h1 id="React-Component-🌟"><a href="#React-Component-🌟" class="headerlink" title="React.Component 🌟"></a>React.Component 🌟</h1><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>React 的组件可以定义为 class 或函数的形式。class 组件目前提供了更多的功能，这些功能将在此章节中详细介绍。如需定义 class 组件，需要继承 <code>React.Component</code>：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Welcome</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  render() &#123;
    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, &#123;this.props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
  &#125;
&#125;</code></pre></div>

<p>在 <code>React.Component</code> 的子类中有个必须定义的 <code>render()</code> 函数。其他方法均为可选。</p>
<p><strong>我们强烈建议你不要创建自己的组件基类</strong></p>
<p>在 React 组件中，代码重用的主要方式是组合而不是继承。</p>
<h2 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h2><p>每个组件都包含 “生命周期方法”，你可以重写这些方法，以便于在运行过程中特定的阶段执行这些方法。</p>
<p>常用的生命周期方法会被加粗。其余生命周期函数的使用则相对罕见。</p>
<p><img src="/images/react-lifecycle.jpg" srcset="/img/loading.gif" alt="react-lifecycle"></p>
<h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><p>当组件实例被创建并插入 DOM 中时，其生命周期调用顺序如下：</p>
<ul>
<li><strong><code>constructor()</code></strong></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><strong><code>render()</code></strong></li>
<li><strong><code>componentDidMount()</code></strong></li>
</ul>
<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><p>当组件的 props 或 state 发生变化时会触发更新。组件更新的生命周期调用顺序如下：</p>
<ul>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><strong><code>render()</code></strong></li>
<li><code>getSnapshotBeforeUpdate()</code></li>
<li><strong><code>componentDidUpdate()</code></strong></li>
</ul>
<h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>当组件从 DOM 中移除时会调用如下方法：</p>
<ul>
<li><strong><code>componentWillUnmount()</code></strong></li>
</ul>
<h3 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h3><p>当渲染过程，生命周期，或子组件的构造函数中抛出错误时，会调用如下方法：</p>
<ul>
<li><code>static getDerivedStateFromError()</code></li>
<li><code>componentDidCatch()</code></li>
</ul>
<h2 id="其他-APIs"><a href="#其他-APIs" class="headerlink" title="其他 APIs"></a>其他 APIs</h2><p>组件还提供了一些额外的 API：</p>
<ul>
<li><p><code>setState()</code></p>
</li>
<li><p><code>forceUpdate()</code></p>
<h3 id="class-属性"><a href="#class-属性" class="headerlink" title="class 属性"></a>class 属性</h3></li>
<li><p><code>defaultProps</code></p>
</li>
<li><p><code>displayName</code></p>
</li>
</ul>
<h3 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h3><ul>
<li><code>props</code></li>
<li><code>state</code></li>
</ul>
<h2 id="常用的生命周期方法"><a href="#常用的生命周期方法" class="headerlink" title="常用的生命周期方法"></a>常用的生命周期方法</h2><p><img src="/images/react-lifecycle.jpg" srcset="/img/loading.gif" alt="react-lifecycle"></p>
<h3 id="render"><a href="#render" class="headerlink" title="render()"></a>render()</h3><div class="hljs"><pre><code class="hljs jsx">render()</code></pre></div>

<p><code>render()</code> 方法是 class 组件中唯一必须实现的方法。</p>
<p>当 <code>render</code> 被调用时，它会检查 <code>this.props</code> 和 <code>this.state</code> 的变化并返回以下类型之一：</p>
<ul>
<li><strong>React 元素</strong>。通常通过 JSX 创建。例如，<code>&lt;div /&gt;</code> 会被 React 渲染为 DOM 节点，<code>&lt;MyComponent /&gt;</code> 会被 React 渲染为自定义组件，无论是 <code>&lt;div /&gt;</code> 还是 <code>&lt;MyComponent /&gt;</code> 均为 React 元素。</li>
<li><strong>数组或 fragments</strong>。 使得 render 方法可以返回多个元素。</li>
<li><strong>Portals</strong>。可以渲染子节点到不同的 DOM 子树中。</li>
<li><strong>字符串或数值类型</strong>。它们在 DOM 中会被渲染为文本节点</li>
<li>**布尔类型或 <code>null</code>**。什么都不渲染。（主要用于支持返回 <code>test &amp;&amp; &lt;Child /&gt;</code> 的模式，其中 test 为布尔类型。)</li>
</ul>
<p><code>render()</code> 函数应该为纯函数，这意味着在不修改组件 state 的情况下，每次调用时都返回相同的结果，并且它不会直接与浏览器交互。</p>
<p>如需与浏览器进行交互，请在 <code>componentDidMount()</code> 或其他生命周期方法中执行你的操作。保持 <code>render()</code> 为纯函数，可以使组件更容易思考。</p>
<blockquote>
<p><strong>注意:</strong></p>
<p>如果 <code>shouldComponentUpdate()</code> 返回 false，则不会调用 <code>render()</code>。</p>
</blockquote>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor()"></a>constructor()</h3><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">constructor</span>(props)</code></pre></div>

<p><strong>如果不初始化 state 或不进行方法绑定，则不需要为 React 组件实现构造函数。</strong></p>
<p>在 React 组件挂载之前，会调用它的构造函数。</p>
<p>在为 React.Component 子类实现构造函数时，应在其他语句之前前调用 <code>super(props)</code>。</p>
<p>否则，<code>this.props</code> 在构造函数中可能会出现未定义的 bug。</p>
<p>通常，在 React 中，构造函数仅用于以下两种情况：</p>
<ul>
<li>通过给 <code>this.state</code> 赋值对象来初始化内部 state</li>
<li>为事件处理函数绑定实例</li>
</ul>
<p>在 <code>constructor()</code> 函数中<strong>不要调用 <code>setState()</code> 方法</strong>。</p>
<p>如果你的组件需要使用内部 state，请直接在构造函数中为 <strong><code>this.state</code> 赋值初始 state</strong>：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">constructor</span>(props) &#123;
  <span class="hljs-built_in">super</span>(props);
  <span class="hljs-comment">// 不要在这里调用 this.setState()</span>
  <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">counter</span>: <span class="hljs-number">0</span> &#125;;
  <span class="hljs-built_in">this</span>.handleClick = <span class="hljs-built_in">this</span>.handleClick.bind(<span class="hljs-built_in">this</span>);
&#125;</code></pre></div>

<p>只能在构造函数中直接为 <code>this.state</code> 赋值。如需在其他方法中赋值，你应使用 <code>this.setState()</code> 替代。</p>
<p>要避免在构造函数中引入任何副作用或订阅。如遇到此场景，请将对应的操作放置在 <code>componentDidMount</code> 中。</p>
<blockquote>
<p>注意</p>
<p><strong>避免将 props 的值复制给 state！这是一个常见的错误：</strong></p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">constructor</span>(props) &#123;
<span class="hljs-built_in">super</span>(props);
<span class="hljs-comment">// 不要这样做</span>
<span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">color</span>: props.color &#125;;
&#125;</code></pre></div>

<p>如此做毫无必要（你可以直接使用 <code>this.props.color</code>），同时还产生了 bug（更新 prop 中的 <code>color</code> 时，并不会影响 state）。</p>
<p><strong>只有在你刻意忽略 prop 更新的情况下使用。</strong></p>
<p>此时，应将 prop 重命名为 <code>initialColor</code> 或 <code>defaultColor</code>。</p>
</blockquote>
<h3 id="componentDidMount"><a href="#componentDidMount" class="headerlink" title="componentDidMount()"></a>componentDidMount()</h3><div class="hljs"><pre><code class="hljs jsx">componentDidMount()</code></pre></div>

<p><code>componentDidMount()</code> 会在组件挂载后（插入 DOM 树中）立即调用。</p>
<p>依赖于 DOM 节点的初始化应该放在这里。</p>
<p>如需通过<strong>网络请求获取数据</strong>，此处是实例化请求的好地方。</p>
<p>这个方法是比较适合添加订阅的地方。如果添加了订阅，请不要忘记在 <code>componentWillUnmount()</code> 里取消订阅</p>
<p>你可以在 <code>componentDidMount()</code> 里**直接调用 <code>setState()</code>**。它将触发额外渲染，但此渲染会发生在浏览器更新屏幕之前。</p>
<p>如此保证了即使在 <code>render()</code> 两次调用的情况下，用户也不会看到中间状态。</p>
<p>请谨慎使用该模式，因为它会导致性能问题。</p>
<p>通常，你应该在 <code>constructor()</code> 中初始化 state。如果你的渲染依赖于 DOM 节点的大小或位置，比如实现 modals 和 tooltips 等情况下，你可以使用此方式处理</p>
<h3 id="componentDidUpdate"><a href="#componentDidUpdate" class="headerlink" title="componentDidUpdate()"></a>componentDidUpdate()</h3><div class="hljs"><pre><code class="hljs jsx">componentDidUpdate(prevProps, prevState, snapshot)</code></pre></div>

<p><code>componentDidUpdate()</code> 会在更新后会被立即调用。首次渲染不会执行此方法。</p>
<p>当组件更新后，可以在此处对 DOM 进行操作。</p>
<p>如果你对更新前后的 props 进行了比较，也可以选择在此处进行网络请求。（例如，当 props 未发生变化时，则不会执行网络请求）。</p>
<div class="hljs"><pre><code class="hljs jsx">componentDidUpdate(prevProps) &#123;
  <span class="hljs-comment">// 典型用法（不要忘记比较 props）：</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.props.userID !== prevProps.userID) &#123;
    <span class="hljs-built_in">this</span>.fetchData(<span class="hljs-built_in">this</span>.props.userID);
  &#125;
&#125;</code></pre></div>

<p>你也可以在 <code>componentDidUpdate()</code> 中<strong>直接调用 <code>setState()</code>**，但请注意</strong>它必须被包裹在一个条件语句里**，正如上述的例子那样进行处理，否则会导致死循环。</p>
<p>它还会导致额外的重新渲染，虽然用户不可见，但会影响组件性能。</p>
<p>不要将 props “镜像”给 state，请考虑直接使用 props。</p>
<p>如果组件实现了 <code>getSnapshotBeforeUpdate()</code> 生命周期（不常用），则它的返回值将作为 <code>componentDidUpdate()</code> 的第三个参数 “snapshot” 参数传递。否则此参数将为 undefined。</p>
<blockquote>
<p><strong>注意:</strong></p>
<p>如果 <code>shouldComponentUpdate()</code> 返回值为 false，则不会调用 <code>componentDidUpdate()</code>。</p>
</blockquote>
<h3 id="componentWillUnmount"><a href="#componentWillUnmount" class="headerlink" title="componentWillUnmount()"></a>componentWillUnmount()</h3><div class="hljs"><pre><code class="hljs jsx">componentWillUnmount()</code></pre></div>

<p><code>componentWillUnmount()</code> 会在组件卸载及销毁之前直接调用。</p>
<p>在此方法中执行必要的清理操作，例如，清除 timer，取消网络请求或清除在 <code>componentDidMount()</code> 中创建的订阅等。</p>
<p><code>componentWillUnmount()</code> 中**不应调用 <code>setState()</code>**，因为该组件将永远不会重新渲染。组件实例卸载后，将永远不会再挂载它。</p>
<h2 id="不常用的生命周期方法"><a href="#不常用的生命周期方法" class="headerlink" title="不常用的生命周期方法"></a>不常用的生命周期方法</h2><p>这些生命周期方法并不太常用。它们偶尔会很方便，但是大部分情况下组件可能都不需要它们。</p>
<h3 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate()"></a>shouldComponentUpdate()</h3><div class="hljs"><pre><code class="hljs jsx">shouldComponentUpdate(nextProps, nextState)</code></pre></div>

<p>根据 <code>shouldComponentUpdate()</code> 的返回值，判断 React 组件的输出是否受当前 state 或 props 更改的影响。</p>
<p>默认行为是 state 每次发生变化组件都会重新渲染。大部分情况下，你应该遵循默认行为。</p>
<p>当 props 或 state 发生变化时，<code>shouldComponentUpdate()</code> 会在渲染执行之前被调用。返回值默认为 true。</p>
<p>首次渲染或使用 <code>forceUpdate()</code> 时不会调用该方法。</p>
<p>此方法仅作为<strong>性能优化的方式</strong>而存在。不要企图依靠此方法来“阻止”渲染，因为这可能会产生 bug。你应该<strong>考虑使用内置的 <code>PureComponent</code> 组件</strong>，而不是手动编写 <code>shouldComponentUpdate()</code>。<code>PureComponent</code> 会对 props 和 state 进行浅层比较，并减少了跳过必要更新的可能性。</p>
<p>如果你一定要手动编写此函数，可以将 <code>this.props</code> 与 <code>nextProps</code> 以及 <code>this.state</code> 与<code>nextState</code> 进行比较，并返回 <code>false</code> 以告知 React 可以跳过更新。请注意，返回 <code>false</code> 并不会阻止子组件在 state 更改时重新渲染。</p>
<p>不建议在 <code>shouldComponentUpdate()</code> 中进行深层比较或使用 <code>JSON.stringify()</code>。这样非常影响效率，且会损害性能。</p>
<p>目前，如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会调用 <code>UNSAFE_componentWillUpdate()</code>，<code>render()</code> 和 <code>componentDidUpdate()</code>。后续版本，React 可能会将 <code>shouldComponentUpdate</code> 视为提示而不是严格的指令，并且，当返回 <code>false</code> 时，仍可能导致组件重新渲染。</p>
<h3 id="static-getDerivedStateFromProps"><a href="#static-getDerivedStateFromProps" class="headerlink" title="static getDerivedStateFromProps()"></a>static getDerivedStateFromProps()</h3><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> getDerivedStateFromProps(props, state)</code></pre></div>

<p><code>getDerivedStateFromProps</code> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。</p>
<p>它应返回一个对象来更新 state，如果返回 <code>null</code> 则不更新任何内容。</p>
<p>此方法适用于罕见的用例，即 state 的值在任何时候都取决于 props。例如，实现 <code>&lt;Transition&gt;</code> 组件可能很方便，该组件会比较当前组件与下一组件，以决定针对哪些组件进行转场动画。</p>
<blockquote>
<p>什么时候使用派生 state ?</p>
<p><code>getDerivedStateFromProps</code> 的存在只有一个目的：让组件在 <strong>props 变化</strong>时更新 state。</p>
</blockquote>
<p>派生状态会导致代码冗余，并使组件难以维护。</p>
<p>请注意，不管原因是什么，都会在<em>每次</em>渲染前触发此方法。这与 <code>UNSAFE_componentWillReceiveProps</code> 形成对比，后者仅在父组件重新渲染时触发，而不是在内部调用 <code>setState</code> 时。</p>
<h3 id="getSnapshotBeforeUpdate-处理滚动位置的聊天线程"><a href="#getSnapshotBeforeUpdate-处理滚动位置的聊天线程" class="headerlink" title="getSnapshotBeforeUpdate() 处理滚动位置的聊天线程"></a>getSnapshotBeforeUpdate() 处理滚动位置的聊天线程</h3><div class="hljs"><pre><code class="hljs jsx">getSnapshotBeforeUpdate(prevProps, prevState)</code></pre></div>

<p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。</p>
<p>它使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。</p>
<p>此生命周期的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p>
<p>此用法并不常见，但它可能出现在 UI 处理中，如需要以特殊方式处理滚动位置的聊天线程等。</p>
<p>应返回 snapshot 的值（或 <code>null</code>）。</p>
<p>例如：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ScrollingList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-keyword">constructor</span>(props) &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.listRef = React.createRef();
  &#125;

  getSnapshotBeforeUpdate(prevProps, prevState) &#123;
    <span class="hljs-comment">// 我们是否在 list 中添加新的 items ？</span>
    <span class="hljs-comment">// 捕获滚动位置以便我们稍后调整滚动位置。</span>
    <span class="hljs-keyword">if</span> (prevProps.list.length &lt; <span class="hljs-built_in">this</span>.props.list.length) &#123;
      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;
      <span class="hljs-keyword">return</span> list.scrollHeight - list.scrollTop;
    &#125;
    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  &#125;

  componentDidUpdate(prevProps, prevState, snapshot) &#123;
    <span class="hljs-comment">// 如果我们 snapshot 有值，说明我们刚刚添加了新的 items，</span>
    <span class="hljs-comment">// 调整滚动位置使得这些新 items 不会将旧的 items 推出视图。</span>
    <span class="hljs-comment">//（这里的 snapshot 是 getSnapshotBeforeUpdate 的返回值）</span>
    <span class="hljs-keyword">if</span> (snapshot !== <span class="hljs-literal">null</span>) &#123;
      <span class="hljs-keyword">const</span> list = <span class="hljs-built_in">this</span>.listRef.current;
      list.scrollTop = list.scrollHeight - snapshot;
    &#125;
  &#125;

  render() &#123;
    <span class="hljs-keyword">return</span> (
      &lt;div ref=&#123;<span class="hljs-built_in">this</span>.listRef&#125;&gt;&#123;<span class="hljs-comment">/* ...contents... */</span>&#125;&lt;/div&gt;
    );
  &#125;
&#125;</code></pre></div>

<p>在上述示例中，重点是从 <code>getSnapshotBeforeUpdate</code> 读取 <code>scrollHeight</code> 属性，因为 “render” 阶段生命周期（如 <code>render</code>）和 “commit” 阶段生命周期（如 <code>getSnapshotBeforeUpdate</code> 和 <code>componentDidUpdate</code>）之间可能存在延迟。</p>
<h3 id="Error-boundaries"><a href="#Error-boundaries" class="headerlink" title="Error boundaries"></a>Error boundaries</h3><p>Error boundaries（错误边界） 是 React 组件，它会在其子组件树中的任何位置捕获 JavaScript 错误，并记录这些错误，展示降级 UI 而不是崩溃的组件树。</p>
<p>Error boundaries 组件会捕获在渲染期间，在生命周期方法以及其整个树的构造函数中发生的错误。</p>
<p>如果 class 组件定义了生命周期方法:</p>
<ul>
<li><p><code>static getDerivedStateFromError()</code> </p>
</li>
<li><p><code>componentDidCatch()</code> </p>
</li>
</ul>
<p>中的任何一个（或两者），它就成为了 Error boundaries。</p>
<p>通过生命周期更新 state 可让组件捕获树中未处理的 JavaScript 错误并展示降级 UI。</p>
<p>仅使用 Error boundaries 组件来从意外异常中恢复的情况；<strong>不要将它们用于流程控制。</strong></p>
<blockquote>
<p>注意:</p>
<p>Error boundaries 仅捕获组件树中<strong>以下</strong>组件中的错误。但它本身的错误无法捕获。</p>
</blockquote>
<h3 id="static-getDerivedStateFromError-处理降级渲染"><a href="#static-getDerivedStateFromError-处理降级渲染" class="headerlink" title="static getDerivedStateFromError() 处理降级渲染"></a>static getDerivedStateFromError() 处理降级渲染</h3><div class="hljs"><pre><code class="hljs jsx"><span class="hljs-keyword">static</span> getDerivedStateFromError(error)</code></pre></div>

<p>此生命周期会在<strong>「后代组件」</strong>抛出错误后被调用。 它将抛出的错误作为参数，并返回一个值以更新 state</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-keyword">constructor</span>(props) &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;
  &#125;

  <span class="hljs-keyword">static</span> getDerivedStateFromError(error) &#123;
    <span class="hljs-comment">// 更新 state 使下一次渲染可以显降级 UI</span>
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;
  &#125;

  render() &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;
      <span class="hljs-comment">// 你可以渲染任何自定义的降级  UI</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;
  &#125;
&#125;</code></pre></div>

<blockquote>
<p>注意</p>
<p><code>getDerivedStateFromError()</code> 会在<code>渲染</code>阶段调用，因此不允许出现副作用。 </p>
<p>如遇此类情况，请改用 <code>componentDidCatch()</code>。</p>
</blockquote>
<h3 id="componentDidCatch"><a href="#componentDidCatch" class="headerlink" title="componentDidCatch()"></a>componentDidCatch()</h3><div class="hljs"><pre><code class="hljs jsx">componentDidCatch(error, info)</code></pre></div>

<p>此生命周期在<strong>「后代组件」</strong>抛出错误后被调用。 它接收两个参数：</p>
<ol>
<li><code>error</code> —— 抛出的错误。</li>
<li><code>info</code> —— 带有 <code>componentStack</code> key 的对象，其中包含有关组件引发错误的栈信息。</li>
</ol>
<p><code>componentDidCatch()</code> 会在“提交”阶段被调用，因此允许执行副作用。 它应该用于记录错误之类的情况：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorBoundary</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-keyword">constructor</span>(props) &#123;
    <span class="hljs-built_in">super</span>(props);
    <span class="hljs-built_in">this</span>.state = &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span> &#125;;
  &#125;

  <span class="hljs-keyword">static</span> getDerivedStateFromError(error) &#123;
    <span class="hljs-comment">// 更新 state 使下一次渲染可以显示降级 UI</span>
    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">hasError</span>: <span class="hljs-literal">true</span> &#125;;
  &#125;

  componentDidCatch(error, info) &#123;
    <span class="hljs-comment">// &quot;组件堆栈&quot; 例子:</span>
    <span class="hljs-comment">//   in ComponentThatThrows (created by App)</span>
    <span class="hljs-comment">//   in ErrorBoundary (created by App)</span>
    <span class="hljs-comment">//   in div (created by App)</span>
    <span class="hljs-comment">//   in App</span>
    logComponentStackToMyService(info.componentStack);
  &#125;

  render() &#123;
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.state.hasError) &#123;
      <span class="hljs-comment">// 你可以渲染任何自定义的降级 UI</span>
      <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Something went wrong.<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span>;
    &#125;

    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.props.children;
  &#125;
&#125;</code></pre></div>

<p>React 的开发和生产构建版本在 <code>componentDidCatch()</code> 的方式上有轻微差别。</p>
<p>在开发模式下，错误会冒泡至 <code>window</code>，这意味着任何 <code>window.onerror</code> 或 <code>window.addEventListener(&#39;error&#39;, callback)</code> 会中断这些已经被 <code>componentDidCatch()</code> 捕获的错误。</p>
<p>相反，在开发模式下，错误不会冒泡，这意味着任何根错误处理器只会接受那些没有显式地被 <code>componentDidCatch()</code> 捕获的错误。</p>
<blockquote>
<p>注意:</p>
<p>如果发生错误，你可以通过调用 <code>setState</code> 使用 <code>componentDidCatch()</code> 渲染降级 UI，但在未来的版本中将不推荐这样做。 可以使用静态 <code>getDerivedStateFromError()</code> 来处理降级渲染。</p>
</blockquote>
<h2 id="setState-和-forceUpdate"><a href="#setState-和-forceUpdate" class="headerlink" title="setState() 和 forceUpdate()"></a>setState() 和 forceUpdate()</h2><p>不同于生命周期方法（React 主动调用），以下是手动可以在组件中调用的方法。</p>
<p>只有两个方法：<code>setState()</code> 和 <code>forceUpdate()</code>。</p>
<h3 id="setState"><a href="#setState" class="headerlink" title="setState()"></a>setState()</h3><div class="hljs"><pre><code class="hljs jsx">setState(updater, [callback])</code></pre></div>

<p><code>setState()</code> 将对组件 state 的更改排入队列，并通知 React 需要使用更新后的 state 重新渲染此组件及其子组件。</p>
<p>这是用于更新用户界面以响应事件处理器和处理服务器数据的主要方式</p>
<p>将 <code>setState()</code> 视为 <em>请求</em> 而不是立即更新组件的命令。</p>
<p>为了更好的感知性能，React 会延迟调用它，然后通过一次传递更新多个组件。React 并不会保证 state 的变更会立即生效。</p>
<p><code>setState()</code> 并不总是立即更新组件。它会批量推迟更新。这使得在调用 <code>setState()</code> 后立即读取 <code>this.state</code> 成为了隐患。</p>
<p>为了消除隐患，请使用 <code>componentDidUpdate</code> 或者 <code>setState</code> 的回调函数（<code>setState(updater, callback)</code>），这两种方式都可以保证在应用更新后触发。</p>
<p>如需基于之前的 state 来设置当前的 state：</p>
<p>除非 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，否则 <code>setState()</code> 将始终执行重新渲染操作。</p>
<p>如果可变对象被使用，且无法在 <code>shouldComponentUpdate()</code> 中实现条件渲染，那么仅在新旧状态不一时调用 <code>setState()</code>可以避免不必要的重新渲染</p>
<p>参数一为带有形式参数的 <code>updater</code> 函数：</p>
<div class="hljs"><pre><code class="hljs jsx">(state, props) =&gt; stateChange</code></pre></div>

<p><code>state</code> 是对应用变化时组件状态的引用。</p>
<p>当然，它不应直接被修改。你应该使用基于 <code>state</code> 和 <code>props</code> 构建的新对象来表示变化。例如，假设我们想根据 <code>props.step</code> 来增加 state：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state, props</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">counter</span>: state.counter + props.step&#125;;
&#125;);</code></pre></div>

<p>updater 函数中接收的 <code>state</code> 和 <code>props</code> 都保证为最新。updater 的返回值会与 <code>state</code> 进行浅合并。</p>
<p><code>setState()</code> 的第二个参数为可选的回调函数，它将在 <code>setState</code> 完成合并并重新渲染组件后执行。通常，我们建议使用 <code>componentDidUpdate()</code> 来代替此方式。</p>
<p><code>setState()</code> 的第一个参数除了接受函数外，还可以接受对象类型：</p>
<div class="hljs"><pre><code class="hljs jsx">setState(stateChange[, callback])</code></pre></div>

<p><code>stateChange</code> 会将传入的对象浅层合并到新的 state 中，例如，调整购物车商品数：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">quantity</span>: <span class="hljs-number">2</span>&#125;)</code></pre></div>

<p>这种形式的 <code>setState()</code> 也是异步的，并且在同一周期内会对多个 <code>setState</code> 进行批处理。</p>
<p>例如，如果在同一周期内多次设置商品数量增加，则相当于：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-built_in">Object</span>.assign(
  previousState,
  &#123;<span class="hljs-attr">quantity</span>: state.quantity + <span class="hljs-number">1</span>&#125;,
  &#123;<span class="hljs-attr">quantity</span>: state.quantity + <span class="hljs-number">1</span>&#125;,
  ...
)</code></pre></div>

<p>后调用的 <code>setState()</code> 将覆盖同一周期内先调用 <code>setState</code> 的值，因此商品数仅增加一次。</p>
<p>如果后续状态取决于当前状态，我们建议使用 updater 函数的形式代替：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">state</span>) =&gt;</span> &#123;
  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">quantity</span>: state.quantity + <span class="hljs-number">1</span>&#125;;
&#125;);</code></pre></div>



<h3 id="forceUpdate"><a href="#forceUpdate" class="headerlink" title="forceUpdate()"></a>forceUpdate()</h3><div class="hljs"><pre><code class="hljs jsx">component.forceUpdate(callback)</code></pre></div>

<p>默认情况下，当组件的 state 或 props 发生变化时，组件将重新渲染。</p>
<p>如果 <code>render()</code> 方法依赖于其他数据，则可以调用 <code>forceUpdate()</code> 强制让组件重新渲染。</p>
<p>调用 <code>forceUpdate()</code> 将致使组件调用 <code>render()</code> 方法，此操作会跳过该组件的 <code>shouldComponentUpdate()</code>。</p>
<p>但其子组件会触发正常的生命周期方法，包括 <code>shouldComponentUpdate()</code> 方法。如果标记发生变化，React 仍将只更新 DOM。</p>
<p>通常你应该避免使用 <code>forceUpdate()</code>，尽量在 <code>render()</code> 中使用 <code>this.props</code> 和 <code>this.state</code>。</p>
<h2 id="Class-属性"><a href="#Class-属性" class="headerlink" title="Class 属性"></a>Class 属性</h2><h3 id="defaultProps"><a href="#defaultProps" class="headerlink" title="defaultProps"></a>defaultProps</h3><p><code>defaultProps</code> 可以为 Class 组件添加默认 props。</p>
<p>这一般用于 props 未赋值，但又不能为 <code>null</code> 的情况。例如：</p>
<div class="hljs"><pre><code class="hljs jsx"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomButton</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;
  <span class="hljs-comment">// ...</span>
&#125;

CustomButton.defaultProps = &#123;
  color: <span class="hljs-string">&#x27;blue&#x27;</span>
&#125;;</code></pre></div>

<p>如果未提供 <code>props.color</code>，则默认设置为 <code>&#39;blue&#39;</code></p>
<div class="hljs"><pre><code class="hljs jsx">render() &#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomButton</span> /&gt;</span></span> ; <span class="hljs-comment">// props.color 将设置为 &#x27;blue&#x27;</span>
&#125;</code></pre></div>

<p>如果 <code>props.color</code> 被设置为 <code>null</code>，则它将保持为 <code>null</code></p>
<div class="hljs"><pre><code class="hljs jsx">render() &#123;
  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">CustomButton</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#123;null&#125;</span> /&gt;</span></span> ; <span class="hljs-comment">// props.color 将保持是 null</span>
&#125;</code></pre></div>

<h3 id="displayName"><a href="#displayName" class="headerlink" title="displayName"></a>displayName</h3><p><code>displayName</code> 字符串多用于调试消息。</p>
<p>通常，你不需要设置它，因为它可以根据函数组件或 class 组件的名称推断出来。</p>
<h2 id="实例属性-1"><a href="#实例属性-1" class="headerlink" title="实例属性"></a>实例属性</h2><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><p><code>this.props</code> 包括被该组件调用者定义的 props。</p>
<p>需特别注意，<code>this.props.children</code> 是一个特殊的 prop，通常由 JSX 表达式中的子组件组成，而非组件本身定义。</p>
<h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>组件中的 state 包含了随时可能发生变化的数据。state 由用户自定义，它是一个普通 JavaScript 对象。</p>
<p>如果某些值未用于渲染或数据流（例如，计时器 ID），则不必将其设置为 state。此类值可以在组件实例上定义。</p>
<p>永远不要直接改变 <code>this.state</code>，因为后续调用的 <code>setState()</code> 可能会替换掉你的改变。请把 <code>this.state</code> 看作是不可变的。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/React/">React</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-primary">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/12/11/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B70/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">《前端100问》70</span>
                        <span class="visible-mobile">Previous</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/12/09/%E6%89%8B%E5%86%99%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95/">
                        <span class="hidden-mobile">手写原生方法</span>
                        <span class="visible-mobile">Next</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                
  <div class="disqus" style="width:100%">
    <div id="disqus_thread"></div>
    <script>
      function loadDisqus() {
        addCssLink('https://cdn.jsdelivr.net/npm/disqusjs@1.0/dist/disqusjs.css');
        addScript('https://cdn.jsdelivr.net/npm/disqusjs@1.0/dist/disqus.js', function () {
          new DisqusJS({
            shortname: 'fluid',
            apikey: 'hvKfdQ2Do0lON1ml44vfDaXi5qJ72hTjbwAgRoxbUliy8PndnwGpouw3trwRxmlx'
          });
        });
      }
      waitElementVisible('disqus_thread', loadDisqus);
    </script>
    <noscript>Please enable JavaScript to view the
      <a target="_blank" href="https://disqus.com/?ref_noscript" rel="nofollow noopener noopener">comments powered by Disqus.</a>
    </noscript>
  </div>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;TOC</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <span>Power by</span>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"
        ><span>Hexo</span></a
      >
      <i class="iconfont icon-love"></i><span>Theme</span>
      <a
        href="https://github.com/fluid-dev/hexo-theme-fluid"
        target="_blank"
        rel="nofollow noopener"
      >
        <span>Fluid</span></a
      >
    </div>
    
 
 
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>







  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "React 组件生命周期&nbsp;",
      ],
      cursorChar: "|",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>




















</body>
</html>
