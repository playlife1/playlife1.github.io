<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Vue 双向数据绑定</title>
    <link href="/2020/11/30/Vue%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/"/>
    <url>/2020/11/30/Vue%20%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A/</url>
    
    <content type="html"><![CDATA[<h1 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h1><p>Vue 在3.0版本之前是利用了 JavaScript ES5 提供的元编程接口 <code>Object.defineProperty</code>进行数据劫持，从而将数据变成了「响应式」的。</p><p>基于「响应式数据」实现了<code>MVVM</code> 数据双向绑定，所谓<code>MVVM</code> 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据。</p><h2 id="Object-defineProperty-的作用"><a href="#Object-defineProperty-的作用" class="headerlink" title="Object.defineProperty 的作用"></a>Object.defineProperty 的作用</h2><p>Vue 2.X 的数据双向绑定都是依据 <code>Object.defineProperty()</code>这一方法来做的</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(obj, prop, descriptor)</code></pre><p><code>Object.defineProperty</code> 方法接收三个参数：</p><ul><li><p><strong>obj</strong></p><p>要定义属性的对象。</p></li><li><p><strong>prop</strong></p><p>要定义或修改的属性的名称或 <code>Symbol</code> 。</p></li><li><p><strong>descriptor</strong></p><p>要定义或修改的属性描述符。</p></li></ul><p>返回值：</p><p>被传递给函数的对象。</p><hr><p>通过这个方法我们可以进行，JavaScript 语言级别的编程（即：对 JavaScript 语言进行编程，使其一些原生的操作可以按我们的逻辑进行执行）。</p><p>简单的说就是可以用这个方法，对一个对象的某个属性的描述符进行定义。</p><p>Vue 进行数据劫持将数据变为响应式的就使用到了描述符当中的 <code>getter</code> 和 <code>setter</code>。</p><ul><li><p><code>get</code>: 当查找某个对象属性时，该对象属性将会与被调用函数绑定。</p></li><li><p><code>set</code>: 当试图设置该属性时，对象属性与被调用函数绑定。</p></li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;  name: <span class="hljs-string">&#x27;playlife&#x27;</span>,  age: <span class="hljs-number">23</span>&#125;obj.age <span class="hljs-comment">//23</span>obj.age = <span class="hljs-number">18</span></code></pre><p>像代码中的两个操作：读取和赋值，就是在访问 <code>obj.age</code> 的 <code>getter</code> 和 <code>setter</code>。</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;age&#x27;</span>, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">18</span> <span class="hljs-comment">//永远18岁</span>  &#125;,  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">newValue</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;不让你设置&#x27;</span>, newValue)  &#125;&#125;)<span class="hljs-built_in">console</span>.log(obj.age)<span class="hljs-comment">//18</span>obj.age = <span class="hljs-number">1</span><span class="hljs-comment">//不让你设置 1</span></code></pre><p><code>getter</code> 和 <code>setter</code> 都是方法函数，所以可以这么写</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(obj, <span class="hljs-string">&#x27;age&#x27;</span>, &#123;  get() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-number">18</span>  &#125;,  set(newValue) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;不让你设置&#x27;</span>, newValue)  &#125;&#125;)</code></pre><p>Vue 的「双向数据绑定」就是根据上面的原理来实现的。</p><p>只要在读取值时收集「观察者」在赋值时触发「观察者的更新函数」就可以实现数据变更，从而实现 DOM 重新渲染。</p><h1 id="Vue-实现双向数据绑定"><a href="#Vue-实现双向数据绑定" class="headerlink" title="Vue 实现双向数据绑定"></a>Vue 实现双向数据绑定</h1><p>在Vue主线里和数据双向绑定有关的有以下几个模块</p><ul><li>Vue 构造函数 <code>new Vue()</code></li><li>观察者 <code>observer</code></li><li>观察者 <code>watcher</code></li><li>指令系统 <code>directive类</code>和<code>directives指令函数</code>集合</li><li>DOM 解析 <code>compile</code></li><li><code>watcher</code> 与 <code>observer</code> 之间的联系者 <code>dep</code></li></ul><p><img src="/images/vue-mvvm.jpg" alt="vue-mvvm"></p><p>结合以上 Vue 源码各模块函数关系图来复述一个 Vue的实现过程：</p><h2 id="实例化之前"><a href="#实例化之前" class="headerlink" title="实例化之前"></a>实例化之前</h2><p>在引入Vue文件时 Vue本身会有几个类函数和一个处理函数集合</p><ul><li>observer</li><li>watcher</li><li>dep</li><li>directive</li><li>directives </li></ul><h2 id="实例化过程"><a href="#实例化过程" class="headerlink" title="实例化过程"></a>实例化过程</h2><p>首先会调用 <code>initData()</code>  <code>initMethods()</code>等一系列方法，将数据挂载到 Vue实例上。这样就可以通过 <code>vm.xxx</code> 或者 <code>vm.$xxx</code>直接读取数据和调用函数。</p><p>接下来会调用<code>observe(data)</code>对数据进行监听。其实就是使用<code>Object.defineProperty()</code>方法，对每一个 <strong>key</strong> 都建立一个 <code>dep</code>实例。</p><p>并且在 <code>getter</code>和<code>setter</code>作了一些设置，当访问这一个 <code>key</code> 的 <code>getter</code>就会触发 <code>getter</code> 函数里的 <code>dep.depend</code>方法收集依赖 (<code>watcher</code>实例)。 </p><p>当对这一个 <strong>key</strong> 赋值时：就会触发<code>setter</code> 里的 <code>dep.notify</code>方法，通知 <code>dep</code> 收集的所有 <code>watcher</code>实例调用<code>update</code>方法进行更新。<code>dep</code> 有一个 <code>watcher</code>实例数组，触发更新遍历这个数组，执行<code>watcher.update()</code>方法。</p><p>上面完成之后就会调用<code>compile</code>函数开始对 DOM 进行解析了。首先会解析节点，然后再解析节点里的<code>&#123;&#123;插值表达式&#125;&#125;</code> 、<code>v-if</code>等指令。</p><p>解析<code>&#123;&#123;插值表达式&#125;&#125;</code> 时会生成一个 <code>text</code> 指令。并把<code>&#123;&#123;插值表达式&#125;&#125;</code> 替换为一个空的文本节点，然后生成一个描述符对象。</p><p>描述符对象收集了后面生成指令实例时所需要的数据、要监听的表达式、对应的文本节点,和指令对应的处理函数。</p><p>然后会将这个描述符当作参数传入<code>directive</code> 类，生成一个指令实例。指令实例执行<code>bind</code>方法，<code>bind</code>方法会将表达式、指令处理函数以及相关的一些参数传给 <code>watcher</code>生成一个<code>watcher</code>实例。</p><p><code>watcher</code> 首次会执行 <code>get</code> 方法对表达式进行求值，然后将得到的值将给 <code>update</code>方法。</p><p><code>update</code> 方法将值传入处理函数对 DOM 进行更新，这样就完成了第一次渲染。</p><h2 id="实例化完成后"><a href="#实例化完成后" class="headerlink" title="实例化完成后"></a>实例化完成后</h2><p>以后每一次更改的数据值，都会触发数据所对应对象属性这个 <strong>key</strong> 的 <code>setter</code> 方法。</p><p><code>setter</code> 方法再触发 <code>dep.notify</code> 通知对应的 <code>watcher</code> 调用<code>update</code>方法进行更新。</p><p><code>update</code>方法再把值传给对应的处理函数，再一次进行 DOM 渲染，如此循环往复。</p><p>其他的指令也是按照这一流程来运行的！</p><p><img src="/images/data.png" alt="data"></p><blockquote><p>此时，看着这张图就不会再一脸懵逼了！</p></blockquote><h1 id="Object-defineProperty-的缺陷"><a href="#Object-defineProperty-的缺陷" class="headerlink" title="Object.defineProperty 的缺陷"></a>Object.defineProperty 的缺陷</h1><blockquote><p>Vue3.0 采用了 Proxy，抛弃了Object.defineProperty？</p></blockquote><ol><li><code>Object.defineProperty</code>无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li><li><code>Object.defineProperty</code>只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。<code>Proxy</code>可以劫持整个对象，并返回一个新的对象。</li><li><code>Proxy</code>不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li></ol><h2 id="对于数组"><a href="#对于数组" class="headerlink" title="对于数组"></a>对于数组</h2><p><code>Object.defineProperty</code> 无法监控到数组下标的变化，导致直接通过数组的下标给数组设置值，不能实时响应。 为了解决这个问题，经过 Vue 内部处理后可以使用以下几种方法来监听数组:</p><pre><code class="hljs js">push()pop()shift()unshift()splice()sort()reverse()</code></pre><blockquote><p>由于只针对了以上八种方法进行了hack处理,所以其他数组的属性也是检测不到的，还是具有一定的局限性。</p></blockquote><h2 id="对于对象"><a href="#对于对象" class="headerlink" title="对于对象"></a>对于对象</h2><p><code>Object.defineProperty</code> 还无法监控到对象属性的添加或移除。由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 <code>data</code> 对象上存在才能让 Vue 将它转换为响应式的。</p><p>对于已经创建的实例，Vue 不允许动态添加根级别的响应式 property。但是，可以使用 <code>Vue.set(object, propertyName, value)</code> 方法向嵌套对象添加响应式 property。</p><p>还可以使用 <code>vm.$set</code> 实例方法，这也是全局 <code>Vue.set</code> 方法的别名</p><h1 id="Proxy-实现的双向绑定的特点"><a href="#Proxy-实现的双向绑定的特点" class="headerlink" title="Proxy 实现的双向绑定的特点"></a>Proxy 实现的双向绑定的特点</h1><p>语法：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)</code></pre><ul><li>handler：包含捕捉器（trap）的占位符对象，可译为处理器对象。</li><li>target：被 Proxy 代理的对象。</li></ul><p>Proxy 的优点：</p><p>Proxy 可以直接监听对象而非属性</p><p>Proxy 可以直接监听数组的变化</p><p>Proxy 有多达13种拦截方法,不限于apply、ownKeys、deleteProperty、has等等是<code>Object.defineProperty</code>不具备的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《前端100问》50</title>
    <link href="/2020/11/23/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B50/"/>
    <url>/2020/11/23/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B50/</url>
    
    <content type="html"><![CDATA[<h1 id="41、下面代码输出什么"><a href="#41、下面代码输出什么" class="headerlink" title="41、下面代码输出什么"></a>41、下面代码输出什么</h1><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//undefined</span>    a = <span class="hljs-number">5</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a)<span class="hljs-comment">//10</span>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">20</span>;    <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//20</span>&#125;)()</code></pre><p>分别为 <code>undefined</code>　<code>10</code>　<code>20</code>，原因是作用域问题</p><p>在内部声名<code>var a = 20</code>；相当于先声明 <code>var a </code>然后再执行赋值操作，这是在 <strong>IIFE</strong> 内形成的独立作用域。</p><p>如果把 <code>var a=20</code>注释掉，那么 <code>a</code> 只有在外部有声明，显示的就是外部的 <code>a</code> 变量的值了。结果 <code>a</code> 会是 <code>10</code>　<code>5</code>　<code>5</code></p><h1 id="42、实现一个-sleep-函数"><a href="#42、实现一个-sleep-函数" class="headerlink" title="42、实现一个 sleep 函数"></a>42、实现一个 sleep 函数</h1><blockquote><p>比如 sleep(1000) 意味着等待1000毫秒，可从 Promise、Generator、Async/Await 等角度实现</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// Promise 实现</span><span class="hljs-keyword">const</span> sleep = <span class="hljs-function"><span class="hljs-params">time</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))sleep(<span class="hljs-number">1000</span>).then(<span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;)<span class="hljs-comment">// Generator</span><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">sleepGenerator</span>(<span class="hljs-params">time</span>) </span>&#123;  <span class="hljs-keyword">yield</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))&#125;<span class="hljs-comment">//next() 返回一个由 yield表达式生成的值。，value拿到返回值</span>sleepGenerator(<span class="hljs-number">1000</span>)  .next()  .value.then(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)  &#125;)<span class="hljs-comment">//async</span><span class="hljs-keyword">const</span> sleep = <span class="hljs-function"><span class="hljs-params">time</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, time))<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">output</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">await</span> sleep(<span class="hljs-number">1000</span>)  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;output()<span class="hljs-comment">// ES5 回调函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span>(<span class="hljs-params">callback, time</span>) </span>&#123;  <span class="hljs-built_in">setTimeout</span>(callback, time)&#125;sleep(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">output</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;, <span class="hljs-number">1000</span>)</code></pre><h1 id="43、使用-sort-进行排序，输出结果"><a href="#43、使用-sort-进行排序，输出结果" class="headerlink" title="43、使用 sort() 进行排序，输出结果"></a>43、使用 sort() 进行排序，输出结果</h1><blockquote><p>使用 sort() 对数组 [3, 15, 8, 29, 102, 22] 进行排序，输出结果</p></blockquote><pre><code class="hljs js">[<span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">29</span>, <span class="hljs-number">102</span>, <span class="hljs-number">22</span>].sort() <span class="hljs-comment">// [ 102, 15, 22, 29, 3, 8 ]</span></code></pre><p>根据MDN上对<code>Array.sort()</code>的解释，默认的排序方法会将数组元素转换为字符串，然后比较字符串中字符的UTF-16编码顺序来进行排序。所以<code>&#39;102&#39;</code> 会排在 <code>&#39;15&#39;</code> 前面。</p><p><strong>Array.prototype.sort()</strong></p><blockquote><p><code>sort()</code> 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</p></blockquote><p>返回值:</p><p>排序后的数组。请注意，数组已原地排序，并且不进行复制。</p><pre><code class="hljs js">[<span class="hljs-number">3</span>, <span class="hljs-number">15</span>, <span class="hljs-number">8</span>, <span class="hljs-number">29</span>, <span class="hljs-number">102</span>, <span class="hljs-number">22</span>].sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>) </span>&#123;<span class="hljs-keyword">return</span> a-b;&#125;)<span class="hljs-comment">//输出： [3, 8, 15, 22, 29, 102]</span></code></pre><h1 id="44、介绍-HTTPS-握手过程"><a href="#44、介绍-HTTPS-握手过程" class="headerlink" title="44、介绍 HTTPS 握手过程"></a>44、介绍 HTTPS 握手过程</h1><h2 id="一、Client-→-Server"><a href="#一、Client-→-Server" class="headerlink" title="一、Client → Server"></a>一、Client → Server</h2><h3 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h3><p>握手开始时，总是由先客户端会发送 <code>Client Hello</code> 信息给服务端，主要包含</p><ul><li>Version Number 客户端支持的协议版本</li><li>Randomly Generated Data 32 字节长度的随机值，用于之后生成主密钥。</li><li>Session Identification Session ID，第一次连接时为空。</li><li>Cipher Suite 客户端支持的加密算法列表，按优先级顺序排列。</li></ul><h2 id="二、Server-→-Client"><a href="#二、Server-→-Client" class="headerlink" title="二、Server → Client"></a>二、Server → Client</h2><h3 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h3><p>接着，服务端收到客户端发来的消息之后，会返回 <code>Server Hello</code> 信息给客户端，告知客户端接下来使用的一些参数</p><ul><li>Version Number 通信协议版本</li><li>Randomly Generated Data 32 字节长度的随机值，用于之后生成主密钥</li><li>Session Identification Session ID</li><li>Cipher Suite 加密算法</li></ul><h3 id="Server-Certificate-证书"><a href="#Server-Certificate-证书" class="headerlink" title="Server Certificate 证书"></a>Server Certificate 证书</h3><p>服务端还会带上证书返回给客户端。证书中含有服务端的公钥、网站地址、证书的颁发机构等信息。</p><p>客户端收到服务端返回的证书之后，会验证该证书的真实合法性。</p><h3 id="Server-Key-Exchange-额外数据"><a href="#Server-Key-Exchange-额外数据" class="headerlink" title="Server Key Exchange 额外数据"></a>Server Key Exchange 额外数据</h3><p>这个是可选的，取决于使用的加密算法。主要是携带密钥交换的额外数据。</p><h3 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h3><p>表示服务端已经发送完毕，并等待客户端回应。</p><h2 id="三、Client-→-Server"><a href="#三、Client-→-Server" class="headerlink" title="三、Client → Server"></a>三、Client → Server</h2><h3 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h3><p>客户端使用之前发送给服务端及服务端返回的随机数，生成预主密钥，然后用服务端返回的公钥进行加密。</p><h3 id="Change-Cipher-Spec"><a href="#Change-Cipher-Spec" class="headerlink" title="Change Cipher Spec"></a>Change Cipher Spec</h3><p>告诉服务端，之后的所有信息都会使用协商好的密钥和算法加密</p><h3 id="Client-Finished"><a href="#Client-Finished" class="headerlink" title="Client Finished"></a>Client Finished</h3><p>客户端的握手工作已经完成。这条信息是握手过程中所有消息的散列值。</p><h2 id="四、Server-→-Client"><a href="#四、Server-→-Client" class="headerlink" title="四、Server → Client"></a>四、Server → Client</h2><h3 id="Change-Cipher-Spec-Message"><a href="#Change-Cipher-Spec-Message" class="headerlink" title="Change Cipher Spec Message"></a>Change Cipher Spec Message</h3><p>告知客户端，会使用刚刚协商的密钥来加密信息</p><h3 id="Server-Finished-Message"><a href="#Server-Finished-Message" class="headerlink" title="Server Finished Message"></a>Server Finished Message</h3><p>表示服务端的握手工作已经完成</p><h2 id="数字证书申请流程"><a href="#数字证书申请流程" class="headerlink" title="数字证书申请流程"></a>数字证书申请流程</h2><ol><li>网站提交身份信息给CA机构</li><li>CA机构审核信息的真实性</li><li>对信息进行Hash，计算信息摘要</li><li>CA机构的密钥加密信息摘要，得到数字签名</li></ol><h2 id="浏览器验证证书"><a href="#浏览器验证证书" class="headerlink" title="浏览器验证证书"></a>浏览器验证证书</h2><ol><li>浏览器利用证书的原始信息计算得到信息摘要</li><li>利用CA的公钥解密数字证书中的数字签名，解密出来的数据也是信息摘要</li><li>比较两个摘要是否相等</li></ol><h1 id="45、HTTPS-握手过程中，客户端如何验证证书的合法性"><a href="#45、HTTPS-握手过程中，客户端如何验证证书的合法性" class="headerlink" title="45、HTTPS 握手过程中，客户端如何验证证书的合法性"></a>45、HTTPS 握手过程中，客户端如何验证证书的合法性</h1><ol><li><p>首先浏览器读取证书中的证书所有者、有效期等信息进行校验，校验证书的网站域名是否与证书颁发的域名一致，校验证书是否在有效期内</p></li><li><p>浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发</p></li><li><p>两种情况：</p><ol><li><p>如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。</p></li><li><p>如果找到，那么浏览器就会从操作系统中取出颁发者CA 的公钥(多数浏览器开发商发布<br>版本时，会事先在内部植入常用认证机关的公开密钥)，然后对服务器发来的证书里面的签名进行解密</p></li></ol></li><li><p>浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比</p></li><li><p>对比结果一致，则证明服务器发来的证书合法，没有被冒充</p></li></ol><h1 id="46、输出以下代码执行的结果并解释为什么"><a href="#46、输出以下代码执行的结果并解释为什么" class="headerlink" title="46、输出以下代码执行的结果并解释为什么"></a>46、输出以下代码执行的结果并解释为什么</h1><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">3</span>,    <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">4</span>,    <span class="hljs-string">&#x27;length&#x27;</span>: <span class="hljs-number">2</span>,    <span class="hljs-string">&#x27;splice&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.splice,    <span class="hljs-string">&#x27;push&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.push&#125;obj.push(<span class="hljs-number">1</span>)obj.push(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(obj)</code></pre><p>MDN描述：</p><blockquote><p>push方法将值追加到数组中。</p></blockquote><p><code>push</code> 方法具有通用性。该方法和 <code>call()</code> 或 <code>apply()</code> 一起使用时，可应用在类似数组的对象上。</p><p><code>push</code> 方法根据 <code>length</code> 属性来决定从哪里开始插入给定的值。</p><p>如果 <code>length</code> 不能被转成一个数值，则插入的元素索引为 0，包括 <code>length</code> 不存在时。</p><p>当 <code>length</code> 不存在时，将会创建它。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = &#123;    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">3</span>,    <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">4</span>,    <span class="hljs-string">&#x27;length&#x27;</span>: <span class="hljs-number">2</span>,        <span class="hljs-string">&#x27;push&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.push&#125;obj.push(<span class="hljs-number">1</span>)obj.push(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(obj)<span class="hljs-comment">//打印： &#123;2: 1, 3: 2, length: 4, push: ƒ&#125;</span><span class="hljs-keyword">var</span> obj1 = &#123;    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-number">3</span>,    <span class="hljs-string">&#x27;3&#x27;</span>: <span class="hljs-number">4</span>,    <span class="hljs-string">&#x27;length&#x27;</span>: <span class="hljs-number">2</span>,    <span class="hljs-string">&#x27;splice&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.splice,    <span class="hljs-string">&#x27;push&#x27;</span>: <span class="hljs-built_in">Array</span>.prototype.push&#125;obj1.push(<span class="hljs-number">1</span>)obj1.push(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(obj1)<span class="hljs-comment">//Object(4) [empty × 2, 1, 2, splice: ƒ, push: ƒ]</span><span class="hljs-keyword">var</span> obj2 = &#123;  <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,  <span class="hljs-number">3</span>: <span class="hljs-number">4</span>,  push: <span class="hljs-built_in">Array</span>.prototype.push&#125;obj2.push(<span class="hljs-number">1</span>)obj2.push(<span class="hljs-number">2</span>)<span class="hljs-built_in">console</span>.log(obj2)<span class="hljs-comment">// &#123;0: 1, 1: 2, 2: 3, 3: 4, length: 2, push: ƒ&#125;</span></code></pre><p>解释：</p><p><code>push</code> 方法具有通用性，所以可以给类数组使用。具体是根据类数组的 <code>length</code> 属性，将其转换为数值当做<code>对象[数值]</code>来使用，而对象使用<code>对象[数值]</code>时，数值一律当成字符处理也是就是<code>obj[1]</code>和 <code>obj[&#39;1&#39;]</code>是等价的。</p><p>所以<code>push</code>会解析 <code>length</code>的值 往<code>obj[2]</code> push 一个 <code>1</code> ，所以<code>obj</code> 的属性 <code>2</code> 的值会变成 <code>1</code>，此时 <code>obj</code> 并没有数组的独有方法，所以JS解析器还是会打印一个对象。</p><p>而<code>obj1</code>有一个只有数组的才有的 <code>splice</code> 方法，而且 <code>length</code> 为 <code>4</code> 所以 JS解析器会将其当成数组来打印输出，从下标<code>0</code>开始读数据，但是并没有数据会补空最后输出。</p><h1 id="47、双向绑定和-vuex-是否冲突"><a href="#47、双向绑定和-vuex-是否冲突" class="headerlink" title="47、双向绑定和 vuex 是否冲突"></a>47、双向绑定和 vuex 是否冲突</h1><p>在严格模式下直接使用确实会有问题。</p><p>在严格模式中使用Vuex，当用户输入时，v-model 会试图直接修改属性值，但这个修改不是在 mutation中修改的，所以会抛出一个错误。</p><p>处理方法：</p><blockquote><p>来自官网文档：</p></blockquote><p>当在严格模式中使用 Vuex 时，在属于 Vuex 的 state 上使用 <code>v-model</code> 会比较棘手：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;obj.message&quot;</span>&gt;</span></code></pre><p>假设这里的 <code>obj</code> 是在计算属性中返回的一个属于 Vuex store 的对象，在用户输入时，<code>v-model</code> 会试图直接修改 <code>obj.message</code>。在严格模式中，由于这个修改不是在 mutation 函数中执行的, 这里会抛出一个错误。</p><p>方法一：不用<code>v-model</code> 直接绑定<code>value</code>值和监听<code>input</code>事件</p><p>用“Vuex 的思维”去解决这个问题的方法是：给 <code>&lt;input&gt;</code> 中绑定 value，然后侦听 <code>input</code> 或者 <code>change</code> 事件，在事件回调中调用一个方法:</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span> @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;updateMessage&quot;</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-comment">// ...</span>computed: &#123;  ...mapState(&#123;    message: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> state.obj.message  &#125;)&#125;,methods: &#123;  updateMessage (e) &#123;    <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;updateMessage&#x27;</span>, e.target.value)  &#125;&#125;</code></pre><p>下面是 mutation 函数：</p><pre><code class="hljs js"><span class="hljs-comment">// ...</span>mutations: &#123;  updateMessage (state, message) &#123;    state.obj.message = message  &#125;&#125;</code></pre><p>方法二：双向绑定的计算属性 给计算属性设置<code>getter</code>和<code>setter</code></p><p>必须承认，这样做比简单地使用“<code>v-model</code> + 局部状态”要啰嗦得多，并且也损失了一些 <code>v-model</code> 中很有用的特性。另一个方法是使用带有 setter 的双向绑定计算属性：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">&quot;message&quot;</span>&gt;</span></code></pre><pre><code class="hljs js"><span class="hljs-comment">// ...</span>computed: &#123;  message: &#123;    get () &#123;      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$store.state.obj.message <span class="hljs-comment">//读 Vuex 数据</span>    &#125;,    set (value) &#123;      <span class="hljs-built_in">this</span>.$store.commit(<span class="hljs-string">&#x27;updateMessage&#x27;</span>, value)<span class="hljs-comment">//提交 mutation 更改 Vuex 数据</span>    &#125;  &#125;&#125;</code></pre><h1 id="48、call-和-apply-的区别是什么，哪个性能更好一些"><a href="#48、call-和-apply-的区别是什么，哪个性能更好一些" class="headerlink" title="48、call 和 apply 的区别是什么，哪个性能更好一些"></a>48、call 和 apply 的区别是什么，哪个性能更好一些</h1><ol><li><code>Function.prototype.apply</code> 和 <code>Function.prototype.call</code> 的作用是一样的，区别在于传入参数的不同；</li><li>第一个参数都是，指定函数体内 <code>this</code> 的指向；</li><li>第二个参数开始不同，<code>apply</code> 是传入带下标的<strong>集合</strong>，<strong>数组</strong>或者<strong>类数组</strong>，<code>apply</code>把它传给函数作为参数，<code>call</code>从第二个开始传入的参数是不固定的，都会传给函数作为参数。</li><li>call比apply的性能要好，平常可以多用call, call传入参数的格式正是内部所需要的格式。</li></ol><h1 id="49、为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片？"><a href="#49、为什么通常在发送数据埋点请求的时候使用的是-1x1-像素的透明-gif-图片？" class="headerlink" title="49、为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？"></a>49、为什么通常在发送数据埋点请求的时候使用的是 1x1 像素的透明 gif 图片？</h1><p><strong>前端监控的原理</strong></p><p>所谓的前端监控，其实是在满足一定条件后，由Web页面将用户信息（UA/鼠标点击位置/页面报错/停留时长/etc）上报给服务器的过程。一般是将上报数据用url_encode（百度统计/CNZZ）或JSON编码（神策/诸葛io）为字符串，通过url参数传递给服务器，然后在服务器端统一处理。</p><p>这套流程的关键在于：</p><p>1）能够收集到用户信息；</p><p>2）能够将收集到的数据上报给服务器。也就是说，只要能上报数据，无论是请求GIF文件还是请求js文件或者是调用页面接口，服务器端其实并不关心具体的上报方式。</p><p>首先，为什么不能直接用GET/POST/HEAD请求接口进行上报？</p><blockquote><p>一般而言，打点域名都不是当前域名，所以所有的接口请求都会构成跨域。而跨域请求很容易出现由于配置不当被浏览器拦截并报错，这是不能接受的。所以，直接排除。</p></blockquote><p>为什么不能用请求其他的文件资源（js/css/ttf）的方式进行上报？</p><blockquote><p>这和浏览器的特性有关。通常，创建资源节点后只有将对象注入到浏览器DOM树后，浏览器才会实际发送资源请求。反复操作DOM不仅会引发性能问题，而且载入js/css资源还会阻塞页面渲染，影响用户体验。</p><p>但是图片请求例外。构造图片打点不仅不用插入DOM，只要在 JS 中 new 出 Image 对象就能发起请求，而且还没有阻塞问题，在没有 JS 的浏览器环境中也能通过 img标签正常打点，这是其他类型的资源请求所做不到的。</p></blockquote><p>同样都是图片，上报时选用了1x1的透明GIF，而不是其他的PNG/JEPG/BMP文件？</p><blockquote><p>首先，1x1像素是最小的合法图片。</p><p>而且，因为是通过图片打点，所以图片最好是透明的，这样一来不会影响页面本身展示效果，二者表示图片透明只要使用一个二进制位标记图片是透明色即可，不用存储色彩空间数据，可以节约体积。</p><p>因为需要透明色，所以可以直接排除JEPG(BMP32格式可以支持透明色)。</p><p>在体积方面最小的BMP文件需要74个字节，PNG需要67个字节，而合法的GIF，只需要43个字节。</p><p>同样的响应，GIF可以比BMP节约41%的流量，比PNG节约35%的流量。</p></blockquote><p>所以，总结：</p><p>前端监控使用GIF进行上报主要是因为：</p><ul><li>没有跨域问题；</li><li>能够完成整个 HTTP 请求+响应（尽管不需要响应内容）</li><li>触发 GET 请求之后不需要获取和处理数据、服务器也不需要发送数据</li><li>不会阻塞页面加载，影响用户体验</li><li>相比 XMLHttpRequest 对象发送 GET 请求，性能上更好</li><li>在所有图片中体积最小，相较BMP/PNG，可以节约41%/35%的网络资源。</li></ul><h1 id="50、实现-5-add-3-minus-2-功能。"><a href="#50、实现-5-add-3-minus-2-功能。" class="headerlink" title="50、实现 (5).add(3).minus(2) 功能。"></a>50、实现 (5).add(3).minus(2) 功能。</h1><p> JavaScript 的 <code>Number</code> 对象是经过封装的能让你处理数字值的对象。<code>Number</code> 对象由 <code>Number()</code> 构造器创建。</p><p><code>(5)</code> 和 <code>Number(5)</code>完全等价 </p><p><code>Number.isNaN()</code> 确定传递的值是否是 NaN。</p><p><code>Number.prototype.valueOf()</code>  <code>valueOf()</code> 方法返回一个被 <code>Number</code>对象包装的原始值。</p><pre><code class="hljs js"><span class="hljs-built_in">Number</span>.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n !== <span class="hljs-string">&#x27;number&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;请输入数字～&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf() + n&#125;<span class="hljs-built_in">Number</span>.prototype.minus = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> n !== <span class="hljs-string">&#x27;number&#x27;</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;请输入数字～&#x27;</span>)  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.valueOf() - n&#125;<span class="hljs-built_in">console</span>.log((<span class="hljs-number">5</span>).add(<span class="hljs-number">3</span>).minus(<span class="hljs-number">2</span>))</code></pre><pre><code class="hljs js"><span class="hljs-built_in">Number</span>.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">parseFloat</span>(value)  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> number !== <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-built_in">Number</span>.isNaN(number)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;请输入数字或者数字字符串～&#x27;</span>)  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> + number&#125;<span class="hljs-built_in">Number</span>.prototype.minus = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;  <span class="hljs-keyword">let</span> number = <span class="hljs-built_in">parseFloat</span>(value)  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> number !== <span class="hljs-string">&#x27;number&#x27;</span> || <span class="hljs-built_in">Number</span>.isNaN(number)) &#123;    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;请输入数字或者数字字符串～&#x27;</span>)  &#125;  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span> - number&#125;<span class="hljs-built_in">console</span>.log((<span class="hljs-number">5</span>).add(<span class="hljs-number">3</span>).minus(<span class="hljs-number">2</span>))<span class="hljs-comment">//更加强壮，排除了NaN 兼容了字符串</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《前端100问》40</title>
    <link href="/2020/11/20/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B40/"/>
    <url>/2020/11/20/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B40/</url>
    
    <content type="html"><![CDATA[<h1 id="31、改造下面的代码，使之输出0-9，写出你能想到的所有解法。"><a href="#31、改造下面的代码，使之输出0-9，写出你能想到的所有解法。" class="headerlink" title="31、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。"></a>31、改造下面的代码，使之输出0 - 9，写出你能想到的所有解法。</h1><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">10</span>; i++)&#123;<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(i);    &#125;, <span class="hljs-number">1000</span>)&#125;</code></pre><p>思路就是：形成词法环境嵌套，形成闭包，延长变量生命</p><pre><code class="hljs js"><span class="hljs-comment">//let 会形成块级作用域，此时 for 类比于 function 内层函数使用了外层函数的变量 闭包</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">console</span>.log(i)  &#125;, <span class="hljs-number">1000</span>)&#125;<span class="hljs-comment">//setTimeout(fucntion,time,...arg) arg为传给 function 的参数</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(    i =&gt; &#123;      <span class="hljs-built_in">console</span>.log(i)    &#125;,    <span class="hljs-number">1000</span>,    i  )&#125;<span class="hljs-comment">// 解法二：闭包</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(i)    &#125;, <span class="hljs-number">1000</span>)  &#125;)(i)&#125;<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-built_in">setTimeout</span>(    (<span class="hljs-function"><span class="hljs-params">i</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(i)    &#125;)(i),    <span class="hljs-number">1000</span>  )&#125;</code></pre><h1 id="32、Virtual-DOM-真的比操作原生-DOM-快吗？谈谈你的想法。"><a href="#32、Virtual-DOM-真的比操作原生-DOM-快吗？谈谈你的想法。" class="headerlink" title="32、Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。"></a>32、Virtual DOM 真的比操作原生 DOM 快吗？谈谈你的想法。</h1><p>Virtual DOM 在某些情况下，并不一定比操作原生 DOM 快，这是一个性能和可维护性的取舍</p><p>没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。</p><p>框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。</p><p><strong>性能比较也要看场合</strong></p><p>在比较性能的时候，要分清楚初始渲染、小量数据更新、大量数据更新这些不同的场合。Virtual DOM、脏检查 MVVM、数据收集 MVVM 在不同场合各有不同的表现和不同的优化需求。</p><ul><li>初始渲染：Virtual DOM &gt; 脏检查 &gt;= 依赖收集</li><li>小量数据更新：依赖收集 &gt;&gt; Virtual DOM + 优化 &gt; 脏检查（无法优化） &gt; Virtual DOM 无优化</li><li>大量数据更新：脏检查 + 优化 &gt;= 依赖收集 + 优化 &gt; Virtual DOM（无法/无需优化）&gt;&gt; MVVM 无优化</li></ul><h1 id="33、下面的代码打印什么内容，为什么？"><a href="#33、下面的代码打印什么内容，为什么？" class="headerlink" title="33、下面的代码打印什么内容，为什么？"></a>33、下面的代码打印什么内容，为什么？</h1><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;    b = <span class="hljs-number">20</span>;    <span class="hljs-built_in">console</span>.log(b); &#125;)();</code></pre><p>打印：</p><pre><code class="hljs txt">function b()&#123;    b = 20;    console.log(b); &#125;</code></pre><p>原因：</p><ol><li>函数表达式与函数声明不同，函数名只在该函数内部有效，并且此绑定是常量绑定。</li><li>对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。</li><li>IIFE中的函数是函数表达式，而不是函数声明。</li></ol><pre><code class="hljs js">let function_expression = function [name]([param1[, param2[, ..., paramN]]]) &#123;   statements&#125;;<span class="hljs-comment">//函数表达式 函数吗 【name】只在函数体内有效</span></code></pre><p>所以：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<span class="hljs-comment">//IIFE中的函数是函数表达式，而不是函数声明。</span><span class="hljs-comment">//函数名只在该函数内部有效,而且 b是常量绑定，不可以更改</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-comment">//对于一个常量进行赋值，在 strict 模式下会报错，非 strict 模式下静默失败。</span>    b = <span class="hljs-number">20</span>; <span class="hljs-comment">//非严格模式 b = 20失败</span>    <span class="hljs-built_in">console</span>.log(b); &#125;)();<span class="hljs-comment">//所以此时b = function b()&#123;b=20;console.log(b)&#125;，自然打印出这个</span></code></pre><h1 id="34、简单改造下面的代码，使之分别打印-10-和-20。"><a href="#34、简单改造下面的代码，使之分别打印-10-和-20。" class="headerlink" title="34、简单改造下面的代码，使之分别打印 10 和 20。"></a>34、简单改造下面的代码，使之分别打印 10 和 20。</h1><pre><code class="hljs js"><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;    b = <span class="hljs-number">20</span>;    <span class="hljs-built_in">console</span>.log(b); &#125;)();</code></pre><pre><code class="hljs js"><span class="hljs-comment">//打印20</span><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;<span class="hljs-comment">//去掉函数名</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;    b = <span class="hljs-number">20</span>;    <span class="hljs-built_in">console</span>.log(b); &#125;)();<span class="hljs-comment">//打印10</span><span class="hljs-keyword">var</span> b = <span class="hljs-number">10</span>;(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(b); &#125;)();</code></pre><h1 id="35、浏览器缓存读取规则"><a href="#35、浏览器缓存读取规则" class="headerlink" title="35、浏览器缓存读取规则"></a>35、浏览器缓存读取规则</h1><blockquote><p>可以分成 Service Worker、Memory Cache、Disk Cache 和 Push Cache，那请求的时候 from memory cache 和 from disk cache 的依据是什么，哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？</p></blockquote><p>如果 Service Worker 存在，可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件</p><p>如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据</p><p>缓存分为强缓存和协商缓存，如果命中强缓存则</p><p>新开一个以前打开过的页面缓存会从 Disk Cache 中拿</p><p>刷新当前页面时浏览器会根据当前运行环境内存来决定是从 Memory Cache 还是 从Disk Cache中拿</p><p>哪些数据什么时候存放在 Memory Cache 和 Disk Cache中？</p><p>对于大文件来说，大概率是不存储在内存中的，反之优先<br>当前系统内存使用率高的话，文件优先存储进硬盘</p><p>页面上已经下载的样式、脚本、图片等存在 Memory Cache 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</p><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p><ul><li>打开网页，地址栏输入地址： 查找 disk cache 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 memory cache 是可用的，会被优先使用(如果匹配的话)。其次才是 disk cache。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache(为了兼容，还带了 Pragma: no-cache),服务器直接返回 200 和最新内容。</li></ul><h1 id="36、使用迭代的方式实现-flatten-函数。"><a href="#36、使用迭代的方式实现-flatten-函数。" class="headerlink" title="36、使用迭代的方式实现 flatten 函数。"></a>36、使用迭代的方式实现 flatten 函数。</h1><blockquote><p>将一个多维数组拍平为一个一维数组</p></blockquote><pre><code class="hljs js">[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],[<span class="hljs-number">6</span>,[<span class="hljs-number">7</span>,[<span class="hljs-number">8</span>]]]]</code></pre><p>如何判断是否为数组：<br><code>Object.prototype.toString.call()</code> “[object Array]”<br><code>instanceof Array</code><br><code>Array.isArray()</code><br>就性能来说 <code>Array.isArray</code> 的性能最好，<code>instanceof</code> 比 <code>Object.prototype.toString.call()</code> 稍微好了一点点</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> example = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, [<span class="hljs-number">7</span>, [<span class="hljs-number">8</span>]]]]<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flatten</span>(<span class="hljs-params">arr</span>) </span>&#123;  <span class="hljs-keyword">let</span> flatArr = []  <span class="hljs-keyword">const</span> walk = <span class="hljs-function"><span class="hljs-params">arr</span> =&gt;</span> &#123;    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> item <span class="hljs-keyword">of</span> arr) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(item)) &#123;          flatArr.concat(walk(item))      &#125; <span class="hljs-keyword">else</span> &#123;        flatArr.push(item)      &#125;    &#125;  &#125;  walk(arr) <span class="hljs-keyword">return</span> flatArr&#125;<span class="hljs-built_in">console</span>.log(flatten(example))</code></pre><h1 id="37、为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作？"><a href="#37、为什么-Vuex-的-mutation-和-Redux-的-reducer-中不能做异步操作？" class="headerlink" title="37、为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？"></a>37、为什么 Vuex 的 mutation 和 Redux 的 reducer 中不能做异步操作？</h1><p>Redux的设计参考了 Flux的模式，作者希望以此来实现时间旅行，保存应用的历史状态，实现应用状态的可预测。所以整个Redux都是函数式编程的范式，要求reducer是纯函数也是自然而然的事情，使用纯函数才能保证相同的输入得到相同的输入，保证状态的可预测。所以Redux有三大原则：</p><ul><li>单一数据源，也就是state</li><li>state 是只读，Redux并没有暴露出直接修改state的接口，必须通过action来触发修改</li><li>使用纯函数来修改state，reducer必须是纯函数</li></ul><p>同步的意义在于这样每一个 mutation 执行完成后都可以对应到一个新的状态（和 reducer 一样），这样 devtools 就可以打个 snapshot 存下来，然后就可以随便 time-travel 了。</p><p>如果你开着 devtool 调用一个异步的 action，你可以清楚地看到它所调用的 mutation 是何时被记录下来的，并且可以立刻查看它们对应的状态。其实我有个点子一直没时间做，那就是把记录下来的 mutations 做成类似 rx-marble 那样的时间线图，对于理解应用的异步状态变化很有帮助</p><p>一句话：为了devtools 开发工具更好的记录追踪 应用状态如何变化，更好的进行 time travel</p><h1 id="38、下面代码中-a-在什么情况下会打印-1？"><a href="#38、下面代码中-a-在什么情况下会打印-1？" class="headerlink" title="38、下面代码中 a 在什么情况下会打印 1？"></a>38、下面代码中 a 在什么情况下会打印 1？</h1><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = ?;<span class="hljs-keyword">if</span>(a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>)&#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;</code></pre><p><code>==</code>操作会隐式类型转换，即的执行一次<code>toString()</code>方法</p><blockquote><p>引用类型在比较运算符时候，隐式转换会调用本类型 toString 或 valueOf 方法.</p></blockquote><p>改写 a 的 <code>toString()</code>方法</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = &#123;  i: <span class="hljs-number">1</span>,  toString() &#123;    <span class="hljs-keyword">return</span> a.i++  &#125;&#125;<span class="hljs-keyword">if</span> (a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>) &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;</code></pre><h1 id="39、介绍下-BFC-及其应用。"><a href="#39、介绍下-BFC-及其应用。" class="headerlink" title="39、介绍下 BFC 及其应用。"></a>39、介绍下 BFC 及其应用。</h1><p>BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响。创建 BFC 的方式有：</p><ol><li>html 根元素</li><li>float 浮动</li><li>绝对定位</li><li>overflow 不为 visiable</li><li>display 为表格布局或者弹性布局</li></ol><p>BFC 主要的作用是：</p><ol><li>清除浮动</li><li>防止同一 BFC 容器中的相邻元素间的外边距重叠问题</li></ol><p>BFC特性：</p><ol><li>内部box会在垂直方向，一个接一个地放置。</li><li>Box垂直方向的距离由margin决定，在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。</li><li>在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）</li><li>形成了BFC的区域不会与float box重叠</li><li>计算BFC高度时，浮动元素也参与计算</li></ol><h1 id="40、在-Vue-中，子组件为何不可以修改父组件传递的-Prop"><a href="#40、在-Vue-中，子组件为何不可以修改父组件传递的-Prop" class="headerlink" title="40、在 Vue 中，子组件为何不可以修改父组件传递的 Prop"></a>40、在 Vue 中，子组件为何不可以修改父组件传递的 Prop</h1><blockquote><p>如果修改了，Vue 是如何监控到属性的修改并给出警告的。</p></blockquote><ol><li>单向数据流，易于监测数据的流动，出现了错误可以更加迅速的定位到错误发生的位置。</li><li>每当父组件属性值修改时，该值都将被覆盖；如果要有不同的改变，可以用基于 prop 的 data 或者 computed</li></ol><p>在 initProps 的时候，在 defineReactive 时通过判断是否在开发环境，如果是开发环境，会在触发 set 的时候判断是否此 key 是否处于 updatingChildren 中被修改，如果不是，说明此修改来自子组件，触发 warning 提示。</p><pre><code class="hljs js"><span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      <span class="hljs-keyword">var</span> hyphenatedKey = hyphenate(key);      <span class="hljs-keyword">if</span> (isReservedAttribute(hyphenatedKey) ||          config.isReservedAttr(hyphenatedKey)) &#123;        warn(          (<span class="hljs-string">&quot;\&quot;&quot;</span> + hyphenatedKey + <span class="hljs-string">&quot;\&quot; is a reserved attribute and cannot be used as component prop.&quot;</span>),          vm        );      &#125;      defineReactive$$<span class="hljs-number">1</span>(props, key, value, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;          warn(            <span class="hljs-string">&quot;Avoid mutating a prop directly since the value will be &quot;</span> +            <span class="hljs-string">&quot;overwritten whenever the parent component re-renders. &quot;</span> +            <span class="hljs-string">&quot;Instead, use a data or computed property based on the prop&#x27;s &quot;</span> +            <span class="hljs-string">&quot;value. Prop being mutated: \&quot;&quot;</span> + key + <span class="hljs-string">&quot;\&quot;&quot;</span>,            vm          );        &#125;      &#125;);    &#125;</code></pre><p>在组件 <code>initProps</code> 方法的时候，会对 props 进行 defineReactive 操作，传入的第四个参数是自定义的 set 函数，该函数会在触发 props 的 set 方法时执行，当 props 修改了，就会运行这里传入的第四个参数，然后进行判断，如果不是 root 根组件，并且不是更新子组件，那么说明更新的是 props，所以会警告</p><pre><code class="hljs js"><span class="hljs-comment">// src/core/instance/state.js 源码路径</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initProps</span> (<span class="hljs-params">vm: Component, propsOptions: Object</span>) </span>&#123;  <span class="hljs-keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;  <span class="hljs-keyword">const</span> props = vm._props = &#123;&#125;  <span class="hljs-comment">// cache prop keys so that future props updates can iterate using Array</span>  <span class="hljs-comment">// instead of dynamic object key enumeration.</span>  <span class="hljs-keyword">const</span> keys = vm.$options._propKeys = []  <span class="hljs-keyword">const</span> isRoot = !vm.$parent  <span class="hljs-comment">// root instance props should be converted</span>  <span class="hljs-keyword">if</span> (!isRoot) &#123;    toggleObserving(<span class="hljs-literal">false</span>)  &#125;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> propsOptions) &#123;    keys.push(key)    <span class="hljs-keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)    <span class="hljs-comment">/* istanbul ignore else */</span>    <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span>) &#123;      <span class="hljs-keyword">const</span> hyphenatedKey = hyphenate(key)      <span class="hljs-keyword">if</span> (isReservedAttribute(hyphenatedKey) ||          config.isReservedAttr(hyphenatedKey)) &#123;        warn(          <span class="hljs-string">`&quot;<span class="hljs-subst">$&#123;hyphenatedKey&#125;</span>&quot; is a reserved attribute and cannot be used as component prop.`</span>,          vm        )      &#125;      defineReactive(props, key, value, <span class="hljs-function">() =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;          warn(            <span class="hljs-string">`Avoid mutating a prop directly since the value will be `</span> +            <span class="hljs-string">`overwritten whenever the parent component re-renders. `</span> +            <span class="hljs-string">`Instead, use a data or computed property based on the prop&#x27;s `</span> +            <span class="hljs-string">`value. Prop being mutated: &quot;<span class="hljs-subst">$&#123;key&#125;</span>&quot;`</span>,            vm          )        &#125;      &#125;)    &#125; <span class="hljs-keyword">else</span> &#123;      defineReactive(props, key, value)    &#125;    <span class="hljs-comment">// static props are already proxied on the component&#x27;s prototype</span>    <span class="hljs-comment">// during Vue.extend(). We only need to proxy props defined at</span>    <span class="hljs-comment">// instantiation here.</span>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;      proxy(vm, <span class="hljs-string">`_props`</span>, key)    &#125;  &#125;  toggleObserving(<span class="hljs-literal">true</span>)&#125;<span class="hljs-comment">// src/core/observer/index.js</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * Define a reactive property on an Object.</span><span class="hljs-comment"> */</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span> (<span class="hljs-params"></span></span><span class="hljs-function"><span class="hljs-params">  obj: Object,</span></span><span class="hljs-function"><span class="hljs-params">  key: string,</span></span><span class="hljs-function"><span class="hljs-params">  val: any,</span></span><span class="hljs-function"><span class="hljs-params">  customSetter?: ?Function,</span></span><span class="hljs-function"><span class="hljs-params">  shallow?: boolean</span></span><span class="hljs-function"><span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()  <span class="hljs-keyword">const</span> property = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj, key)  <span class="hljs-keyword">if</span> (property &amp;&amp; property.configurable === <span class="hljs-literal">false</span>) &#123;    <span class="hljs-keyword">return</span>  &#125;  <span class="hljs-comment">// cater for pre-defined getter/setters</span>  <span class="hljs-keyword">const</span> getter = property &amp;&amp; property.get  <span class="hljs-keyword">const</span> setter = property &amp;&amp; property.set  <span class="hljs-keyword">if</span> ((!getter || setter) &amp;&amp; <span class="hljs-built_in">arguments</span>.length === <span class="hljs-number">2</span>) &#123;    val = obj[key]  &#125;  <span class="hljs-keyword">let</span> childOb = !shallow &amp;&amp; observe(val)  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;    enumerable: <span class="hljs-literal">true</span>,    configurable: <span class="hljs-literal">true</span>,    get: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val      <span class="hljs-keyword">if</span> (Dep.target) &#123;        dep.depend()        <span class="hljs-keyword">if</span> (childOb) &#123;          childOb.dep.depend()          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(value)) &#123;            dependArray(value)          &#125;        &#125;      &#125;      <span class="hljs-keyword">return</span> value    &#125;,    set: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveSetter</span> (<span class="hljs-params">newVal</span>) </span>&#123;      <span class="hljs-keyword">const</span> value = getter ? getter.call(obj) : val      <span class="hljs-comment">/* eslint-disable no-self-compare */</span>      <span class="hljs-keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;        <span class="hljs-keyword">return</span>      &#125;      <span class="hljs-comment">/* eslint-enable no-self-compare */</span>      <span class="hljs-keyword">if</span> (process.env.NODE_ENV !== <span class="hljs-string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;        customSetter()      &#125;      <span class="hljs-comment">// #7981: for accessor properties without setter</span>      <span class="hljs-keyword">if</span> (getter &amp;&amp; !setter) <span class="hljs-keyword">return</span>      <span class="hljs-keyword">if</span> (setter) &#123;        setter.call(obj, newVal)      &#125; <span class="hljs-keyword">else</span> &#123;        val = newVal      &#125;      childOb = !shallow &amp;&amp; observe(newVal)      dep.notify()    &#125;</code></pre><p>如果传入的 props 是基本数据类型，子组件修改父组件传的 props 会警告，并且修改不成功，如果传入的是引用数据类型，那么修改改引用数据类型的某个属性值时，对应的 props 也会修改，并且 vue 不会抱警告。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器输入URL发生了什么</title>
    <link href="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h1><p>从输入 <code>URL</code> 到页面呈现发生了什么？</p><p>整体过程：</p><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ol><li><code>DNS</code> 解析</li><li><code>TCP</code> 连接</li><li>发送 <code>HTTP</code> 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ol><h1 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h1><blockquote><p><code>DNS</code> 解析过程就是通过网络查找哪台机器有你需要的资源的过程。</p></blockquote><p>浏览器输入 <code>github.com</code> 并不是真正意义上的去查找这个，而是查找这个域名解析到的 <code>IP</code> 地址。</p><p>互联网上每一台计算机的唯一标识是它的 <code>IP</code> 地址，但是 <code>IP</code> 地址并不方便记忆，所以互联网设计者为了方便，才会搞出 <code>github.com</code> 这样的域名。</p><ul><li>DNS 解析过程：</li></ul><ol><li>查询 <code>www.github.com</code></li><li>访问客户端 DNS 缓存：<strong>浏览器缓存</strong> → <strong>系统缓存（host）</strong> →  <strong>路由器缓存</strong></li><li>访问 <strong>ISP DNS 服务器</strong>（ISP，互联网服务提供商），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去咨询查找。</li><li>本地去咨询 <strong>DNS 根服务器</strong>，DNS 根服务器发现是 <code>.com 区域</code> 管理的，告诉本地去咨询它。</li><li>本地去咨询 <strong>.com 顶级域名服务器</strong>，.com 顶级域名服务器不太清楚，告诉本地去咨询 <code>github.com</code> 主区域 的服务器。</li><li>本地去咨询 <strong>github.com 主域名服务器</strong>，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。</li><li>本地服务器通知用户，<code>github.com</code> 对应的 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。</li></ol><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h1><blockquote><p>TCP 连接的内容，详细请看 《TCP 三次握手和四次挥手》</p></blockquote><ul><li>建立连接阶段：3 次握手。建立客户端和服务器之间的连接。</li><li>传输数据阶段</li><li>断开连接阶段：4 次挥手。断开客户端和服务器之间的连接。</li></ul><h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><p>发送 <code>HTTP</code> 请求的过程就是构建 <code>HTTP</code> 请求报文，并通过 <code>TCP</code> 协议发送到服务器指定端口（<code>HTTP</code> 协议默认端口 <code>80/8080</code>，<code>HTTPS</code> 协议默认端口 <code>443</code>）。</p><p><code>HTTP</code> 请求报文由 3 部分组成：<strong>请求行</strong>、<strong>请求报文</strong> 和 <strong>请求正文</strong>。</p><ul><li>请求行：常用方法有：GET、POST、PUT、DELETE、OPTIONS、HEAD。</li><li>请求报头：允许客户端向服务器传递请求的附加信息和客户端自身的信息。</li><li>请求正文：通过 POST、PUT 等方法时，通常需要客户端向服务器传递数据，这些数据就储存在请求正文中。</li></ul><p>当然，<code>HTTP</code> 请求需要注意是否跨域，如何解决跨域问题：</p><ul><li><p>JSONP</p></li><li><p>跨域资源共享（CORS）服务端设置 <code>Access-Control-Allow-Origin</code></p></li><li><p>Nginx 反向代理跨域</p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p></li></ul><h1 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h1><p>服务器处理请求完毕后，会返回 <code>HTTP</code> 报文。</p><p><code>HTTP</code> 响应报文也是由 3 部分组成：<strong>状态码</strong>、<strong>响应报头</strong> 和 <strong>响应报文</strong>。</p><p><strong>状态码</strong>：<code>1xx</code> 指示信息-表示请求已接收；<code>2xx</code> 请求成功-表示请求成功接收并解析；<code>3xx</code> 重定向-表示要完成请求需要更进一步操作；<code>4xx</code> 客户端错误-请求有语法错误或者请求无法实现；<code>5xx</code>：服务端错误-服务端未能实现合法的请求。</p><p><strong>常见状态码</strong>：200（成功）、304（请求内容有缓存，不需要更新）、404（网页或者文件找不到）、500（服务器-后端处理错误）。</p><p><strong>响应报头</strong>：常见的响应报头字段 <code>Server</code>、<code>Connection</code> 等。</p><p><strong>响应报文</strong>：服务器返回给浏览器的文本信息，通常 HTML、CSS、JS、图片等文件就放在这一部分。</p><h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><p>浏览器的渲染过程为：</p><ol><li>解析 HTML，生成 <code>DOM</code> 树</li><li>解析 CSS，生成 <code>CSS 规则树（CSS Rule Tree）</code></li><li>将 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 相结合，生成 <strong>渲染树</strong>（<code>Render Tree</code>）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 <strong>布局渲染树</strong>（<code>Layout of the render tree</code>）。</li><li>遍历渲染树，将每个节点用 UI 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 <strong>绘制渲染树</strong>（<code>Painting the render tree</code>）</li></ol><p>在解析渲染过程中，可能会产生 <strong>回流</strong> 和 <strong>重绘</strong>：</p><ul><li>重绘 (repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此<strong>损耗较少</strong>。</li><li>回流 (reflow)：又叫重排（<code>layout</code>）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</li></ul><h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p>JavaScript 的加载、解析和执行会阻塞 DOM 的构建。</p><p>在渲染的过程中，遇到一个 script 标记时，就会停止渲染，去请求脚本文件并执行脚本文件，因为浏览器渲染和 JavaScript 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。</p><p>JavaScript 的加载、解析与执行会严重阻塞DOM的构建。只有等到脚本文件执行完毕，才会去继续构建DOM。</p><p>JavaScript 不单会阻塞DOM构建，还会导致 CSSOM 也阻塞 DOM 的构建，如果 JavaScript 脚本还操作了CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM的下载和构建，然后再执行 JavaScript，最后在继续构建 DOM。</p><p>因此 script 的位置很重要，在实际使用过程中遵循以下两个原则：</p><p>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。<br>JavaScript 置后：我们通常把JS代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。</p><p>也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 <code>script</code> 标签放到 <code>body</code> 标签底部，或者给 <code>script</code> 标签添加 <code>defer/async</code> 属性的原因。</p><h2 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h2><ol><li>涉及 JS 引擎和渲染引擎两个线程间的通信，损耗性能。</li><li>操作 DOM 可能会重复回流，加剧性能损耗。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 三次握手四次挥手</title>
    <link href="/2020/11/20/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2020/11/20/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-的概述"><a href="#TCP-的概述" class="headerlink" title="TCP 的概述"></a>TCP 的概述</h1><p>TCP 把连接作为最基本的对象，每一条 TCP 连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到 IP 地址即构成了套接字，例如，若 IP 地址为192.3.4.16 而端口号为 80，那么得到的套接字为192.3.4.16:80。</p><p><strong>常用的熟知端口号</strong></p><table><thead><tr><th align="center">应用程序</th><th align="center">FTP</th><th align="center">TFTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">HTTP/HTTPS</th><th align="center">SSH</th><th align="center">MYSQL</th></tr></thead><tbody><tr><td align="center">熟知端口</td><td align="center">21,20</td><td align="center">69</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">80/443</td><td align="center">22</td><td align="center">3306</td></tr><tr><td align="center">传输层协议</td><td align="center">TCP</td><td align="center">UDP</td><td align="center">TCP</td><td align="center">TCP</td><td align="center">UDP</td><td align="center">TCP</td><td align="center">TCP</td><td align="center">TCP</td></tr></tbody></table><h1 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h1><ul><li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><h1 id="TCP-报文首部"><a href="#TCP-报文首部" class="headerlink" title="TCP 报文首部"></a>TCP 报文首部</h1><ol><li><p><strong>源端口</strong>和<strong>目的端口</strong>，各占2个字节，分别写入源端口和目的端口；</p></li><li><p><strong>序号</strong>，占4个字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。</p><blockquote><p>例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从 401 开始；</p></blockquote></li><li><p><strong>确认号</strong>，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。</p><blockquote><p>例如，B 收到了 A 发送过来的报文，其序列号字段是 501，而数据长度是 200字节，这表明 B 正确的收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给A 的确认报文段中把确认号置为 701；</p></blockquote></li><li><p><strong>数据偏移</strong>，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</p></li><li><p><strong>保留</strong>，占6位，保留今后使用，但目前应都位0；</p></li><li><p>紧急<code>URG</code>，当 <code>URG=1</code>，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p></li><li><p>确认<code>ACK</code>，仅当<code>ACK=1</code>时，确认号字段才有效。TCP 规定，在连接建立后所有报文的传输都必须把 <code>ACK</code> 置1；</p></li><li><p>推送<code>PSH</code>，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将 <code>PSH=1</code>；</p></li><li><p>复位<code>RST</code>，当 <code>RST=1</code>，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接；</p></li><li><p>同步<code>SYN</code>，在连接建立时用来同步序号。</p><blockquote><p>当 <code>SYN=1</code>，<code>ACK=0</code>，表明是连接请求报文，若同意连接，则响应报文中应该使 <code>SYN=1</code>，<code>ACK=1</code>；</p></blockquote></li><li><p>终止<code>FIN</code>，用来释放连接。</p><blockquote><p>当 <code>FIN=1</code>，表明此报文的发送方的数据已经发送完毕，并且要求释放；</p></blockquote></li><li><p><strong>窗口</strong>，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</p></li><li><p><strong>检验和</strong>，占2字节，校验首部和数据这两部分；</p></li><li><p><strong>紧急指针</strong>，占2字节，指出本报文段中的紧急数据的字节数；</p></li><li><p><strong>选项</strong>，长度可变，定义一些其他的可选的参数。</p></li></ol><h1 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h1><blockquote><p>拟人化场景解释 TCP 三次握手和四次挥手：</p></blockquote><p>三次握手：</p><p>Browser：先告诉服务器 “我要开始发起请求了，你那边可以吗？”<br>Server：服务器回复浏览器 “没问题，你发吧！”<br>Browser：告诉服务器 “好的，那我开始发了。”</p><p>四次挥手：</p><p>Browser：先告诉服务器 “我数据都发完了，你可以关闭连接了。”<br>Server：回复浏览器 “我先看看我这边还有没有数据没传完。”<br>Server：确认过以后，再次回复浏览器 “我这边数据传输完成了，你可以关闭连接了。”<br>Browser：告诉服务器 “好的，那我真的关闭了。你不用回复我了。”</p><p>Browser 又等了 2MSL，确认确实没有再收到请求了，才会真的关闭TCP连接。</p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><blockquote><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器</p></blockquote><p>所谓三次握手 (Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p><img src="/images/3handshakes.gif" alt="3handshakes"><br>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p><ul><li><p>第一次握手( <code>SYN=1</code>，<code>seq=x</code> ):</p><p>客户端发送一个 TCP 的 <code>SYN</code> 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 <strong>SYN_SEND</strong> 状态。</p></li><li><p>第二次握手( <code>SYN=1</code>， <code>ACK=1</code>，<code>seq=y</code>， <code>ACKnum=x+1</code> ):</p><p>服务器发回确认包(ACK) 应答。即 <code>SYN</code> 标志位和 <code>ACK</code> 标志位均为 1。服务器端选择自己 <code>ISN</code> 序列号，放到 <code>Seq</code> 域里，同时将确认序号 (Acknowledgement Number) 设置为客户的 <code>ISN</code> 加1，即 X+1。 发送完毕后，服务器端进入 <strong>SYN_RCVD</strong> 状态。</p></li><li><p>第三次握手( <code>ACK=1</code>，<code>ACKnum=y+1</code> )</p><p>客户端再次发送确认包(ACK)，<code>SYN</code> 标志位为 0，<code>ACK</code> 标志位为1，并且把服务器发来 <code>ACK</code> 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写<code>ISN</code>的+1</p><p>发送完毕后，客户端进入 <strong>ESTABLISHED</strong> 状态，当服务器端接收到这个包时，也进入 <strong>ESTABLISHED</strong> 状态，TCP 握手结束。</p></li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。</p><p>客户端或服务器均可主动发起挥手动作。</p><p><img src="/images/4handshakes.gif" alt="4handshakes"></p><ul><li><p>第一次挥手( <code>FIN=1</code>，<code>seq=x</code> )</p><p>假设客户端想要关闭连接，客户端发送一个 <code>FIN</code> 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 <strong>FIN_WAIT_1</strong> 状态。</p></li><li><p>第二次挥手( <code>ACK=1</code>，<code>ACKnum=x+1</code> )</p><p>服务器端确认客户端的 <code>FIN</code> 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手( <code>FIN=1</code>，<code>seq=y</code> )</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，<code>FIN</code> 置为1。</p><p>发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 <code>ACK</code>。</p></li><li><p>第四次挥手( <code>ACK=1</code>，<code>ACKnum=y+1</code> )</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <strong>TIME_WAIT</strong> 状态，等待可能出现的要求重传的 <code>ACK</code> 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 <strong>CLOSED</strong> 状态。</p></li></ul><p>客户端等待了两个最大段生命周期（2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 <code>ACK</code> ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <strong>CLOSED</strong> 状态。</p><h1 id="三次握手的过程为什么是三次而不是两次、四次？"><a href="#三次握手的过程为什么是三次而不是两次、四次？" class="headerlink" title="三次握手的过程为什么是三次而不是两次、四次？"></a>三次握手的过程为什么是三次而不是两次、四次？</h1><h2 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h2><blockquote><p>为什么TCP客户端最后还要发送一次确认呢？</p></blockquote><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，<strong>客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了</strong>，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。</p><p>此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h2 id="为什么不是四次？"><a href="#为什么不是四次？" class="headerlink" title="为什么不是四次？"></a>为什么不是四次？</h2><p>可以是四次，但是三次就可以安全建立连接，四次会浪费资源不必要。</p><h1 id="为什么是四次挥手而不是三次？"><a href="#为什么是四次挥手而不是三次？" class="headerlink" title="为什么是四次挥手而不是三次？"></a>为什么是四次挥手而不是三次？</h1><blockquote><p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p></blockquote><p>建立连接的时候， 服务器在 <strong>LISTEN</strong> 状态下，收到建立连接请求的 <code>SYN</code> 报文后，把 <code>ACK</code> 和 <code>SYN</code> 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 <code>FIN</code> 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 <code>FIN</code> 报文给对方来表示同意现在关闭连接，因此，己方 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而导致多了一次。</p><h2 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h2><p>MSL 是 Maximum Segment Lifetime 的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。TCP 允许不同的实现可以设置不同的 MSL 值。</p><p>第一，保证客户端发送的最后一个 <code>ACK</code> 报文能够到达服务器，因为这个 <code>ACK</code> 报文可能丢失，<strong>站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次</strong>，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h1 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h1><p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。</p><p>TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。</p><p>在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p><p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的继承</title>
    <link href="/2020/11/16/JavaScript%20%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/11/16/JavaScript%20%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的继承"><a href="#JavaScript-中的继承" class="headerlink" title="JavaScript 中的继承"></a>JavaScript 中的继承</h1><p>在 JavaScript 中的继承可以以是否使用<code>Object.create</code>大致分为两类：</p><p><img src="/images/js-extends.jpg" alt="js-extends">  </p><p>不使用<code>Object.create</code>：</p><ol><li>原型链继承</li><li>构造函数继承</li><li>组合继承</li></ol><p>使用<code>Object.create</code>：</p><ol start="4"><li>原型式继承</li><li>寄生式继承</li><li>寄生组合继承</li></ol><p>以及ES6 Class 继承</p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h1><p><code>Object.create()</code> 方法创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code>。</p><p>语法：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.create(proto，[propertiesObject])</code></pre><p>参数:</p><ul><li><p><code>proto</code></p><p> 新创建对象的原型对象。</p></li><li><p><code>propertiesObject</code></p><p>可选。需要传入一个对象，该对象的属性类型参照<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties()</code></a>的第二个参数。</p></li></ul><p>返回值:</p><p>一个新对象，带着指定的原型对象和属性。</p><p><code>Object.create()</code>的 Polyfill 方法：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  F.prototype = o  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()&#125;<span class="hljs-comment">//等价于</span><span class="hljs-built_in">Object</span>.create(o)</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>首先，先准备一个父类：</p><pre><code class="hljs js"><span class="hljs-comment">// 定义一个动物类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>&#123;  <span class="hljs-comment">// 属性</span>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Animal&#x27;</span>  <span class="hljs-comment">// 实例方法</span>  <span class="hljs-built_in">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉！&#x27;</span>)  &#125;&#125;<span class="hljs-comment">// 原型方法</span>Animal.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在吃：&#x27;</span> + food)&#125;;</code></pre><h1 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h1><blockquote><p>核心： 将父类的实例作为子类的原型</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>)</span>&#123; &#125;Cat.prototype = <span class="hljs-keyword">new</span> Animal()Cat.prototype.name = <span class="hljs-string">&#x27;cat&#x27;</span><span class="hljs-comment">//　Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<span class="hljs-built_in">console</span>.log(cat.name);cat.eat(<span class="hljs-string">&#x27;fish&#x27;</span>)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">//true </span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">//true </span></code></pre><p>特点：</p><ol><li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li><li>父类新增原型方法/原型属性，子类都能访问到</li><li>简单，易于实现</li></ol><p>缺点：</p><ol><li>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中<br>无法实现多继承</li><li>来自原型对象的引用属性是所有实例共享的</li><li>创建子类实例时，无法向父类构造函数传参</li></ol><h1 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h1><blockquote><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;  Animal.call(<span class="hljs-built_in">this</span>)  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<span class="hljs-built_in">console</span>.log(cat.name)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span></code></pre><p>特点：</p><ol><li>解决了「原型链继承」中，子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多继承（call多个父类对象） </li></ol><p>缺点：</p><ol><li>实例并不是父类的实例，只是子类的实例</li><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ol><h1 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h1><blockquote><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;  Animal.call(<span class="hljs-built_in">this</span>)  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;Cat.prototype = <span class="hljs-keyword">new</span> Animal()<span class="hljs-comment">//组合继承也是需要修复构造函数指向的。</span>Cat.prototype.constructor = Cat<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<span class="hljs-built_in">console</span>.log(cat.name)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span></code></pre><p>特点：</p><ol><li>弥补了「构造继承」的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li><li>既是子类的实例，也是父类的实例</li><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ol><p>缺点：</p><ol><li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li></ol><h1 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h1><blockquote><p>核心：原型式继承的 object方法 本质上是对参数对象的一个浅复制。</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</span><span class="hljs-comment">//就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  F.prototype = o  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()&#125;<span class="hljs-keyword">var</span> person = &#123;  name: <span class="hljs-string">&quot;Nicholas&quot;</span>,  friends: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]&#125;<span class="hljs-keyword">var</span> anotherPerson = object(person)anotherPerson.name = <span class="hljs-string">&quot;Greg&quot;</span>anotherPerson.friends.push(<span class="hljs-string">&quot;Rob&quot;</span>)<span class="hljs-keyword">var</span> yetAnotherPerson = object(person)yetAnotherPerson.name = <span class="hljs-string">&quot;Linda&quot;</span>yetAnotherPerson.friends.push(<span class="hljs-string">&quot;Barbie&quot;</span>)alert(person.friends);  <span class="hljs-comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><span class="hljs-comment">//注意：修改anotherPerson.name的值，yetAnotherPerson.name的值并未发生改变，并不是因为anotherPerson 和 yetAnotherPerson 有独立的 name 值，而是因为 anotherPerson.name = &quot;Greg&quot;，给anotherPerson添加了 name 值，并非修改了原型上的 name 值。</span></code></pre><p>缺点：</p><ol><li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li></ol><h1 id="5、寄生继承"><a href="#5、寄生继承" class="headerlink" title="5、寄生继承"></a>5、寄生继承</h1><blockquote><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 寄生继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>) </span>&#123;    Animal.call(<span class="hljs-built_in">this</span>)    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<span class="hljs-comment">// function object(o) &#123;</span><span class="hljs-comment">//     function F()&#123;&#125;</span><span class="hljs-comment">//     F.prototype = o</span><span class="hljs-comment">//     return new F()</span><span class="hljs-comment">// &#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>) </span>&#123;    <span class="hljs-comment">// 通过调用函数创建一个新对象</span>    <span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">Object</span>.create(original)    <span class="hljs-comment">// 以某种方式来增强这个对象</span>    clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-string">&quot;hi&quot;</span>)    &#125;clone.name = <span class="hljs-string">&#x27;Tom&#x27;</span>    <span class="hljs-keyword">return</span> clone&#125;<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = createAnother(<span class="hljs-keyword">new</span> Animal())<span class="hljs-built_in">console</span>.log(cat.name)cat.sayHi()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat)</code></pre><p>特点：</p><ol><li>可以增强子例对象功</li><li>例子中使用的 Object.create(original) 函数不是必须的，可以使用任何能够返回新对象的函数都适用于此模式</li></ol><p>缺点：</p><ol><li>不能做到函数复用而降低效率</li><li>只是借用了一个没有属性子类实例作为原型，并没有真正的意义上的子类，constructor 依然指向父类</li></ol><h2 id="6、寄生组合继承"><a href="#6、寄生组合继承" class="headerlink" title="6、寄生组合继承"></a>6、寄生组合继承</h2><blockquote><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 寄生组合继承</span><span class="hljs-comment">// 该实现没有修复constructor</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>) </span>&#123;    Animal.call(<span class="hljs-built_in">this</span>)    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Class&#125;</span> </span>Father 父类构造函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Class&#125;</span> </span>Son 子类构造函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> </span>子类实例 </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parasiteExtend</span>(<span class="hljs-params">Father, Son</span>) </span>&#123;    <span class="hljs-comment">// 没有实例方法的临时类</span>    <span class="hljs-comment">// let Super = function () &#123;&#125;</span>    <span class="hljs-comment">// Super.prototype = Father.prototype</span><span class="hljs-comment">// Son.prototype = new Super()</span>    Son.prototype = <span class="hljs-built_in">Object</span>.create(Father.prototype)    <span class="hljs-comment">// 修复constructor</span>    Son.prototype.constructor = Son    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Son()&#125;<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = parasiteExtend(Animal,Cat)<span class="hljs-built_in">console</span>.log(cat.name)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span></code></pre><p>特点：</p><ol><li>堪称完美</li></ol><p>缺点：</p><ol><li>实现较为复杂</li></ol><h1 id="ES6-Class-extends"><a href="#ES6-Class-extends" class="headerlink" title="ES6 Class extends"></a>ES6 Class extends</h1><blockquote><p>核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。</p></blockquote><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(name, gender) &#123;    <span class="hljs-built_in">super</span>(name)    <span class="hljs-built_in">this</span>.gender = gender  &#125;  like() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cat like fish&#x27;</span>)  &#125;&#125;<span class="hljs-comment">//　Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Man&#x27;</span>)<span class="hljs-built_in">console</span>.log(cat.name)<span class="hljs-comment">//Tom</span><span class="hljs-built_in">console</span>.log(cat.gender)<span class="hljs-comment">//Man</span>cat.eat(<span class="hljs-string">&#x27;fish&#x27;</span>)<span class="hljs-comment">//Tom正在吃fish</span>cat.sleep()<span class="hljs-comment">//我的name是Tom</span>cat.like()<span class="hljs-comment">//cat like fish</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal)<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat)<span class="hljs-comment">//true</span></code></pre><p>寄生组合继承是先创建子类实例 this 对象，然后再对其增强；</p><p>而 ES6 先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-built_in">super</span>();  &#125;&#125;</code></pre><p>ES6 实现继承的具体原理：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-built_in">Object</span>.setPrototypeOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, proto</span>) </span>&#123;  obj.__proto__ = proto;  <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-comment">// B 的实例继承 A 的实例</span><span class="hljs-built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);<span class="hljs-comment">// B 继承 A 的静态属性</span><span class="hljs-built_in">Object</span>.setPrototypeOf(B, A);</code></pre><p>ES6 继承与 ES5 继承的异同：<br>相同点：</p><ul><li>本质上ES6继承是ES5继承的语法糖</li></ul><p>不同点：</p><ul><li>ES6 继承中子类的构造函数的原型链指向父类的构造函数，ES5 中使用的是构造函数复制，没有原型链指向。</li><li>ES6 子类实例的构建，基于父类实例，ES5 中不是。</li></ul><h1 id="ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="ES5/ES6 的继承除了写法以外还有什么区别？"></a>ES5/ES6 的继承除了写法以外还有什么区别？</h1><ol><li><code>class</code> 声明会提升，但不会初始化赋值。<code>Foo</code> 进入暂时性死区，类似于 <code>let</code>、<code>const</code> 声明变量。</li><li><code>class</code> 声明内部会启用严格模式。</li><li><code>class</code> 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li><li><code>class</code> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 <code>new</code> 来调用。</li><li>必须使用 <code>new</code> 调用 <code>class</code>。</li><li><code>class</code> 内部无法重写类名</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的渲染机制</title>
    <link href="/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h1><p>浏览器主要由7个部分组成：</p><ul><li>用户界面（User Interface）：定义了一些常用的浏览器组件，比如地址栏，返回、书签等等</li><li>数据持久化（Data Persistence）：指浏览器的 cookie、localStorage 等组件</li><li>浏览器引擎（Browser engine）：平台应用的相关接口，在用户界面和呈现引擎之间传送指令。</li><li>渲染引擎（Rendering engine）：处理 HTML、CSS 的解析与渲染</li><li>JavaScript解释器（JavaScript Interpreter）：解析和执行 JavaScript 代码</li><li>用户界面后端（UI Backend）：指浏览器的的图形库等</li><li>网络（Networking）：用于网络调用，比如 HTTP 请求</li></ul><h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>浏览器内核分为两部分：渲染引擎 (layout engineer 或 Rendering Engine) 和 JavaScript 引擎</p><p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机</p><p>JavaScript 引擎：负责解析和执行 JavaScript 来实现网页的动态效果 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核，最开始渲染引擎和  JavaScript  引擎并没有区分的很明确，后来 JavaScript 引擎越来越独立，内核就倾向于只指渲染引擎</p><blockquote><p>常见的浏览器内核：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）</p></blockquote><h1 id="渲染引擎简介"><a href="#渲染引擎简介" class="headerlink" title="渲染引擎简介"></a>渲染引擎简介</h1><p>Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome(28版本以前) 浏览器使用的都是 Webkit。</p><blockquote><p>2013年7月10日发布的 Chrome 28 版本中，Chrome浏览器开始正式使用 Blink 内核。所以，Webkit 已经成为了Chrome浏览器的前内核。</p></blockquote><h1 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h1><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p><ol><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染：浏览器对内容的渲染</li></ol><h1 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h1><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h2 id="解析-HTML-成-DOM-树"><a href="#解析-HTML-成-DOM-树" class="headerlink" title="解析 HTML 成 DOM 树"></a>解析 HTML 成 DOM 树</h2><p>这个解析过程大概可以分为几个步骤：</p><blockquote><p>字节（Byte）→ 字符串（Characters）→ Tokens →节点（Nodes）→ DOM</p></blockquote><p>第一步：浏览器从磁盘或网络读取 HTML 的原始字节，也就是传输的 0 和 1这样的字节数据，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。</p><p>第二步：将字符串转换成 Token。例如：“”、“” 等。Token 中会标识出当前 Token 是“开始标签”或是“结束标签”亦或是“文本”等信息。</p><p>第三步：在每个 Token 被生成后，会立刻消耗这个 Token 创建出节点对象，因此在构建 DOM 的过程中，不是等待所有的 Token 都生成后才去构建 DOM，而是一边生成 Token 一边消耗来生成节点对象。</p><blockquote><p>注意：带有结束标签标识的 Token 不会创建节点对象 </p></blockquote><p>第四步：通过“开始标签”与“结束标签”来识别并关联节点之间的关系。当所有 Token 都生成并消耗完毕后，我们就得到了一颗完整的 DOM 树。</p><h2 id="构建-CSSOM"><a href="#构建-CSSOM" class="headerlink" title="构建 CSSOM"></a>构建 CSSOM</h2><p>解析 CSS 构建 CSSOM 的过程和构建 DOM 的过程非常的相似。当浏览器接收到一段 CSS，浏览器首先要做的是识别出 Token，然后构建节点并生成 CSSOM</p><blockquote><p>字节（Byte）→ 字符串（Characters）→ Tokens →节点（Nodes）→ CSSOM</p></blockquote><p>节点中样式可以通过继承得到，也可以自己设置，因此在构建的过程中浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。</p><p>为了 CSSOM 的完整性，也只有等构建完毕才能进入到下一个阶段，哪怕 DOM 已经构建完，它也得等 CSSOM，然后才能进入下一个阶段。</p><p>CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情</p><p>所以，DOM 树要小，CSS 尽量用 id 和 class，千万不要过渡层叠下去。所以，CSS 的加载速度与构建 CSSOM 的速度将直接影响首屏渲染速度，因此在默认情况下 CSS 被视为阻塞渲染的资源</p><h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><p>当我们生成 DOM 树和 CSSOM 树后，我们需要将这两颗树合并成渲染树，在构建渲染树的过程中浏览器需要做如下工作：</p><ul><li>从 DOM 树的根节点开始遍历每个可见节点。</li><li>有些节点不可见（例如脚本 Token、元 Token等），因为它们不会体现在渲染输出中，所以会被忽略。</li><li>某些节点被 CSS 隐藏，因此在渲染树中也会被忽略。例如某些节点设置了 display: none 属性。</li><li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们</li></ul><h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p>在渲染的过程中，遇到一个 script 标记时，就会停止渲染，去请求脚本文件并执行脚本文件，因为浏览器渲染和 JavaScript 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。</p><p>JavaScript 的加载、解析与执行会严重阻塞 DOM 的构建。只有等到脚本文件执行完毕，才会去继续构建 DOM。</p><p>JavaScript 不单会阻塞 DOM 构建，还会导致 CSSOM 也阻塞 DOM 的构建，如果 JavaScript 脚本还操作了CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM的下载和构建，然后再执行 JavaScript，最后在继续构建 DOM。</p><p>因此 script 的位置很重要，在实际使用过程中遵循以下两个原则：</p><ul><li>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</li><li>JavaScript 置后：我们通常把 JS代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。</li></ul><h2 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h2><p>浏览器拿到渲染树后，就会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，通常这一行为也被称为“自动重排”。</p><p>布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对测量值都将转换为屏幕上的绝对像素。这一过程也可称为回流</p><p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p><h1 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h1><h2 id="回流-reflow-与-重绘-repaint"><a href="#回流-reflow-与-重绘-repaint" class="headerlink" title="回流(reflow) 与 重绘(repaint)"></a>回流(reflow) 与 重绘(repaint)</h2><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p><ul><li><p>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少</p></li><li><p>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</p></li></ul><p>会触发回流的操作:</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的</li><li>注意：回流一定会触发重绘，而重绘不一定会回流,重绘的开销较小，回流的代价较高</li></ul><p>因此为了减少性能优化，我们可以尽量避免回流或者重绘操作 CSS</p><ul><li><p>避免使用table布局</p></li><li><p>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</p></li></ul><p>JavaScript</p><ul><li>避免频繁操作样式，可汇总后统一 一次修改</li><li>尽量使用class进行样式修改</li><li>减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入</li><li>极限优化时，修改样式可将其 display: none 后修改</li><li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住</li></ul><h1 id="探讨-requestAnimationFrame"><a href="#探讨-requestAnimationFrame" class="headerlink" title="探讨 requestAnimationFrame"></a>探讨 requestAnimationFrame</h1><p>在 JavaScript 中，我们可以使用 <code>setTimeout</code> 和 <code>setIntarval</code> 实现动画，但是 H5 的出现，让我们又多了两种实现动画的方式，分别是 CSS 动画（<code>transition</code>、<code>animation</code>）和 H5 的<code>canvas</code> 实现。</p><p>由于 JavaScript 是单线程的，所以定时器的实现是在当前任务队列完成后再执行定时器的回调的，假如当前队列任务执行时间大于定时器设置的延迟时间，那么定时器就不是那么可靠了。</p><p>所以，H5 还提供了一个专门用于请求动画的 API，让 DOM 动画、canvas 动画、svg 动画、webGL 动画等有一个专门的刷新机制。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>动画是由浏览器按照一定的频率一帧一帧的绘制的，由 CSS 实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新 UI，给用户一种流畅的体验。</p><p>而<code>setInterval</code>或<code>setTimeout</code>实现的 JavaScript 动画就没有这么可靠了，因为浏览器压根就无法保证每一帧渲染的时间间隔。</p><p>一般情况下，每秒平均刷新次数能够达到 60帧，就能够给人流畅的体验，即每过 1000/60 毫秒渲染新一帧即可，这一点单靠定时器是无法保证的。 为此，<code>requestAnimationFrame</code> 应运而生，其作用就是让浏览器流畅的执行动画效果。</p><p>可以将其理解为专门用来实现动画效果的 API，通过这个 API 可以告诉浏览器某个 JavaScript 代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。</p><p><code>requestAnimationFrame</code> 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.requestAnimationFrame(callback)</code></pre><ul><li>callback：下一次重绘之前更新动画帧所调用的函数，<strong>callback仅有一个参数，为DOMHighResTimeStamp参数，表示requestAnimationFrame()开始执行回调函数的时刻。</strong></li><li>返回值：一个 long 类型整数，唯一标志元组在列表中的位置，你可以传这个值给<code>cancelAnimationFrame()</code> 以取消动画。</li></ul><p>在使用和实现上， <code>requestAnimationFrame</code> 与 <code>setTimeout</code> 类似。举个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> rafId = <span class="hljs-literal">null</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 回调函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>time requestAnimationFrame 调用该函数时，自动传入的一个时间</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestAnimation</span>(<span class="hljs-params">time</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(time); <span class="hljs-comment">// 打印执行requestAnimation函数的时刻</span>  <span class="hljs-comment">// 动画没有执行完，则递归渲染</span>  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) &#123;    count++;    <span class="hljs-comment">// 渲染下一帧</span>    rafId = <span class="hljs-built_in">window</span>.requestAnimationFrame(requestAnimation);  &#125;&#125;<span class="hljs-comment">// 渲染第一帧</span><span class="hljs-built_in">window</span>.requestAnimationFrame(requestAnimation);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的缓存机制</title>
    <link href="/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><blockquote><p>浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。</p></blockquote><p>缓存可以说是性能优化中简单高效的一种优化方式了。</p><p>一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p><p>对于一个数据请求来说，可以分为：</p><ol><li><p>发起网络请求</p></li><li><p>后端处理</p></li><li><p>浏览器响应</p></li></ol><p>三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。</p><p>比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p><h1 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h1><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p><ul><li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能</li><li><code>Memory Cache</code> 是内存中的缓存，主要是页面上已经下载的样式、脚本、图片等已经抓取到的资源。</li><li><code>Disk Cache</code> 是存储在硬盘中的缓存，读取速度相对慢点。</li><li><code>Push Cache</code> 是 <code>HTTP/2</code> 中的内容，当以上 3 种缓存都没有命中的时候，它才会被使用。</li></ul><h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</p><p>注意点：</p><ol><li>必须是 <code>HTTPS</code>。因为它涉及请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全。</li><li><code>Service Worker</code> 缓存不同于其他机制，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li></ol><p>实现：</p><p>Service Worker 实现缓存功能一般分为三个步骤：</p><p>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。</p><p>如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h1 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h1><blockquote><p><code>Memory Cache</code>：内存中的缓存，主要是页面上已经下载的样式、脚本、图片等已经抓取到的资源。</p></blockquote><p>注意点：</p><ol><li>读取内存中的数据肯定比磁盘快，读取高效。</li><li>缓存持续性很短，会随着进程的释放而释放。关闭页面内存中的缓存也就释放了。</li></ol><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p><p>内存缓存中有一块重要的缓存资源是 <code>preloader</code>相关指令（例如<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>）下载的资源。</p><p><code>preloader</code> 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。</p><p>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 <code>Cache-Control</code> 是什么值，同时资源的匹配也并非仅仅是对 <strong>URL</strong> 做匹配，还可能会对 <strong>Content-Type</strong>，<strong>CORS</strong> 等其他特征做校验。</p><h1 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h1><p><code>Disk Cache</code> 是存储在硬盘中的缓存，读取速度相对慢点。</p><p>注意点：</p><ol><li>比起 <code>Memory Cache</code> 胜在容量和存储时效性上。</li></ol><p>在所有浏览器缓存中，<code>Disk Cache</code> 覆盖面基本是最大的。</p><p>它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p>绝大部分的缓存都来自 <code>Disk Cache</code></p><ul><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li><li>当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><h1 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h1><p><code>Push Cache</code>（推送缓存） 是 <code>HTTP/2</code> 中的内容，当以上 3 种缓存都没有命中的时候，它才会被使用。</p><p>注意点：</p><ol><li>它只在会话（<code>Session</code>）中存在，一旦会话结束就被释放，并且缓存也很短暂。</li></ol><p><code>Push Cache</code>是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome浏览器中只有 5分钟左右，同时它也并非严格执行 HTTP头中的缓存指令。</p><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><p><strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</strong></p><h1 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h1><p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong>。</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p><img src="/images/brower-cache.jpg" alt="brower-cache">  </p><p>过程：</p><ol><li><strong>浏览器</strong> 发起一次 HTTP 请求</li><li><strong>浏览器缓存</strong> 告诉浏览器这边没有该请求的缓存结果和缓存标识</li><li><strong>浏览器</strong> 向 <strong>服务器</strong> 发起 HTTP 请求</li><li><strong>服务器</strong> 返回该请求结果和缓存规则</li><li><strong>浏览器</strong> 将该请求结果和缓存标识存入浏览器缓存中</li></ol><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>缓存分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong>。</p><p><strong>强缓存</strong>优先于<strong>协商缓存</strong>进行，若<strong>强制缓存</strong>生效则直接使用缓存，若不生效则进行<strong>协商缓存</strong>。</p><p><strong>协商缓存</strong>由服务器决定是否使用缓存，若<strong>协商缓存</strong>失效，那么该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器中；生效则返回 304，继续使用缓存。</p><p>如果强缓存和协商缓存都没有设置，那么浏览器会采用启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 的值的 <code>10%</code> 作为缓存时间。</p><p>当浏览器再次访问一个已经访问过的资源时，它会这样做：</p><ol><li>看看是否命中强缓存，如果命中，就直接使用缓存了；</li><li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；</li><li>如果命中协商缓存，服务器会返回 <code>304</code> 告诉浏览器使用本地缓存；</li><li>否则，返回最新的资源。</li></ol><h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p><strong>强缓存</strong>：不会向服务器发送请求，直接从缓存中读取资源。</p><p><strong>强缓存</strong> 判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容（如果需要判断，那就要用 <strong>协商缓存</strong>）。</p><p><strong>强缓存</strong>可以通过设置两种 HTTP请求头实现：<code>Expires</code> 和 <code>Cache-Control</code>。</p><ul><li><strong>表示方式</strong>：在 Chrome 控制台的 Network 选项中可以看到该请求返回 <code>200</code> 状态码，并且 <code>Size</code> 显示为 <code>from disk cache</code> 或者 <code>from memory cache</code>。</li><li><strong>实现方式</strong>：</li></ul><ol><li><code>Expires</code></li><li><code>Cache-Control</code></li></ol><h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</p><p><code>Expires = max-age + 请求时间</code>，需要和 <code>Last-modified</code> 结合使用。</p><p><code>Expires</code> 是 Web服务器 响应消息头字段，在响应 HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p><code>Expires</code> 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>在 HTTP/1.1中，<code>Cache-Control</code> 是最重要的规则，主要用于控制网页缓存。</p><p>比如当<code>Cache-Control:max-age=300</code> 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><ul><li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）。</p></li><li><p>private：所有内容只有客户端可以缓存，Cache-Control的默认取值。</p></li><li><p>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。</p><blockquote><p>设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p></blockquote></li><li><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p>max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p></li><li><p>s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。</p></li><li><p>max-stale：能容忍的最大过期时间。</p></li><li><p>min-fresh：能够容忍的最小新鲜度。</p></li></ul><h2 id="Expires和Cache-Control两者对比"><a href="#Expires和Cache-Control两者对比" class="headerlink" title="Expires和Cache-Control两者对比"></a>Expires和Cache-Control两者对比</h2><p>区别就在于 <code>Expires</code> 是 http1.0的产物，<code>Cache-Control</code> 是 HTTP1.1的产物。</p><p>两者同时存在的话，<code>Cache-Control</code> 优先级高于 <code>Expires</code>；</p><p>在某些不支持 HTTP1.1的环境下，<code>Expires</code> 就会发挥用处。所以 <code>Expires</code> 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><p>主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified</li></ul><p><img src="/images/consult-cache-1.jpg" alt="consult-cache-1">  </p><ol><li><strong>浏览器</strong> 发起 HTTP 请求，先经过 <strong>浏览器缓存</strong></li><li><strong>浏览器缓存</strong> 判断该请求的缓存结果，返回缓存标识</li><li><strong>浏览器</strong> 携带该标识，向 <strong>服务器</strong> 发起 HTTP 请求</li><li><strong>服务器</strong> 返回 304 告诉 <strong>浏览器</strong> 资源没有更新</li><li><strong>浏览器</strong> 再次请求这个缓存结果</li><li><strong>浏览器缓存</strong> 返回该请求的缓存结果</li></ol><ul><li>协商缓存失效，返回200和请求结果</li></ul><p><img src="/images/consult-cache-2.jpg" alt="consult-cache-2">  </p><ol><li><strong>浏览器</strong> 发起 HTTP 请求，先经过 <strong>浏览器缓存</strong></li><li><strong>浏览器缓存</strong> 判断该请求的缓存结果失效，返回缓存标识</li><li><strong>浏览器</strong> 携带该标识，向 <strong>服务器</strong> 发起 HTTP 请求</li><li><strong>服务器</strong> 返回 200 告诉 <strong>浏览器</strong> 资源可以更新了</li><li><strong>浏览器</strong> 读取并将请求结果和缓存标识存入 <strong>浏览器缓存</strong> 中</li></ol><h2 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h2><p>浏览器第一次请求资源的时候，服务器返回的响应头上会带有一个 <code>Last-Modified</code> 字段，表示资源<strong>最后修改</strong>的时间。</p><pre><code class="hljs http"><span class="hljs-attribute">Last-Modified</span>: Fri, 27 Oct 2017 07:55:30 GMT</code></pre><p>当浏览器再次请求该资源时，请求头中会带有一个 <code>If-Modified-Since</code> 字段，这个值是第一次请求返回的 <code>Last-Modified</code> 的值。</p><p>服务器收到这个请求后，将 <code>If-Modified-Since</code> 和当前的 <code>Last-Modified</code> 进行对比。</p><p>如果相等，则说明资源未修改，返回 <code>304</code>，浏览器使用本地缓存。</p><p>这个方法也是有缺点的：</p><ul><li>最小单位是秒。也就是说如果我短时间内资源发生了改变，<code>Last-Modified</code> 并不会发生变化；</li><li>周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为。</li></ul><p>所以，后来又引入一个 <code>Etag</code>。</p><h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><p><code>Etag</code> 一般是由文件内容 <code>hash</code> 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 <code>Etag</code> 发生改变。</p><p>同样地，在浏览器第一次请求资源时，服务器会返回一个 <code>Etag</code> 标识。</p><p>当再次请求该资源时， 会通过 <code>If-no-match</code> 字段将 <code>Etag</code> 发送回服务器，然后服务器进行比较，如果相等，则返回 <code>304</code> 表示未修改。</p><p><code>Last-Modified</code> 和 <code>Etag</code> 是可以同时设置的，服务器会优先校验 <code>Etag</code>，如果 <code>Etag</code> 相等就会继续比对 <code>Last-Modified</code>，最后才会决定是否返回 <code>304</code>。</p><h1 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h1><ol><li>频繁变动的资源</li></ol><blockquote><p><code>Cache-Control: no-cache</code></p></blockquote><p>对于频繁变动的资源，首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code>或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><ol start="2"><li>不常变化的资源</li></ol><blockquote><p><code>Cache-Control: max-age=31536000</code></p></blockquote><p>通常在处理这类资源时，给它们的 <code>Cache-Control</code> 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。</p><p>而为了解决更新的问题，就需要在文件名(或者路径) 中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。</p><p>在线提供的类库 (如 <code>jquery-3.3.1.min.js</code>, <code>lodash.min.js</code> 等) 均采用这个模式。</p><h1 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h1><p>用户在浏览器如何操作时，会触发 3种缓存策略 ：</p><ul><li>打开网页，地址栏输入地址： 查找 <strong>disk cache</strong> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <strong>memory cache</strong> 是可用的，会被优先使用(如果匹配的话)。其次才是 <strong>disk cache</strong>。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code> (为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 HTTP协议</title>
    <link href="/2020/11/08/%E6%B5%85%E8%B0%88%20HTTP%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88%20HTTP%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><blockquote><p>HTTP（超文本传输协议，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。</p></blockquote><p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。</p><p>默认使用 80 端口，HTTP 客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的 TCP 连接。</p><p>HTTP协议和 TCP协议是不冲突的，HTTP 定义在七层协议中的应用层，TCP 解决的是传输层的逻辑。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>HTTP1.0 是第一个在通讯中指定版本号的 HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。</p><p>HTTP1.1是当前版本，持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。</p><p>HTTP2.0 在 HTTP1.x 的基础上，大幅度的提高了 Web 性能，减少了网络延迟。</p><p>HTTP1.0 和 1.1 在之后很长的一段时间内会一直并存，这是由于网络基础设施更新缓慢所决定的。</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>HTTP1.0 是 HTTP 协议老的标准，其为了提高系统系统的效率，规定浏览器与服务器只保持短暂的连接，浏览器每一次请求都需要与服务器建立一个 TCP 连接。</p><p>TCP 协议提供传输控制，按顺序组织数据，和错误纠正。HTTP 协议的瓶颈和优化都是基于 TCP 协议本身的。如 TCP 建立连接时需要三次握手，三次握手有 1.5 个 RTT（Round-Trip-Time）的延迟，TCP 在建立初期还有慢启动（Slow Start）的特性，所有连接的重用总是比新建连接性能要好。</p><p>HTTP1.0 支持长连接，需要设置 <code>Connection: keep-alive</code>参数来告诉服务器端要建立一个长连接。</p><p>HTTP1.0 在请求方式新增了POST，DELETE，PUT，HEADER等方式</p><p>增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)</p><p>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输</p><p>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p><p>HTTP 1.0 特性：</p><ul><li>无状态：服务器不跟踪不记录请求过程的状态</li><li>无连接：浏览器每次请求都需要建立 TCP 连接</li></ul><p>对于「无状态」的特性可以借助 cookie/session 机制来做身认证和状态记录</p><p>无连接则导致性能缺陷：</p><ol><li><p>无法复用连接</p><blockquote><p>每次发送请求都需要一次 TCP 连接 （3次握手，4次挥手），使网路的传输效率非常低</p></blockquote></li><li><p>队头堵塞</p><blockquote><p>HTTP1.0 规定在前一个请求响应到达之后，下一个请求才能发送。如果前一个阻塞，后面的请求也阻塞</p></blockquote></li></ol><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>1.1 是 1.0 发布之后半年就推出的版本。为了解决传输效率的问题，1.1完善 1.0 版本。</p><p>HTTP 1.1 默认支持长连接（持久连接）无需手动设置 <code>Connection: keep-alive</code>，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><p>基于上面的长连接基础，HTTP1.1 还引入了管道机制（Pipelining）。管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</p><p>HTTP1.1 的默认模式是使用管道机制的长连接。</p><p>在 HTTP1.1 中默认允许<code>Connection: keep-alive</code>  但是在一个 TCP 连接里面数据通信是按次序进行的，服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>HTTP1.1 特性：</p><ul><li><p>基于管道化的长连接</p><blockquote><p>默认支持管道化的长连接，无需设置请求头<code>Connection: keep-alive</code> 。可以不等第一请求响应，继续发送请求。但是响应的顺序还是按照请求的顺序返回，第一个响应如果阻塞后面请求的响应也一样阻塞。队头堵塞的问题依然没有得到解决</p></blockquote></li><li><p>缓存处理</p><blockquote><p>新增加字段 <code>cache-control</code></p><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。</p></blockquote></li><li><p>支持断点续传</p><blockquote><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p></blockquote></li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><blockquote><p>HTTP2.0 比之前的协议在性能上有很大的提升。</p></blockquote><p><strong>HTTP2.0 协议拥有了新的特性：</strong></p><p><strong>多路复用 (Multiplexing)</strong></p><p>多路复用允许同时通过单一的 HTTP2.0 连接发起多重的 <em>请求-响应</em> 消息。</p><p>在 HTTP1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。</p><p>HTTP2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p><p>帧（frame）和流（stream）是 HTTP2.0 中两个很重要的概念：</p><p>帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流就是由多个帧组成的数据流。</p><p>多路复用，也就是在一个 TCP 连接中可以存在多条流，就是我们所说的可以发送多个请求，对端可以通过帧的标示知道，该帧属于哪个流（请求），通过这个技术及意义避免 HTTP 1.x 中的队头阻塞问题，极大的提高传输性能。</p><p><strong>二进制分帧</strong></p><p>HTTP1.x 的解析是基于文本，HTTP2.0 之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率</p><p>HTTP2.0 在 应用层 (HTTP2.0) 和传输层 (TCP or UDP) 之间增加一个二进制分帧层。在不改动 HTTP1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。</p><p>HTTP2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。</p><p><strong>首部压缩（Header Compression）</strong></p><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。</p><p>HTTP1.1并不支持 HTTP 首部压缩， HTTP2.0 使用了专门为首部压缩而设计的 HPACK 算法。</p><p>HTTP2.0 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源</p><p><strong>服务端推送（Server Push）</strong></p><p>HTTP2.0 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送</p><blockquote><p>服务端推送是一种在客户端请求之前发送数据的机制。</p></blockquote><p>在 HTTP2.0 中，服务器可以对客户端的一个请求发送多个响应。服务器可以额外的向客户端推送资源，而无需客户端明确的请求</p><p>当我们对支持 HTTP2.0 的服务器请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。</p><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。</p><p>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了HTTPS。</p><p>HTTPS 在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。</p><p>TLS/SSL 协议不仅仅是一套加密传输的协议，TLS/SSL 中使用了非对称加密，对称加密以及 HASH 算法。</p><p>握手过程的简单描述如下：</p><ol><li><p>浏览器将自己支持的一套加密规则发送给网站。</p></li><li><p>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。</p><blockquote><p>证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息</p></blockquote></li><li><p>获得网站证书之后浏览器要做以下工作：</p><ol><li>验证证书的合法性</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密</li><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站</li></ol></li><li><p>网站接收浏览器发来的数据之后要做以下的操作：</p><ol><li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致</li><li>使用密码加密一段握手消息，发送给浏览器</li></ol></li><li><p>浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p></li></ol><p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据。</p><p>TLS 握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。</p><p>正是由于 HTTPS 非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息。默认 HTTP 的端口号为 80，HTTPS 的端口号为 443。</p><h2 id="HTTPS-和-HTTP-对比"><a href="#HTTPS-和-HTTP-对比" class="headerlink" title="HTTPS 和 HTTP 对比"></a>HTTPS 和 HTTP 对比</h2><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样，前者是80，后者是443</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 行在 SSL/TLS 之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的</li><li>HTTPS 可以有效的防止运营商劫持</li></ul><h2 id="HTTPS-握手过程"><a href="#HTTPS-握手过程" class="headerlink" title="HTTPS 握手过程"></a>HTTPS 握手过程</h2><h3 id="一、Client-→-Server"><a href="#一、Client-→-Server" class="headerlink" title="一、Client → Server"></a>一、Client → Server</h3><h4 id="Client-Hello"><a href="#Client-Hello" class="headerlink" title="Client Hello"></a>Client Hello</h4><p>握手开始时，总是由先客户端会发送 <code>Client Hello</code> 信息给服务端，主要包含</p><ul><li>Version Number 客户端支持的协议版本</li><li>Randomly Generated Data 32 字节长度的随机值，用于之后生成主密钥。</li><li>Session Identification Session ID，第一次连接时为空。</li><li>Cipher Suite 客户端支持的加密算法列表，按优先级顺序排列。</li></ul><h3 id="二、Server-→-Client"><a href="#二、Server-→-Client" class="headerlink" title="二、Server → Client"></a>二、Server → Client</h3><h4 id="Server-Hello"><a href="#Server-Hello" class="headerlink" title="Server Hello"></a>Server Hello</h4><p>接着，服务端收到客户端发来的消息之后，会返回 <code>Server Hello</code> 信息给客户端，告知客户端接下来使用的一些参数</p><ul><li>Version Number 通信协议版本</li><li>Randomly Generated Data 32 字节长度的随机值，用于之后生成主密钥</li><li>Session Identification Session ID</li><li>Cipher Suite 加密算法</li></ul><h4 id="Server-Certificate-证书"><a href="#Server-Certificate-证书" class="headerlink" title="Server Certificate 证书"></a>Server Certificate 证书</h4><p>服务端还会带上证书返回给客户端。证书中含有服务端的公钥、网站地址、证书的颁发机构等信息。</p><p>客户端收到服务端返回的证书之后，会验证该证书的真实合法性。</p><h4 id="Server-Key-Exchange-额外数据"><a href="#Server-Key-Exchange-额外数据" class="headerlink" title="Server Key Exchange 额外数据"></a>Server Key Exchange 额外数据</h4><p>这个是可选的，取决于使用的加密算法。主要是携带密钥交换的额外数据。</p><h4 id="Server-Hello-Done"><a href="#Server-Hello-Done" class="headerlink" title="Server Hello Done"></a>Server Hello Done</h4><p>表示服务端已经发送完毕，并等待客户端回应。</p><h3 id="三、Client-→-Server"><a href="#三、Client-→-Server" class="headerlink" title="三、Client → Server"></a>三、Client → Server</h3><h4 id="Client-Key-Exchange"><a href="#Client-Key-Exchange" class="headerlink" title="Client Key Exchange"></a>Client Key Exchange</h4><p>客户端使用之前发送给服务端及服务端返回的随机数，生成预主密钥，然后用服务端返回的公钥进行加密。</p><h4 id="Change-Cipher-Spec"><a href="#Change-Cipher-Spec" class="headerlink" title="Change Cipher Spec"></a>Change Cipher Spec</h4><p>告诉服务端，之后的所有信息都会使用协商好的密钥和算法加密</p><h4 id="Client-Finished"><a href="#Client-Finished" class="headerlink" title="Client Finished"></a>Client Finished</h4><p>客户端的握手工作已经完成。这条信息是握手过程中所有消息的散列值。</p><h3 id="四、Server-→-Client"><a href="#四、Server-→-Client" class="headerlink" title="四、Server → Client"></a>四、Server → Client</h3><h4 id="Change-Cipher-Spec-Message"><a href="#Change-Cipher-Spec-Message" class="headerlink" title="Change Cipher Spec Message"></a>Change Cipher Spec Message</h4><p>告知客户端，会使用刚刚协商的密钥来加密信息</p><h4 id="Server-Finished-Message"><a href="#Server-Finished-Message" class="headerlink" title="Server Finished Message"></a>Server Finished Message</h4><p>表示服务端的握手工作已经完成</p><h2 id="数字证书申请流程"><a href="#数字证书申请流程" class="headerlink" title="数字证书申请流程"></a>数字证书申请流程</h2><ol><li>网站提交身份信息给CA机构</li><li>CA机构审核信息的真实性</li><li>对信息进行Hash，计算信息摘要</li><li>CA机构的密钥加密信息摘要，得到数字签名</li></ol><h2 id="浏览器验证证书"><a href="#浏览器验证证书" class="headerlink" title="浏览器验证证书"></a>浏览器验证证书</h2><ol><li>浏览器利用证书的原始信息计算得到信息摘要</li><li>利用CA的公钥解密数字证书中的数字签名，解密出来的数据也是信息摘要</li><li>比较两个摘要是否相等</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《前端100问》30</title>
    <link href="/2020/11/06/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B30/"/>
    <url>/2020/11/06/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B30/</url>
    
    <content type="html"><![CDATA[<h1 id="21、有以下-3-个判断数组的方法，请分别介绍它们之间的区别和优劣"><a href="#21、有以下-3-个判断数组的方法，请分别介绍它们之间的区别和优劣" class="headerlink" title="21、有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣"></a>21、有以下 3 个判断数组的方法，请分别介绍它们之间的区别和优劣</h1><blockquote><p>Object.prototype.toString.call() 、 instanceof 以及 Array.isArray()</p></blockquote><h2 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h2><p>每一个继承 Object 的对象都有 <code>toString</code> 方法，如果 <code>toString</code> 方法没有重写的话，会返回 <code>[Object type]</code>，其中 type 为对象的类型。</p><p>但当除了 Object 类型的对象外，其他类型直接使用 <code>toString</code> 方法时，会直接返回都是内容的字符串，所以我们需要使用 call 或者 apply 方法来改变 toString 方法的执行上下文。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> an = [<span class="hljs-string">&#x27;Hello&#x27;</span>,<span class="hljs-string">&#x27;An&#x27;</span>];an.toString(); <span class="hljs-comment">// &quot;Hello,An&quot;</span><span class="hljs-built_in">Object</span>.prototype.toString.call(an); <span class="hljs-comment">// &quot;[object Array]&quot;</span></code></pre><p>这种方法对于所有基本的数据类型都能进行判断，即使是 null 和 undefined 。</p><p><code>Object.prototype.toString.call()</code> 常用于判断浏览器内置对象时。</p><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><p><code>instanceof</code> 的内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p><p>使用 <code>instanceof</code>判断一个对象是否为数组，<code>instanceof</code> 会判断这个对象的原型链上是否会找到对应的 <code>Array</code> 的原型，找到返回 <code>true</code>，否则返回 <code>false</code>。</p><p>但 <code>instanceof</code> 只能用来判断对象类型，原始类型不可以。并且所有对象类型 instanceof Object 都是 true。</p><h2 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h2><p>功能：用来判断对象是否为数组</p><ul><li>instanceof 与 isArray</li></ul><p>当检测Array实例时，<code>Array.isArray</code> 优于 <code>instanceof</code> ，因为 <code>Array.isArray</code> 可以检测出 <code>iframes</code></p><ul><li><code>Array.isArray()</code> 与 <code>Object.prototype.toString.call()</code></li></ul><p><code>Array.isArray()</code>是ES5新增的方法，当不存在 <code>Array.isArray()</code> ，可以用 <code>Object.prototype.toString.call()</code> 实现。</p><p>就性能来说 Array.isArray 的性能最好，instanceof 比 toString.call 稍微好了一点点</p><p><strong>补充：</strong></p><p>typeof 不能校验 object 的其他类型，引用类型除了 function 都不能区分</p><p>instanceof 不能校验原始值类型</p><p>Object.prototype.toString.call() 不能校验自定义类型</p><h1 id="22、介绍下重绘和回流（Repaint-amp-Reflow），以及如何进行优化"><a href="#22、介绍下重绘和回流（Repaint-amp-Reflow），以及如何进行优化" class="headerlink" title="22、介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化"></a>22、介绍下重绘和回流（Repaint &amp; Reflow），以及如何进行优化</h1><ol><li>浏览器渲染机制</li></ol><ul><li>浏览器采用流式布局模型（<code>Flow Based Layout</code>）</li><li>浏览器会把<code>HTML</code>解析成<code>DOM</code>，把<code>CSS</code>解析成<code>CSSOM</code>，<code>DOM</code>和<code>CSSOM</code>合并就产生了渲染树（<code>Render Tree</code>）。</li><li>有了<code>RenderTree</code>，我们就知道了所有节点的样式，然后计算他们在页面 上的大小和位置，最后把节点绘制到页面上。</li><li>由于浏览器使用流式布局，对<code>Render Tree</code>的计算通常只需要遍历一次就可以完成，<strong>但<code>table</code>及其内部元素除外，他们可能需要多次计算，通常要花3倍于同等元素的时间，这也是为什么要避免使用<code>table</code>布局的原因之一</strong>。</li></ul><ol start="2"><li>重绘</li></ol><p>由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如<code>outline</code>, <code>visibility</code>, <code>color</code>、<code>background-color</code>等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。</p><ol start="3"><li>回流</li></ol><p>回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及 DOM 中紧随其后的节点、祖先节点元素的随后的回流。</p><p><strong>大部分的回流将导致页面的重新渲染，回流必定会发生重绘，重绘不一定会引发回流。</strong></p><ol start="4"><li>浏览器优化</li></ol><p>现代浏览器大多都是通过队列机制来批量更新布局，浏览器会把修改操作放在队列中，至少一个浏览器刷新（即16.6ms）才会清空队列，但当你<strong>获取布局信息的时候，队列中可能有会影响这些属性或方法返回值的操作，即使没有，浏览器也会强制清空队列，触发回流与重绘来确保返回正确的值</strong>。</p><p>主要包括以下属性或方法：</p><ul><li><code>offsetTop</code>、<code>offsetLeft</code>、<code>offsetWidth</code>、<code>offsetHeight</code></li><li><code>scrollTop</code>、<code>scrollLeft</code>、<code>scrollWidth</code>、<code>scrollHeight</code></li><li><code>clientTop</code>、<code>clientLeft</code>、<code>clientWidth</code>、<code>clientHeight</code></li><li><code>width</code>、<code>height</code></li><li><code>getComputedStyle()</code></li><li><code>getBoundingClientRect()</code></li></ul><p>所以，我们应该避免频繁的使用上述的属性，他们都会强制渲染刷新队列。</p><ol start="5"><li>减少重绘与回流</li></ol><p><strong>CSS</strong></p><ul><li><p><strong>使用</strong> <code>transform</code> <strong>替代</strong> <code>top</code></p></li><li><p><strong>使用</strong> <code>visibility</code> <strong>替换</strong> <code>display: none</code> ，<strong>因为前者只会引起重绘，后者会引发回流（改变了布局）</strong></p></li><li><p><strong>避免使用<code>table</code>布局</strong>，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局。</p></li><li><p>**尽可能在<code>DOM</code>树的最末端改变<code>class</code>**，回流是不可避免的，但可以减少其影响。尽可能在DOM树的最末端改变class，可以限制了回流的范围，使其影响尽可能少的节点。</p></li><li><p><strong>避免设置多层内联样式</strong>，CSS 选择符<strong>从右往左</strong>匹配查找，避免节点层级过多。</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">a</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span>  span &#123;    color: red;  &#125;  div &gt; a &gt; span &#123;    color: red;  &#125;<span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span></code></pre><p>对于第一种设置样式的方式来说，浏览器只需要找到页面中所有的 <code>span</code> 标签然后设置颜色，但是对于第二种设置样式的方式来说，浏览器首先需要找到所有的 <code>span</code> 标签，然后找到 <code>span</code> 标签上的 <code>a</code> 标签，最后再去找到 <code>div</code> 标签，然后给符合这种条件的 <code>span</code> 标签设置颜色，这样的递归过程就很复杂。所以我们应该尽可能的避免写<strong>过于具体</strong>的 CSS 选择器，然后对于 HTML 来说也尽量少的添加无意义标签，保证<strong>层级扁平</strong>。</p></li><li><p><strong>将动画效果应用到<code>position</code>属性为<code>absolute</code>或<code>fixed</code>的元素上</strong>，避免影响其他元素的布局，这样只是一个重绘，而不是回流，同时，控制动画速度可以选择 <code>requestAnimationFrame</code>，详见<a href="https://github.com/LuNaHaiJiao/blog/issues/30">探讨 requestAnimationFrame</a>。</p></li><li><p><strong>避免使用</strong> <code>CSS</code> <strong>表达式</strong>，可能会引发回流。</p></li><li><p><strong>将频繁重绘或者回流的节点设置为图层</strong>，图层能够阻止该节点的渲染行为影响别的节点，例如<code>will-change</code>、<code>video</code>、<code>iframe</code>等标签，浏览器会自动将该节点变为图层。</p></li><li><p><strong>CSS3 硬件加速（GPU加速）</strong>，使用 CSS3 硬件加速，可以让<code>transform</code>、<code>opacity</code>、<code>filters</code>这些动画不会引起回流重绘 。但是对于动画的其它属性，比如<code>background-color</code>这些，还是会引起回流重绘的，不过它还是可以提升这些动画的性能。</p></li></ul><p><strong>JavaScript</strong></p><ul><li><strong>避免频繁操作样式</strong>，最好一次性重写<code>style</code>属性，或者将样式列表定义为<code>class</code>并一次性更改<code>class</code>属性。</li><li><strong>避免频繁操作</strong><code>DOM</code>，创建一个<code>documentFragment</code>，在它上面应用所有<code>DOM操作</code>，最后再把它添加到文档中。</li><li><strong>避免频繁读取会引发回流/重绘的属性</strong>，如果确实需要多次使用，就用一个变量缓存起来。</li><li><strong>对具有复杂动画的元素使用绝对定位</strong>，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</li></ul><h1 id="23、介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景"><a href="#23、介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景" class="headerlink" title="23、介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景"></a>23、介绍下观察者模式和订阅-发布模式的区别，各自适用于什么场景</h1><p>观察者模式中主体和观察者是互相感知的，发布-订阅模式是借助第三方来实现调度的，发布者和订阅者之间互不感知</p><p>观察者模式 在软件设计中是一个对象，维护一个依赖列表，当任何状态发生改变自动通知它们。</p><p>在发布-订阅模式，消息的发送方，叫做发布者（publishers），消息不会直接发送给特定的接收者，叫做订阅者。</p><p>意思就是发布者和订阅者不知道对方的存在。需要一个第三方组件，叫做信息中介，它将订阅者和发布者串联起来，它过滤和分配所有输入的消息。换句话说，发布-订阅模式用来处理不同系统组件的信息交流，即使这些组件不知道对方的存在。</p><ul><li>在观察者模式中，观察者是知道 Subject 的，Subject 一直保持对观察者进行记录。然而，在发布订阅模式中，发布者和订阅者不知道对方的存在。它们只有通过消息代理进行通信。</li><li>在发布订阅模式中，组件是松散耦合的，正好和观察者模式相反。</li><li>观察者模式大多数时候是同步的，比如当事件触发，Subject 就会去调用观察者的方法。而发布-订阅模式大多数时候是异步的（使用消息队列）。</li><li>观察者 模式需要在单个应用程序地址空间中实现，而发布-订阅更像交叉应用模式。</li></ul><h1 id="24、聊聊-Redux-和-Vuex-的设计思想"><a href="#24、聊聊-Redux-和-Vuex-的设计思想" class="headerlink" title="24、聊聊 Redux 和 Vuex 的设计思想"></a>24、聊聊 Redux 和 Vuex 的设计思想</h1><p>不管是Vue，还是 React，都需要管理状态（state），比如组件之间都有共享状态的需要。如果不对状态进行有效的管理，状态在什么时候，由于什么原因，如何变化就会不受控制，就很难跟踪和测试了。</p><p>对于状态管理的解决思路就是：把组件之间需要共享的状态抽取出来，遵循特定的约定，统一来管理，让状态的变化可以预测。</p><p>最简单的处理就是把状态存到一个外部变量里面，比如：this.$root.$data，当然也可以是一个全局变量。但是这样有一个问题，就是数据改变后，不会留下变更过的记录，这样不利于调试。</p><p>所以我们稍微搞得复杂一点，用一个简单的 Store 模式：</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> store = &#123;  state: &#123;    message: <span class="hljs-string">&#x27;Hello!&#x27;</span>  &#125;,  setMessageAction (newValue) &#123;    <span class="hljs-comment">// 发生改变记录点日志啥的</span>    <span class="hljs-built_in">this</span>.state.message = newValue  &#125;,  clearMessageAction () &#123;    <span class="hljs-built_in">this</span>.state.message = <span class="hljs-string">&#x27;&#x27;</span>  &#125;&#125;</code></pre><p>store 的 state 来存数据，store 里面有一堆的 action，这些 action 来控制 state 的改变，也就是不直接去对 state 做改变，而是通过 action 来改变，因为都走 action，我们就可以知道到底改变（mutation）是如何被触发的，出现错误，也可以记录记录日志啥的。</p><p>组件不允许直接修改属于 store 实例的 state，组件必须通过 action 来改变 state，也就是说，组件里面应该执行 action 来分发 (dispatch) 事件通知 store 去改变。</p><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>Redux 里面只有一个 Store，整个应用的数据都在这个大 Store 里面。Store 的 State 不能直接修改，每次只能返回一个新的 State。Redux 整了一个 createStore 函数来生成 Store。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createStore &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;redux&#x27;</span>;<span class="hljs-keyword">const</span> store = createStore(fn);</code></pre><p>Store 允许使用 store.subscribe 方法设置监听函数，一旦 State 发生变化，就自动执行这个函数。这样不管 View 是用什么实现的，只要把 View 的更新函数 subscribe 一下，就可以实现 State 变化之后，View 自动渲染了。比如在 React 里，把组件的render方法或setState方法订阅进去就行。</p><h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><p>每一个 Vuex 里面有一个全局的 Store，包含着应用中的状态 State，这个 State 只是需要在组件中共享的数据，不用放所有的 State，没必要。这个 State 是单一的，和 Redux 类似，所以，一个应用仅会包含一个 Store 实例。单一状态树的好处是能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p><p>Vuex通过 store 选项，把 state 注入到了整个应用中，这样子组件能通过 this.$store 访问到 state 了。State 改变，View 就会跟着改变，这个改变利用的是 Vue 的响应式机制。</p><p>显而易见，State 不能直接改，需要通过一个约定的方式，这个方式在 Vuex 里面叫做 mutation，更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。</p><p>触发 mutation 事件的方式不是直接调用，比如 increment(state) 是不行的，而要通过 store.commit 方法</p><h1 id="25、说说浏览器和-Node-事件循环的区别"><a href="#25、说说浏览器和-Node-事件循环的区别" class="headerlink" title="25、说说浏览器和 Node 事件循环的区别"></a>25、说说浏览器和 Node 事件循环的区别</h1><h2 id="浏览器中的-Event-Loop"><a href="#浏览器中的-Event-Loop" class="headerlink" title="浏览器中的 Event Loop"></a>浏览器中的 Event Loop</h2><h3 id="1-Micro-Task-与-Macro-Task"><a href="#1-Micro-Task-与-Macro-Task" class="headerlink" title="1. Micro-Task 与 Macro-Task"></a>1. Micro-Task 与 Macro-Task</h3><p>浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。宏任务队列可以有多个，微任务队列只有一个。</p><ul><li>常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。</li><li>常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。</li></ul><h3 id="2-Event-Loop-过程解析"><a href="#2-Event-Loop-过程解析" class="headerlink" title="2. Event Loop 过程解析"></a>2. Event Loop 过程解析</h3><ul><li>一开始执行栈空,我们可以把执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li><li>全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li><li>上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。</li><li>执行渲染操作，更新界面</li><li>检查是否存在 Web worker 任务，如果有，则对其进行处理</li><li>上述过程循环往复，直到两个队列都清空</li></ul><p>当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。</p><h2 id="Node-中的-Event-Loop"><a href="#Node-中的-Event-Loop" class="headerlink" title="Node 中的 Event Loop"></a>Node 中的 Event Loop</h2><h3 id="1-Node-简介"><a href="#1-Node-简介" class="headerlink" title="1.Node 简介"></a>1.Node 简介</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p><p>Node.js 采用 V8 作为 js 的解析引擎，而 I/O 处理方面使用了自己设计的 libuv，libuv 是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现。</p><h3 id="Node-js的运行机制如下"><a href="#Node-js的运行机制如下" class="headerlink" title="Node.js的运行机制如下:"></a>Node.js的运行机制如下:</h3><ol><li>V8 引擎解析JavaScript脚本。</li><li>解析后的代码，调用Node API。</li><li>libuv 库负责 Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li><li>V8引擎再将结果返回给用户。</li></ol><h3 id="2-六个阶段"><a href="#2-六个阶段" class="headerlink" title="2.六个阶段"></a>2.六个阶段</h3><p>其中 libuv 引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。</p><p>每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p><p>Node.js 中的事件循环的顺序：</p><p>外部输入数据 → 轮询阶段(poll) → 检查阶段(check) → 关闭事件回调阶段(close callback) → 定时器检测阶段(timer) → I/O事件回调阶段(I/O callbacks) → 闲置阶段(idle, prepare) → 轮询阶段（按照该顺序反复运行）…</p><ul><li><p>timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调</p></li><li><p>I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调</p></li><li><p>idle, prepare 阶段：仅node内部使用</p></li><li><p>poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里</p></li><li><p>check 阶段：执行 setImmediate() 的回调</p></li><li><p>close callbacks 阶段：执行 socket 的 close 事件回调</p><p>注意：上面六个阶段都不包括 <strong>process.nextTick()</strong></p></li></ul><h3 id="3-Micro-Task-与-Macro-Task"><a href="#3-Micro-Task-与-Macro-Task" class="headerlink" title="3. Micro-Task 与 Macro-Task"></a>3. Micro-Task 与 Macro-Task</h3><p>Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。</p><ul><li>常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。</li><li>常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。</li></ul><p><strong>process.nextTick</strong><br>这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。</p><h2 id="Node与浏览器的-Event-Loop-差异"><a href="#Node与浏览器的-Event-Loop-差异" class="headerlink" title="Node与浏览器的 Event Loop 差异"></a>Node与浏览器的 Event Loop 差异</h2><p>浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。</p><p>而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务。</p><p>总结：</p><p>浏览器和Node 环境下，microtask 任务队列的执行时机不同</p><ul><li>Node端，microtask 在事件循环的各个阶段之间执行</li><li>浏览器端，microtask 在事件循环的 macrotask 执行完之后执行</li></ul><p>但是，在Node版本更新到11之后，<strong>Event Loop运行原理发生了变化，一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这点就跟浏览器端一致。</strong></p><h1 id="26、介绍模块化发展历程"><a href="#26、介绍模块化发展历程" class="headerlink" title="26、介绍模块化发展历程"></a>26、介绍模块化发展历程</h1><blockquote><p>可从IIFE、AMD、CMD、CommonJS、UMD、webpack(require.ensure)、ES Module、<code>&lt;script type=&quot;module&quot;&gt;</code> 这几个角度考虑。</p></blockquote><p><strong>模块化主要是用来抽离公共代码，隔离作用域，避免变量冲突等。</strong></p><p>因为一开始 JavaScript 本身没有提供模块化的机制，所以才会衍生出 CommonJS、AMD、CMD 和 UMD 这么多模块化规范。JavaScript 在 ES6 时原生提供了 import 和export 模块化机制</p><p><strong>IIFE</strong>： 使用自执行函数来编写模块化，特点：<strong>在一个单独的函数作用域中执行代码，避免变量冲突</strong>。</p><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> &#123;data:[]  &#125;&#125;)()</code></pre><p><strong>AMD</strong>： 使用requireJS 来编写模块化，特点：<strong>依赖必须提前声明好</strong>。</p><pre><code class="hljs js">define(<span class="hljs-string">&#x27;./index.js&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">code</span>)</span>&#123;<span class="hljs-comment">// code 就是index.js 返回的内容</span>&#125;)</code></pre><p><strong>CMD</strong>： 使用seaJS 来编写模块化，特点：<strong>支持动态引入依赖文件</strong>。</p><pre><code class="hljs js">define(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">require, exports, module</span>) </span>&#123;    <span class="hljs-keyword">var</span> indexCode = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./index.js&#x27;</span>);&#125;);</code></pre><p><strong>CommonJS</strong>： node.js 中自带的模块化。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);</code></pre><p>特点: <code>require</code>、<code>module.exports</code>、<code>exports</code><br>CommonJS 一般用在服务端或者Node用来同步加载模块，它对于模块的依赖发生在代码运行阶段，不适合在浏览器端做异步加载。</p><p><strong>UMD</strong>：兼容AMD，CommonJS 模块化语法。</p><p>**webpack(require.ensure)**：webpack 2.x 版本中的代码分割。</p><p><strong>ES Module</strong>： ES6 引入的模块化，支持import 来引入另一个 js 。</p><pre><code class="hljs js"><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;a&#x27;</span>;</code></pre><p>特点: <code>import</code>、<code>export</code><br>ES6模块化不是对象，<code>import</code>会在JavaScript引擎静态分析，在编译时就引入模块代码，而并非在代码运行时加载，因此也不适合异步加载。</p><p>ES Module 的优势：</p><ul><li>死代码检测和排除。我们可以用静态分析工具检测出哪些模块没有被调用过。比如，在引入工具类库时，工程中往往只用到了其中一部分组件或接口，但有可能会将其代码完整地加载进来。未被调用到的模块代码永远不会被执行，也就成为了死代码。通过静态分析可以在打包时去掉这些未曾使用过的模块，以减小打包资源体积。</li><li>模块变量类型检查。JavaScript属于动态类型语言，不会在代码执行前检查类型错误（比如对一个字符串类型的值进行函数调用）。ES6 Module的静态模块结构有助于确保模块之间传递的值或接口类型是正确的。</li><li>编译器优化。在CommonJS等动态模块系统中，无论采用哪种方式，本质上导入的都是一个对象，而ES6 Module支持直接导入变量，减少了引用层级，程序效率更高。</li></ul><h2 id="二者的差异"><a href="#二者的差异" class="headerlink" title="二者的差异"></a>二者的差异</h2><h3 id="CommonJS模块引用后是一个值的拷贝，而ESModule引用后是一个值的动态映射，并且这个映射是只读的。"><a href="#CommonJS模块引用后是一个值的拷贝，而ESModule引用后是一个值的动态映射，并且这个映射是只读的。" class="headerlink" title="CommonJS模块引用后是一个值的拷贝，而ESModule引用后是一个值的动态映射，并且这个映射是只读的。"></a>CommonJS模块引用后是一个值的拷贝，而ESModule引用后是一个值的动态映射，并且这个映射是只读的。</h3><ul><li>CommonJS 模块输出的是值的拷贝，一旦输出之后，无论模块内部怎么变化，都无法影响之前的引用。</li><li>ESModule 是引擎会在遇到<code>import</code>后生成一个引用链接，在脚本真正执行时才会根据这个引用链接去模块里面取值，模块内部的原始值变了<code>import</code>加载的模块也会变。</li></ul><h3 id="CommonJS运行时加载，ESModule编译阶段引用。"><a href="#CommonJS运行时加载，ESModule编译阶段引用。" class="headerlink" title="CommonJS运行时加载，ESModule编译阶段引用。"></a>CommonJS运行时加载，ESModule编译阶段引用。</h3><ul><li>CommonJS在引入时是加载整个模块，生成一个对象，然后再从这个生成的对象上读取方法和属性。</li><li>ESModule 不是对象，而是通过<code>export</code>暴露出要输出的代码块，在<code>import</code>时使用静态命令的方法引用指定的输出代码块，并在<code>import</code>语句处执行这个要输出的代码，而不是直接加载整个模块。</li></ul><h1 id="27、全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？"><a href="#27、全局作用域中，用-const-和-let-声明的变量不在-window-上，那到底在哪里？如何去获取？" class="headerlink" title="27、全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？"></a>27、全局作用域中，用 const 和 let 声明的变量不在 window 上，那到底在哪里？如何去获取？</h1><p>在 ES5 中，顶层对象的属性和全局变量是等价的，var 命令和 function 命令声明的全局变量，自然也是顶层对象。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">12</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.a); <span class="hljs-comment">// 12</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.f); <span class="hljs-comment">// f()&#123;&#125;</span></code></pre><p>但 ES6 规定，var 命令和 function 命令声明的全局变量，依旧是顶层对象的属性，但 let 命令、const 命令、class 命令声明的全局变量，不属于顶层对象的属性。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> aa = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> bb = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.aa); <span class="hljs-comment">// undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">window</span>.bb); <span class="hljs-comment">// undefined</span></code></pre><p>在全局作用域中，用 let 和 const 声明的全局变量并没有在全局对象中，只是一个块级作用域（Script）中</p><p>在定义变量的块级作用域中就能获取啊，既然不属于顶层对象，那就不加 window（global）呗。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> aa = <span class="hljs-number">1</span>;<span class="hljs-keyword">const</span> bb = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(aa); <span class="hljs-comment">// 1</span><span class="hljs-built_in">console</span>.log(bb); <span class="hljs-comment">// 2</span></code></pre><h1 id="28、cookie-和-token-都存放在-header-中，为什么不会劫持-token？"><a href="#28、cookie-和-token-都存放在-header-中，为什么不会劫持-token？" class="headerlink" title="28、cookie 和 token 都存放在 header 中，为什么不会劫持 token？"></a>28、cookie 和 token 都存放在 header 中，为什么不会劫持 token？</h1><p>形象的比喻一下：</p><p>cookie 就好比如：你将身份证给管理员看了一下，他记录下你的身份证号然后发给你一个编号，每次你出示编号，他拿着编号去查你的身份证号</p><p>token：就是直接给服务员看自己的身份证</p><p>cookie ：可以存一些用户信息。因为 HTTP 是无状态的，它不知道你有没有登陆过。故可以通过cookie里的信息解决无状态的问题。</p><p>而浏览器，会自动带上请求同域的cookie。（AJAX 不会自动携带cookie）</p><p>token ：后端把用户信息和其他内容放进去，通过 jwt 生成 token，返回给前端。<br>浏览器是不会自动携带 token。</p><h1 id="29、聊聊-Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的"><a href="#29、聊聊-Vue-的双向数据绑定，Model-如何改变-View，View-又是如何改变-Model-的" class="headerlink" title="29、聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的"></a>29、聊聊 Vue 的双向数据绑定，Model 如何改变 View，View 又是如何改变 Model 的</h1><p>Vue2.x版本 的双向数据绑定核心是利用了 ES5  JavaScript 提供的元编程接口 <code>Object.defineProperty</code>  进行数据劫持，这也是Vue 不兼容 IE8及以下的浏览器的原因</p><p><code>Object.defineProperty</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，我们可以利用<code>Object.defineProperty</code>提供的set、get 为对象属性设置 setter、getter方法，当我们访问或是修改对象属性时，就会触发 setter、getter 函数逻辑。</p><p>在 Vue 的初始化阶段会对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>watch</code> 等属性做了初始化操作挂载到vm实例上，通过vm.XX就可以访问到。调用 <code>observe</code> 方法给非 VNode 的对象类型数据添加一个 <code>Observer</code></p><p>通过 <code>Observer</code> 给对象的属性添加 getter 和 setter，同时还初始化了一个Dep 实例用于依赖收集和派发更新</p><p>给数据添加了 getter 和 setter，目的就是为了在我们访问数据以及写数据的时候能自动执行一些逻辑：getter 做的事情是依赖收集，setter 做的事情是派发更新。</p><p>在 <code>get</code> 函数中通过 <code>dep.depend</code> 做依赖收集，在<code>set</code>中通过另一个是 <code>dep.notify()</code>，通知所有的订阅者</p><p>Dep 是整个 getter 依赖收集的核心，<code>Dep</code> 是一个 Class，它定义了一些属性和方法，它有一个静态属性 <code>target</code>，这是一个全局唯一 <code>Watcher</code>，在同一时间只能有一个全局的 <code>Watcher</code> 被计算，另外它的自身属性 <code>subs</code> 也是 <code>Watcher</code> 的数组。</p><p><code>Watcher</code> 是一个 Class，在它的构造函数中，定义了一些和 <code>Dep</code> 相关的属性</p><p>当对数据对象的访问会触发他们的 getter 方法， Vue 的 mount 过程是通过 <code>mountComponent</code> 函数</p><p>收集依赖的目的是为了当这些响应式数据发生变化，触发它们的 setter 的时候，能知道应该通知哪些订阅者去做相应的逻辑处理，我们把这个过程叫派发更新，其实 <code>Watcher</code> 和 <code>Dep</code> 就是一个非常经典的观察者设计模式的实现</p><p>当我们在组件中对响应的数据做了修改，就会触发 setter 的逻辑，最后调用 <code>dep.notify()</code> 方法，他还遍历遍历<code>dep</code>所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法</p><h1 id="30、两个数组合并成一个数组"><a href="#30、两个数组合并成一个数组" class="headerlink" title="30、两个数组合并成一个数组"></a>30、两个数组合并成一个数组</h1><blockquote><p>请把两个数组 [‘A1’, ‘A2’, ‘B1’, ‘B2’, ‘C1’, ‘C2’, ‘D1’, ‘D2’] 和 [‘A’, ‘B’, ‘C’, ‘D’]，合并为 [‘A1’, ‘A2’, ‘A’, ‘B1’, ‘B2’, ‘B’, ‘C1’, ‘C2’, ‘C’, ‘D1’, ‘D2’, ‘D’]。</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;A1&#x27;</span>, <span class="hljs-string">&#x27;A2&#x27;</span>, <span class="hljs-string">&#x27;B1&#x27;</span>, <span class="hljs-string">&#x27;B2&#x27;</span>, <span class="hljs-string">&#x27;C1&#x27;</span>, <span class="hljs-string">&#x27;C2&#x27;</span>, <span class="hljs-string">&#x27;D1&#x27;</span>, <span class="hljs-string">&#x27;D2&#x27;</span>]<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>, <span class="hljs-string">&#x27;D&#x27;</span>]<span class="hljs-keyword">const</span> arr3 = arr2.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item + <span class="hljs-number">3</span>)<span class="hljs-built_in">console</span>.log(arr3) <span class="hljs-comment">//[ &#x27;A3&#x27;, &#x27;B3&#x27;, &#x27;C3&#x27;, &#x27;D3&#x27; ]</span><span class="hljs-keyword">const</span> arr4 = [...arr1, ...arr3].sort()<span class="hljs-built_in">console</span>.log(arr4)<span class="hljs-comment">//[&quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;B1&quot;, &quot;B2&quot;, &quot;B3&quot;, &quot;C1&quot;, &quot;C2&quot;, &quot;C3&quot;, &quot;D1&quot;, &quot;D2&quot;, &quot;D3&quot;]</span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《前端100问》20</title>
    <link href="/2020/11/06/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B20/"/>
    <url>/2020/11/06/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B20/</url>
    
    <content type="html"><![CDATA[<h1 id="11、算法手写题-数组扁平化去重"><a href="#11、算法手写题-数组扁平化去重" class="headerlink" title="11、算法手写题 数组扁平化去重"></a>11、算法手写题 数组扁平化去重</h1><blockquote><p>已知如下数组：</p><p>var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13, [14] ] ] ], 10];</p><p>编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组</p></blockquote><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.from(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr.flat(<span class="hljs-literal">Infinity</span>))).sort((<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a - b))</code></pre><p><code>Array.prototype.flat()</code>用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响。</p><p><code>flat()</code>默认只会“拉平”一层，如果想要“拉平”多层的嵌套数组，可以将<code>flat()</code>方法的参数写成一个整数，表示想要拉平的层数，默认为1。</p><p>如果不管有多少层嵌套，都要转成一维数组，可以用<code>Infinity</code>关键字作为参数。</p><h1 id="12、JS-异步解决方案的发展历程以及优缺点"><a href="#12、JS-异步解决方案的发展历程以及优缺点" class="headerlink" title="12、JS 异步解决方案的发展历程以及优缺点"></a>12、JS 异步解决方案的发展历程以及优缺点</h1><p>按时间顺序：</p><ol><li>回调函数（callback）</li><li>Promise</li><li>Generator</li><li>Async/await</li></ol><p>优缺点：</p><h2 id="回调函数（callback）"><a href="#回调函数（callback）" class="headerlink" title="回调函数（callback）"></a>回调函数（callback）</h2><p><strong>优点：解决了同步的问题</strong>（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）</p><p>缺点：回调地狱，不能用 try catch 捕获错误，不能 return</p><p>回调地狱的根本问题在于：</p><ul><li>缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符</li><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（<strong>控制反转</strong>）</li><li>嵌套函数过多的多话，很难处理错误</li></ul><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><blockquote><p>Promise就是为了解决callback的问题而产生的。</p></blockquote><p><strong>优点：解决了回调地狱的问题</strong></p><p><strong>缺点：无法取消 Promise ，错误需要通过回调函数来捕获</strong></p><h2 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h2><p><strong>特点：可以控制函数的执行</strong>，可以配合 co 函数库使用</p><p>缺点：需要手动调用函数执行，麻烦</p><h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><blockquote><p>async、await 是异步的终极解决方案</p></blockquote><p><strong>优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题。async 相比于 Generator内置了执行器，拥有更好的语义化</strong> </p><p><strong>缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。</strong></p><h1 id="13、Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？"><a href="#13、Promise-构造函数是同步执行还是异步执行，那么-then-方法呢？" class="headerlink" title="13、Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？"></a>13、Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？</h1><p>Promise 构造函数是同步执行的，而then方法里面的执行函数一般是放到微任务队列的异步任务所以是异步执行</p><p><strong>扩展：什么是Promise？</strong></p><p>Promise 是解决异步编程的一种方案。以前我们处理异步操作，一般都是通过回调函数来处理，典型的例子就好像使用<code>setTimeout</code>一样，如果执行操作函数里面还有<code>setTimeout</code>，一层一层往下，都有的话。那么代码看起来十分臃肿，不利于维护，也很容易写出bug。</p><p>而Promise的出现，能够让异步编程变得更加可观，把异步操作按照同步操作的流程表达出来，避免层层嵌套的回调函数。</p><p>Promise 对象有三种状态，进行中<code>pending</code>、完成成功<code>fulfilled</code>、失败<code>rejected</code>，顾名思义，表示这个异步操作是进行中还是成功还是失败了。</p><p>Promise 的状态一旦确定了，就不会再更改了，这就是 promise（承诺）的由来吧，承诺状态确定了就是确定了。</p><p>然而Promise还是有不足的地方：</p><ol><li>如果没有执行捕获错误的函数（如下述说的 catch，then 的第二个参数），则 Promise 内部发生的错误（虽然会报错但）是无法传递到 Promise 外部代码上的，因此外部脚本并不会因为错误而导致不继续执行下去。</li><li>一旦新建了，就无法中断它的操作。不像<code>setTimeout</code>那样，我还可以使用<code>clearTimeout</code>取消掉。</li></ol><h1 id="14、如何实现一个-new"><a href="#14、如何实现一个-new" class="headerlink" title="14、如何实现一个 new"></a>14、如何实现一个 new</h1><p><code>new</code> 在执行时，会做下面这四件事：</p><ol><li><p>开辟内存空间，在内存中创建一个新的空对象。</p></li><li><p>让 this 指向这个新的对象。</p></li><li><p>执行构造函数里面的代码，给这个新对象添加属性和方法。</p></li><li><p>返回这个新对象（所以构造函数里面不需要 return）</p></li></ol><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 1. 创建了一个全新的对象。</span><span class="hljs-comment"> * 2. 这个对象会被执行[[Prototype]]（也就是__proto__）链接。</span><span class="hljs-comment"> * 3. 生成的新对象会绑定到函数调用的this。</span><span class="hljs-comment"> * 4. 通过new创建的每个对象将最终被[[Prototype]]链接到这个函数的prototype对象上。</span><span class="hljs-comment"> * 5. 如果函数没有返回对象类型Object(包含Functoin, Array, Date, RegExg, Error)，那么new表达式中的函数调用会自动返回这个新的对象。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_new</span>(<span class="hljs-params">fn, ...arg</span>) </span>&#123;  <span class="hljs-keyword">const</span> obj = <span class="hljs-built_in">Object</span>.create(fn.prototype)  <span class="hljs-keyword">const</span> ret = fn.apply(obj, arg)  <span class="hljs-keyword">return</span> ret <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span> ? ret : obj&#125;</code></pre><h1 id="15、简单讲解一下http2的多路复用"><a href="#15、简单讲解一下http2的多路复用" class="headerlink" title="15、简单讲解一下http2的多路复用"></a>15、简单讲解一下http2的多路复用</h1><p>HTTP2.0 的出现，相比较于 HTTP1.x，大幅度提升了 Web 的性能。在与 1.x 版本语义上完全兼容的基础上大幅度减少了网络延迟，减少了前端在 Web 优化的工作量。</p><p>而实现以上优点的原因就是 HTTP2.0 采用了多路复用，即允许同时通过单一的 HTTP2.0 连接发起多重的 <em>请求-响应</em> 消息。就是连接一次可以发送多个请求-响应。</p><p>多路复用代替了 HTTP1.x 的 <em>序列</em> 和 <em>阻塞机制</em>，所有的相同域名请求都通过同一个 TCP 连接并发完成。在HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6 到 8 个 TCP 连接都限制。</p><p>HTTP2.0 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。</p><p>在 HTTP2.0 中：</p><ul><li>同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。</li><li>单个连接上可以并行交错的请求和响应，之间互不干扰</li></ul><p>HTTP2.0 中有两个很重要的概念：帧（frame）和流（stream）</p><p>帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流就是由多个帧组成的数据流。</p><p>多路复用，也就是在一个 TCP 连接中可以存在多条流，就是我们所说的可以发送多个请求，对端可以通过帧的标示知道，该帧属于哪个流（请求），通过这个技术及意义避免 HTTP 1.x 中的队头阻塞问题，极大的提高传输性能。</p><h1 id="16、谈谈你对TCP三次握手和四次挥手的理解"><a href="#16、谈谈你对TCP三次握手和四次挥手的理解" class="headerlink" title="16、谈谈你对TCP三次握手和四次挥手的理解"></a>16、谈谈你对TCP三次握手和四次挥手的理解</h1><p>三次握手：</p><p>Browser:先告诉服务器 “我要开始发起请求了，你那边可以吗？”<br>Server:服务器回复浏览器 “没问题，你发吧！”<br>Browser:告诉服务器 “好的，那我开始发了。”</p><p>四次挥手：</p><p>Browser:先告诉服务器 “我数据都发完了，你可以关闭连接了。”<br>Server:回复浏览器 “我先看看我这边还有没有数据没传完。”<br>Server:确认过以后，再次回复浏览器 “我这边数据传输完成了，你可以关闭连接了。”<br>Browser:告诉服务器 “好的，那我真的关闭了。你不用回复我了。”</p><p>Browser又等了2MSL，确认确实没有再收到请求了，才会真的关闭TCP连接。</p><hr><p>三次握手：</p><p>从最开始双方都处于<code>CLOSED</code>状态。然后服务端开始监听某个端口，进入了<code>LISTEN</code>状态。</p><p>然后客户端主动发起连接，发送 SYN(同步序列编号) , 自己变成了<code>SYN-SENT</code>状态。</p><p>服务端接收到，返回<code>SYN</code>(对应客户端发来的SYN)和<code>ACK</code>(确认字符)，自己变成了<code>SYN-REVD</code>。</p><p>之后客户端再发送<code>ACK</code>给服务端，自己变成了<code>ESTABLISHED</code>状态；服务端收到<code>ACK</code>之后，也变成了<code>ESTABLISHED</code>状态。</p><p>四次挥手：</p><p>刚开始双方处于<code>ESTABLISHED</code>状态。客户端要断开了，向服务器发送 <code>FIN</code>(结束字段) 报文。发送后客户端变成了<code>FIN-WAIT-1</code>状态。注意, 这时候客户端同时也变成了<code>half-close(半关闭)</code>状态，即无法向服务端发送报文，只能接收</p><p>服务端接收后向客户端确认，变成了<code>CLOSED-WAIT</code>状态。客户端接收到了服务端的确认，变成了<code>FIN-WAIT2</code>状态。</p><p>随后，服务端向客户端发送<code>FIN</code>，自己进入<code>LAST-ACK</code>状态，客户端收到服务端发来的<code>FIN</code>后，自己变成了<code>TIME-WAIT</code>状态然后发送 ACK 给服务端。</p><p>这个时候，客户端需要等待足够长的时间，具体来说，是 2 个 <code>MSL</code>(<code>Maximum Segment Lifetime，报文最大生存时间</code>), 在这段时间内如果客户端没有收到服务端的重发请求，那么表示 ACK 成功到达，挥手结束，否则客户端重发 ACK。</p><p>补充：</p><p>TCP 三次握手的过程为什么是三次而不是两次、四次？</p><p>为什么不是两次？根本原因: 无法确认客户端的接收能力。</p><blockquote><p>如果是两次，你现在发了 SYN 报文想握手，但是这个包<strong>滞留</strong>在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。看似没有问题，但是连接关闭后，如果这个<strong>滞留</strong>在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认<strong>建立连接</strong>，但是现在客户端已经断开了。这就带来了连接资源的浪费。</p></blockquote><p>为什么不是四次？三次就足够了，再多用处就不大了。</p><p>为什么是四次挥手而不是三次？因为服务端在接收到<code>FIN</code>, 往往不会立即返回<code>FIN</code>, 必须等到服务端所有的报文都发送完毕了，才能发<code>FIN</code>。因此先发一个<code>ACK</code>表示已经收到客户端的<code>FIN</code>，延迟一段时间才发<code>FIN</code>。这就造成了四次挥手。</p><p>如果是三次挥手会有什么问题？等于说服务端将<code>ACK</code>和<code>FIN</code>的发送合并为一次挥手，这个时候长时间的延迟可能会导致客户端误以为<code>FIN</code>没有到达客户端，从而让客户端不断的重发<code>FIN</code>。</p><h1 id="17、A、B-机器正常连接后，B-机器突然重启，问-A-此时处于-TCP-什么状态"><a href="#17、A、B-机器正常连接后，B-机器突然重启，问-A-此时处于-TCP-什么状态" class="headerlink" title="17、A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态"></a>17、A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态</h1><blockquote><p>如果A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）</p></blockquote><p>A侧在超时退出之后一般会发送一个RST 包用于告知对端重置链路，并给应用层一个异常的状态信息，视乎同步IO与异步IO的差异，这个异常获知的时机会有所不同。</p><p>B侧重启之后，因为不存有之前A-B之间建立链路相关的信息，这时候收到任何A侧来的数据都会以RST作为响应，以告知A侧链路发生异常</p><h1 id="18、React-中-setState-什么时候是同步的，什么时候是异步的？"><a href="#18、React-中-setState-什么时候是同步的，什么时候是异步的？" class="headerlink" title="18、React 中 setState 什么时候是同步的，什么时候是异步的？"></a>18、React 中 setState 什么时候是同步的，什么时候是异步的？</h1><h1 id="19、React-setState-笔试题，下面的代码输出什么？"><a href="#19、React-setState-笔试题，下面的代码输出什么？" class="headerlink" title="19、React setState 笔试题，下面的代码输出什么？"></a>19、React setState 笔试题，下面的代码输出什么？</h1><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Example</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-built_in">super</span>();    <span class="hljs-built_in">this</span>.state = &#123;      val: <span class="hljs-number">0</span>    &#125;;  &#125;    componentDidMount() &#123;    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">val</span>: <span class="hljs-built_in">this</span>.state.val + <span class="hljs-number">1</span>&#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.val);    <span class="hljs-comment">// 第 1 次 log</span>    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">val</span>: <span class="hljs-built_in">this</span>.state.val + <span class="hljs-number">1</span>&#125;);    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.val);    <span class="hljs-comment">// 第 2 次 log</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">val</span>: <span class="hljs-built_in">this</span>.state.val + <span class="hljs-number">1</span>&#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.val);  <span class="hljs-comment">// 第 3 次 log</span>      <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">val</span>: <span class="hljs-built_in">this</span>.state.val + <span class="hljs-number">1</span>&#125;);      <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.state.val);  <span class="hljs-comment">// 第 4 次 log</span>    &#125;, <span class="hljs-number">0</span>);  &#125;  render() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  &#125;&#125;;</code></pre><h1 id="20、介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？"><a href="#20、介绍下-npm-模块安装机制，为什么输入-npm-install-就可以自动安装对应的模块？" class="headerlink" title="20、介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？"></a>20、介绍下 npm 模块安装机制，为什么输入 npm install 就可以自动安装对应的模块？</h1><ul><li>发出<code>npm install</code>命令</li><li>查询node_modules目录之中是否已经存在指定模块<ul><li>若存在，不再重新安装</li><li>若不存在<ul><li>npm 向 registry 查询模块压缩包的网址</li><li>下载压缩包，存放在根目录下的<code>.npm</code>目录里</li><li>解压压缩包到当前项目的<code>node_modules</code>目录</li></ul></li></ul></li></ul><h2 id="npm-实现原理"><a href="#npm-实现原理" class="headerlink" title="npm 实现原理"></a>npm 实现原理</h2><ol><li><p>执行工程自身 preinstall</p><blockquote><p>当前 npm 工程如果定义了 preinstall 钩子此时会被执行。</p></blockquote></li><li><p>确定首层依赖模块</p><blockquote><p>首先需要做的是确定工程中的首层依赖，也就是 dependencies 和 devDependencies 属性中直接指定的模块（假设此时没有添加 npm install 参数）。</p></blockquote><blockquote><p>工程本身是整棵依赖树的根节点，每个首层依赖模块都是根节点下面的一棵子树，npm 会开启多进程从每个首层依赖模块开始逐步寻找更深层级的节点。</p></blockquote></li><li><p>获取模块</p></li></ol><p>获取模块是一个递归的过程</p><ul><li>获取模块信息。在下载一个模块之前，首先要确定其版本，这是因为 package.json 中往往是 semantic version（semver，语义化版本）。此时如果版本描述文件（npm-shrinkwrap.json 或 package-lock.json）中有该模块信息直接拿即可，如果没有则从仓库获取。如 packaeg.json 中某个包的版本是 ^1.1.0，npm 就会去仓库中获取符合 1.x.x 形式的最新版本。</li><li>获取模块实体。上一步会获取到模块的压缩包地址（resolved 字段），npm 会用此地址检查本地缓存，缓存中有就直接拿，如果没有则从仓库下载。</li><li>查找该模块依赖，如果有依赖则回到第1步，如果没有则停止。</li></ul><ol start="4"><li>模块扁平化（dedup）</li></ol><p>上一步获取到的是一棵完整的依赖树，其中可能包含大量重复模块。比如 A 模块依赖于 loadsh，B 模块同样依赖于 lodash。在 npm3 以前会严格按照依赖树的结构进行安装，因此会造成模块冗余。</p><p>从 npm3 开始默认加入了一个 dedupe 的过程。它会遍历所有节点，逐个将模块放在根节点下面，也就是 node-modules 的第一层。当发现有<strong>重复模块</strong>时，则将其丢弃。</p><p>这里需要对<strong>重复模块</strong>进行一个定义，它指的是模块名相同且 semver 兼容。每个 semver 都对应一段版本允许范围，如果两个模块的版本允许范围存在交集，那么就可以得到一个兼容版本，而不必版本号完全一致，这可以使更多冗余模块在 dedupe 过程中被去掉。</p><ol start="5"><li><p>安装模块</p></li><li><p>执行工程自身生命周期</p></li></ol><blockquote><p>当前 npm 工程如果定义了钩子此时会被执行（按照 install、postinstall、prepublish、prepare 的顺序）。</p></blockquote><p>最后一步是生成或更新版本描述文件，npm install 过程完成。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《前端100问》10</title>
    <link href="/2020/11/06/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B10/"/>
    <url>/2020/11/06/%E3%80%8A%E5%89%8D%E7%AB%AF100%E9%97%AE%E3%80%8B10/</url>
    
    <content type="html"><![CDATA[<h1 id="1、写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？"><a href="#1、写-React-Vue-项目时为什么要在列表组件中写-key，其作用是什么？" class="headerlink" title="1、写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？"></a>1、写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？</h1><p><code>key</code> 是给每一个 <strong>VNode</strong> 的唯一 <code>id</code>，可以依靠 <code>key</code>，在 <strong>diff算法</strong> 执行时更快的找到对应的节点。</p><p>更准确、更快的拿到 <strong>OldVNode</strong> 中对应的 <strong>VNode</strong> 节点。</p><p>在数据变化时强制更新组件，以避免 ”原地复用“ 带来的副作用，使用 <code>key</code> 时，它会基于 <code>key</code> 的变化重新排列元素顺序，并且会移除 <code>key</code>不存在的元素。</p><h1 id="2、-‘1’-‘2’-‘3’-map-parseInt-what-amp-why"><a href="#2、-‘1’-‘2’-‘3’-map-parseInt-what-amp-why" class="headerlink" title="2、[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?"></a>2、[‘1’, ‘2’, ‘3’].map(parseInt) what &amp; why ?</h1><p><strong>parseInt</strong></p><p><code>parseInt()</code> 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> intValue = <span class="hljs-built_in">parseInt</span>(string[, radix]);</code></pre><p><code>string</code> 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。</p><p><code>radix</code> 一个介于2和36之间的整数(数学系统的基础)，表示上述字符串的基数。默认为10。<br><code>返回值</code> 返回一个整数或NaN</p><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">100</span>); <span class="hljs-comment">// 100</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">100</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">// 100</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">100</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 4 -&gt; converts 100 in base 2 to base 10</span></code></pre><p><strong>注意：</strong><br>在<code>radix</code>为 undefined，或者<code>radix</code>为 0 或者没有指定的情况下，JavaScript 作如下处理：</p><ul><li>如果字符串 string 以”0x”或者”0X”开头, 则基数是16 (16进制).</li><li>如果字符串 string 以”0”开头, 基数是8（八进制）或者10（十进制），那么具体是哪个基数由实现环境决定。ECMAScript 5 规定使用10，但是并不是所有的浏览器都遵循这个规定。因此，永远都要明确给出radix参数的值。</li><li>如果字符串 string 以其它任何值开头，则基数是10 (十进制)。</li></ul><p><strong>map</strong></p><p><code>map()</code> 方法创建一个新数组，其结果是该数组中的每个元素都调用一个提供的函数后返回的结果。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> new_array = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[,index[, array]]</span>) </span>&#123; <span class="hljs-comment">// Return element for new_array</span> &#125;[, thisArg])</code></pre><p>可以看到<code>callback</code>回调函数需要三个参数, 我们通常只使用第一个参数 (其他两个参数是可选的)。</p><ul><li><code>currentValue</code> 是callback 数组中正在处理的当前元素。</li><li><code>index</code>可选, 是callback 数组中正在处理的当前元素的索引。</li><li><code>array</code>可选, 是callback map 方法被调用的数组。</li><li>另外还有<code>thisArg</code>可选, 执行 callback 函数时使用的this 值。</li></ul><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];arr.map(<span class="hljs-function">(<span class="hljs-params">num</span>) =&gt;</span> num + <span class="hljs-number">1</span>); <span class="hljs-comment">// [2, 3, 4]</span></code></pre><p>所以对于题目：</p><pre><code class="hljs js">[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-built_in">parseInt</span>)</code></pre><p>对于每个迭代<code>map</code>, <code>parseInt()</code>传递两个参数: <strong>字符串和基数</strong>。</p><p>所以实际执行的的代码是：</p><pre><code class="hljs js">[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">parseInt</span>(item, index)&#125;)</code></pre><p>所以结果为：</p><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// 1</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// NaN</span><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// NaN, 3 不是二进制</span>[<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>].map(<span class="hljs-built_in">parseInt</span>)<span class="hljs-comment">// 1, NaN, NaN</span></code></pre><h1 id="3、什么是防抖和节流？有什么区别？如何实现？"><a href="#3、什么是防抖和节流？有什么区别？如何实现？" class="headerlink" title="3、什么是防抖和节流？有什么区别？如何实现？"></a>3、什么是防抖和节流？有什么区别？如何实现？</h1><p><strong>防抖</strong> （debounce）：防抖，顾名思义，防止抖动，以免把一次事件误认为多次，敲键盘就是一个每天都会接触到的防抖操作。</p><p>防抖适用场景：</p><ol><li>登录、发短信等按钮避免用户点击太快，以致于发送了多次请求，需要防抖</li><li>调整浏览器窗口大小时，resize 次数过于频繁，造成计算过多，此时需要一次到位，就用到了防抖</li><li>文本编辑器实时保存，当无任何更改操作一秒后进行保存</li></ol><p>可以看出来<strong>防抖重在清零 <code>clearTimeout(timer)</code></strong></p><p><strong>节流</strong>（throttle）：节流，顾名思义，控制水的流量。控制事件发生的频率，如控制为1s发生一次，甚至1分钟发生一次。与服务端(server) 及网关(gateway) 控制的限流(Rate Limit) 类似。</p><p>节流适用场景：</p><ol><li><code>scroll</code> 事件，每隔一秒计算一次位置信息等</li><li>浏览器播放事件，每个一秒计算一次进度信息等</li><li>input 框实时搜索并发送请求展示下拉列表，每隔一秒发送一次请求 (也可做防抖)</li></ol><p>可以看出来<strong>节流重在加锁 <code>timer=timeout</code></strong></p><p>代码实现：</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> <span class="hljs-variable">fn</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-variable">wait</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span></span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer;    <span class="hljs-comment">// 箭头函数始终指向上一层 this</span>    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 使用闭包 timer持久化</span>        <span class="hljs-built_in">clearTimeout</span>(timer);        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            fn(...args);        &#125;, wait);    &#125;;&#125;</code></pre><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Function&#125;</span> <span class="hljs-variable">fn</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> <span class="hljs-variable">wait</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Function&#125;</span> </span></span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;    <span class="hljs-keyword">let</span> timer;    <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> &#123;        <span class="hljs-keyword">if</span> (timer) <span class="hljs-keyword">return</span>;        timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;            fn(...args);            timer = <span class="hljs-literal">null</span>;        &#125;,wait);    &#125;;&#125;</code></pre><h1 id="4、介绍下-Set、Map、WeakSet-和-WeakMap-的区别？"><a href="#4、介绍下-Set、Map、WeakSet-和-WeakMap-的区别？" class="headerlink" title="4、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？"></a>4、介绍下 Set、Map、WeakSet 和 WeakMap 的区别？</h1><p>Set 和 Map 主要的应用场景在于 <strong>数据重组</strong> 和 <strong>数据储存</strong></p><p>Set 是一种叫做<strong>集合</strong>的数据结构，Map 是一种叫做<strong>字典</strong>的数据结构</p><p><strong>集合（Set）</strong></p><p>ES6 新增的一种新的数据结构，类似于数组，但成员是唯一且无序的，没有重复的值。</p><p><strong>Set 本身是一种构造函数，用来生成 Set 数据结构。</strong></p><p>Set 对象允许你储存任何类型的唯一值，无论是原始值或者是对象引用。</p><p><strong>WeakSet</strong></p><p>WeakSet 对象允许你将<strong>弱引用对象</strong>储存在一个集合中</p><p>WeakSet 与 Set 的区别：</p><ul><li>WeakSet 只能储存对象引用，不能存放值，而 Set 对象都可以</li><li>WeakSet 对象中储存的对象值都是被弱引用的，即垃圾回收机制不考虑 WeakSet 对该对象的应用，如果没有其他的变量或属性引用这个对象值，则这个对象将会被垃圾回收掉（不考虑该对象还存在于 WeakSet 中），所以，WeakSet 对象里有多少个成员元素，取决于垃圾回收机制有没有运行，运行前后成员个数可能不一致，遍历结束之后，有的成员可能取不到了（被垃圾回收了），WeakSet 对象是无法被遍历的（ES6 规定 WeakSet 不可遍历），也没有办法拿到它包含的所有元素</li></ul><p><strong>字典（Map）</strong></p><p>集合 与 字典 的区别：</p><ul><li>共同点：集合、字典 可以储存不重复的值</li><li>不同点：集合 是以 [value, value] 的形式储存元素，字典 是以 [ key, value ] 的形式储存</li></ul><p><strong>WeakMap</strong></p><p>WeakMap 对象是一组键值对的集合，其中的<strong>键是弱引用对象，而值可以是任意</strong>。</p><p><strong>注意，WeakMap 弱引用的只是键名，而不是键值。键值依然是正常引用。</strong></p><p>WeakMap 中，每个键对自己所引用对象的引用都是弱引用，在没有其他引用和该键引用同一对象，这个对象将会被垃圾回收（相应的 key 则变成无效的），所以，WeakMap 的 key 是不可枚举的。</p><h1 id="5、介绍下深度优先遍历和广度优先遍历，如何实现？"><a href="#5、介绍下深度优先遍历和广度优先遍历，如何实现？" class="headerlink" title="5、介绍下深度优先遍历和广度优先遍历，如何实现？"></a>5、介绍下深度优先遍历和广度优先遍历，如何实现？</h1><p>深度优先遍历：从根节点出发，沿着左子树方向进行纵向遍历，直到找到叶子节点为止。然后回溯到前一个节点，进行右子树节点的遍历，直到遍历完所有可达节点为止。</p><p>广度优先遍历：从根节点出发，在横向遍历二叉树层段节点的基础上纵向遍历二叉树的层次。</p><p>以遍历 Dom 树为例子：</p><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one&quot;</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-one&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-one-one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-one-two&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-one-three&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-two&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-two-one&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-two-two&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;one-three&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;onr-four&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre><p>深度优先遍历：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> depthFirstSearch = <span class="hljs-function">(<span class="hljs-params">node, nodeList = []</span>) =&gt;</span> &#123;    <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;      nodeList.push(node)      <span class="hljs-comment">//ParentNode.children 返回子节点集合（动态）</span>      <span class="hljs-keyword">let</span> children = node.children      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; children.length; index++) &#123;        depthFirstSearch(children[index], nodeList)      &#125;    &#125;    <span class="hljs-keyword">return</span> nodeList  &#125;<span class="hljs-comment">//test</span><span class="hljs-keyword">const</span> node = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.one&#x27;</span>)<span class="hljs-built_in">console</span>.dir(depthFirstSearch(node))</code></pre><pre><code class="hljs js"><span class="hljs-comment">//结果：</span><span class="hljs-number">0</span>: div.one<span class="hljs-number">1</span>: div.one-one<span class="hljs-number">2</span>: div.one-one-one<span class="hljs-number">3</span>: div.one-one-two<span class="hljs-number">4</span>: div.one-one-three<span class="hljs-number">5</span>: div.one-two<span class="hljs-number">6</span>: div.one-two-one<span class="hljs-number">7</span>: div.one-two-two<span class="hljs-number">8</span>: div.one-three<span class="hljs-number">9</span>: div.onr-four</code></pre><p>广度遍历优先：</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> breadthFirstSearch = <span class="hljs-function"><span class="hljs-params">node</span> =&gt;</span> &#123;  <span class="hljs-keyword">let</span> nodes = []  <span class="hljs-keyword">let</span> stack = []  <span class="hljs-keyword">if</span> (node !== <span class="hljs-literal">null</span>) &#123;    stack.push(node)    <span class="hljs-keyword">while</span> (stack.length) &#123;      <span class="hljs-keyword">let</span> item = stack.shift()      <span class="hljs-keyword">let</span> children = item.children      nodes.push(item)      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; children.length; index++) &#123;        stack.push(children[index])      &#125;    &#125;  &#125;  <span class="hljs-keyword">return</span> nodes&#125;<span class="hljs-comment">//test</span><span class="hljs-keyword">const</span> node = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;.one&#x27;</span>)<span class="hljs-built_in">console</span>.dir(breadthFirstSearch(node))</code></pre><pre><code class="hljs js"><span class="hljs-comment">//结果：</span><span class="hljs-number">0</span>: div.one<span class="hljs-number">1</span>: div.one-one<span class="hljs-number">2</span>: div.one-two<span class="hljs-number">3</span>: div.one-three<span class="hljs-number">4</span>: div.onr-four<span class="hljs-number">5</span>: div.one-one-one<span class="hljs-number">6</span>: div.one-one-two<span class="hljs-number">7</span>: div.one-one-three<span class="hljs-number">8</span>: div.one-two-one<span class="hljs-number">9</span>: div.one-two-two</code></pre><h1 id="6、请分别用深度优先思想和广度优先思想实现一个拷贝函数？-算法-❌"><a href="#6、请分别用深度优先思想和广度优先思想实现一个拷贝函数？-算法-❌" class="headerlink" title="6、请分别用深度优先思想和广度优先思想实现一个拷贝函数？[算法]❌"></a>6、请分别用深度优先思想和广度优先思想实现一个拷贝函数？[算法]❌</h1><h1 id="7、ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#7、ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="7、ES5/ES6 的继承除了写法以外还有什么区别？"></a>7、ES5/ES6 的继承除了写法以外还有什么区别？</h1><ol><li><code>class</code> 声明会提升，但不会初始化赋值。<code>Foo</code> 进入暂时性死区，类似于 <code>let</code>、<code>const</code> 声明变量。</li><li><code>class</code> 声明内部会启用严格模式。</li><li><code>class</code> 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li><li><code>class</code> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 <code>new</code> 来调用。</li><li>必须使用 <code>new</code> 调用 <code>class</code>。</li><li><code>class</code> 内部无法重写类名</li></ol><h1 id="8、setTimeout、Promise、Async-Await-的区别"><a href="#8、setTimeout、Promise、Async-Await-的区别" class="headerlink" title="8、setTimeout、Promise、Async/Await 的区别"></a>8、setTimeout、Promise、Async/Await 的区别</h1><p>setTimeout 是宿主环境（浏览器、Node）所发起的异步任务，相同的还有事件和 ajax</p><p>而 Promise 和 Async/Await 分别是 ES6、ES7，JavaScript 语言本身所实现的异步任务。</p><p>它们在 JavaScript 引擎中别分为由宿主发起的异步宏任务，和 JavaScript 语言自身发起的异步微任务。</p><p>当异步任务的回调函数注册完毕，分别进入宏任务队列和微任务队列，在执行顺序上优先执行微任务队列，执行完微任务队列再去读取宏任务队列，每执行完一个异步宏任务，都先读取一遍微任务队列，有就执行，没有就就继续执行宏任务队列</p><h1 id="9、Async-Await-如何通过同步的方式实现异步"><a href="#9、Async-Await-如何通过同步的方式实现异步" class="headerlink" title="9、Async/Await 如何通过同步的方式实现异步"></a>9、Async/Await 如何通过同步的方式实现异步</h1><p>Async/Await 就是一个<strong>自执行</strong>的 <em>generator</em>  函数。利用 <em>generator</em>  函数的特性把异步的代码写成“同步”的形式。</p><p><strong>生成器函数</strong>在执行时能暂停，后面又能从暂停处继续执行。</p><p>调用一个<strong>生成器函数</strong>并不会马上执行它里面的语句，而是返回一个这个生成器的 <strong>迭代器</strong> <strong>（ iterator）对象</strong>。当这个迭代器的 <code>next() </code>方法被首次（后续）调用时，其内的语句会执行到第一个（后续）出现<code>yield</code>的位置为止，<code>yield</code>后紧跟迭代器要返回的值。或者如果用的是 <code>yield*</code>)（多了个星号），则表示将执行权移交给另一个生成器函数（当前生成器暂停执行）。</p><h1 id="10、异步笔试题"><a href="#10、异步笔试题" class="headerlink" title="10、异步笔试题"></a>10、异步笔试题</h1><blockquote><p>请写出下面代码的运行结果</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async1</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 start&#x27;</span>);    <span class="hljs-keyword">await</span> async2();    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async1 end&#x27;</span>);&#125;<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">async2</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;async2&#x27;</span>);&#125;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script start&#x27;</span>);<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setTimeout&#x27;</span>);&#125;, <span class="hljs-number">0</span>)<span class="hljs-comment">//1</span>async1();<span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise1&#x27;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;promise2&#x27;</span>);&#125;);<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;script end&#x27;</span>);</code></pre><p>await 做了什么？</p><p>await 等待的是一个表达式，这个表达式的返回值可以是一个promise对象也可以是其他值。</p><p>很多人以为 await 会一直等待之后的表达式执行完之后才会继续执行后面的代码，<strong>实际上await是一个让出线程的标志。await 后面的表达式会先执行一遍，将 await 后面的代码加入到 microtask 中，然后就会跳出整个async函数来执行后面的代码。</strong></p><p>结果：</p><pre><code class="hljs routeros">script startasync1 startasync2promise1script endasync1 endpromise2setTimeout</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript6 精粹</title>
    <link href="/2020/11/02/ECMAScript6/"/>
    <url>/2020/11/02/ECMAScript6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>整理一些在学习、工作中用到的 ES6</p></blockquote><h1 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1. let 和 const"></a>1. let 和 const</h1><p>let 的作用域与 const 相同：只在声明所在的「块」级作用域内有效。且不存在变量提升 。</p><p>对于 数值、字符串、布尔值 经常会变的，用 let 声明。</p><p>对象、数组和函数用 const 来声明</p><h2 id="1-1-let"><a href="#1-1-let" class="headerlink" title="1.1 let"></a>1.1 let</h2><p>let 声明的变量，可以改变</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">4396</span>a = <span class="hljs-number">5678</span><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;playlife&#x27;</span>b = <span class="hljs-string">&#x27;Johnny&#x27;</span></code></pre><h2 id="1-2-const"><a href="#1-2-const" class="headerlink" title="1.2 const"></a>1.2 const</h2><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p>简单类型的数据（数值、字符串、布尔值），不可以变动</p><p>复合类型的数据（主要是对象和数组），可以这样子变动</p><pre><code class="hljs stylus">const <span class="hljs-selector-tag">a</span> = [<span class="hljs-number">4396</span>]<span class="hljs-selector-tag">a</span>.push(<span class="hljs-number">2233</span>)const <span class="hljs-selector-tag">b</span> = &#123;&#125;<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.name</span> = <span class="hljs-string">&#x27;playlife&#x27;</span></code></pre><h2 id="1-3-不存在变量提升"><a href="#1-3-不存在变量提升" class="headerlink" title="1.3 不存在变量提升"></a>1.3 不存在变量提升</h2><p>let 和 const 的暂时性死区：let 和 const 不存在变量提升是因为 let/const 命令会使区块形成封闭的作用域，</p><p>用 let/const 声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。</p><p>因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。</p><h1 id="2-解构-Destructuring"><a href="#2-解构-Destructuring" class="headerlink" title="2. 解构 (Destructuring)"></a>2. 解构 (Destructuring)</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 （Destructuring）。</p><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><p>一次性声明多个变量：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ];</code></pre><p>结合扩展运算符：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> [head, ...tail] = [ <span class="hljs-number">4</span> , <span class="hljs-number">3</span> , <span class="hljs-number">2</span> ,<span class="hljs-number">5</span> ]<span class="hljs-built_in">console</span>.log(head) <span class="hljs-comment">// 4</span><span class="hljs-built_in">console</span>.log(tail) <span class="hljs-comment">// [3, 2, 5]</span></code></pre><p>解构赋值允许指定默认值:</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo = <span class="hljs-literal">true</span>] = [];foo <span class="hljs-comment">// true</span><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></code></pre><blockquote><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p></blockquote><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><h2 id="2-2-对象-（常用）"><a href="#2-2-对象-（常用）" class="headerlink" title="2.2 对象 （常用）"></a>2.2 对象 （常用）</h2><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;foo <span class="hljs-comment">// &quot;aaa&quot;</span>bar <span class="hljs-comment">// &quot;bbb&quot;</span></code></pre><p>数组的结构赋值取决于变量的排列位置，在对象中，结构赋值变量必须于对象的属性同名才能正确的赋值。（对象的解构赋值在开发中常用，它帮助我们代码更加简洁，更加优雅）</p><p>如果解构失败，变量的值等于<code>undefined</code>。</p><p>对象的解构也可以指定默认值。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> &#123;x = <span class="hljs-number">3</span>&#125; = &#123;&#125;;x <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;x <span class="hljs-comment">// 1</span>y <span class="hljs-comment">// 5</span><span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">x</span>: y = <span class="hljs-number">3</span>&#125; = &#123;&#125;;y <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">x</span>: y = <span class="hljs-number">3</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">5</span>&#125;;y <span class="hljs-comment">// 5</span><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">message</span>: msg = <span class="hljs-string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;msg <span class="hljs-comment">// &quot;Something went wrong&quot;</span></code></pre><h2 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;a <span class="hljs-comment">// &quot;h&quot;</span>b <span class="hljs-comment">// &quot;e&quot;</span>c <span class="hljs-comment">// &quot;l&quot;</span>d <span class="hljs-comment">// &quot;l&quot;</span>e <span class="hljs-comment">// &quot;o&quot;</span></code></pre><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span> : len&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;len <span class="hljs-comment">// 5</span></code></pre><h2 id="2-4-解构赋值用途"><a href="#2-4-解构赋值用途" class="headerlink" title="2.4 解构赋值用途"></a>2.4 解构赋值用途</h2><h3 id="2-4-1-交换变量的值"><a href="#2-4-1-交换变量的值" class="headerlink" title="2.4.1 交换变量的值"></a>2.4.1 交换变量的值</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span>[ x , y ] = [ y , x ]</code></pre><h3 id="2-4-2-接受函数返回的值"><a href="#2-4-2-接受函数返回的值" class="headerlink" title="2.4.2 接受函数返回的值"></a>2.4.2 接受函数返回的值</h3><blockquote><p>常用于 ajax请求返回数据的获取</p></blockquote><p>简单例子：</p><pre><code class="hljs js">cont &#123;status , data&#125; = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;localhost:33301&#x27;</span>)</code></pre><h3 id="2-4-3-导入模块指定的方法"><a href="#2-4-3-导入模块指定的方法" class="headerlink" title="2.4.3 导入模块指定的方法"></a>2.4.3 导入模块指定的方法</h3><p>举例子：vuex中的方法</p><pre><code class="hljs js"><span class="hljs-comment">//导入 vuex 的 mapGetters 方法</span><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></code></pre><h1 id="3-模版字符串"><a href="#3-模版字符串" class="headerlink" title="3. 模版字符串"></a>3. 模版字符串</h1><blockquote><p>可以在字符串中嵌入变量，可以换行，可以调用方法，比普通的拼接字符串更加高效优雅</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`输出值为：<span class="hljs-subst">$&#123;x&#125;</span>`</span>) <span class="hljs-comment">// &quot;输出值为：1&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`输出值为：<span class="hljs-subst">$&#123;x + y&#125;</span>`</span>) <span class="hljs-comment">// &quot;输出值为：3&quot;</span></code></pre><p>常用于模版引擎</p><h1 id="4-字符串的新增方法"><a href="#4-字符串的新增方法" class="headerlink" title="4. 字符串的新增方法"></a>4. 字符串的新增方法</h1><blockquote><p>仅列举常用的新增方法，更多的请查看《ES6标准入门》阮一峰老师的书学习</p></blockquote><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;s.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span>s.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// true</span></code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;s.startsWith(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// true</span>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span>s.includes(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// false</span></code></pre><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><p>扩展眼界列举出其他新增方法但是不详细展开，有需要再去查阅资料💾</p><ol><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#String.fromCodePoint()">String.fromCodePoint()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#String.raw()">String.raw()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AcodePointAt()">实例方法：codePointAt()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Anormalize()">实例方法：normalize()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Aincludes(">实例方法：includes(), startsWith(), endsWith()</a>, startsWith(), endsWith())</li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Arepeat()">实例方法：repeat()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9ApadStart()%EF%BC%8CpadEnd()">实例方法：padStart()，padEnd()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AtrimStart()%EF%BC%8CtrimEnd()">实例方法：trimStart()，trimEnd()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AmatchAll()">实例方法：matchAll()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AreplaceAll()">实例方法：replaceAll()</a></li></ol><h1 id="5-函数的扩展"><a href="#5-函数的扩展" class="headerlink" title="5. 函数的扩展"></a>5. 函数的扩展</h1><h2 id="5-1-函数参数的默认值"><a href="#5-1-函数参数的默认值" class="headerlink" title="5.1 函数参数的默认值"></a>5.1 函数参数的默认值</h2><p>可以为函数参数声明一个默认值</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span></span>) </span>&#123;  <span class="hljs-built_in">this</span>.x = x;  <span class="hljs-built_in">this</span>.y = y;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Point();p <span class="hljs-comment">// &#123; x: 0, y: 0 &#125;</span></code></pre><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x = <span class="hljs-number">5</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// error</span>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>; <span class="hljs-comment">// error</span>&#125;</code></pre><p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p><p>使用参数默认值时，函数不能有同名参数。</p><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><pre><code class="hljs js">参数默认值可以与解构赋值的默认值，结合起来使用。<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">&#123;x, y = <span class="hljs-number">5</span>&#125;</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(x, y);&#125;foo(&#123;&#125;) <span class="hljs-comment">// undefined 5</span>foo(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// 1 5</span>foo(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;) <span class="hljs-comment">// 1 2</span>foo() <span class="hljs-comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></code></pre><h2 id="5-2-rest-参数"><a href="#5-2-rest-参数" class="headerlink" title="5.2 rest 参数"></a>5.2 rest 参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...values</span>) </span>&#123;  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> values) &#123;    sum += val;  &#125;  <span class="hljs-keyword">return</span> sum;&#125;add(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 10</span></code></pre><p>上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, ...b, c</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>函数的<code>length</code>属性，不包括 rest 参数。</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;&#125;).length  <span class="hljs-comment">// 1</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...a</span>) </span>&#123;&#125;).length  <span class="hljs-comment">// 0</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, ...b</span>) </span>&#123;&#125;).length  <span class="hljs-comment">// 1</span></code></pre><h2 id="5-3-箭头函数"><a href="#5-3-箭头函数" class="headerlink" title="5.3 箭头函数"></a>5.3 箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;  <span class="hljs-keyword">return</span> v;&#125;;</code></pre><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><span class="hljs-keyword">let</span> getTempItem = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123; <span class="hljs-attr">id</span>: id, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Temp&quot;</span> &#125;;<span class="hljs-comment">// 不报错</span><span class="hljs-keyword">let</span> getTempItem = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> (&#123; <span class="hljs-attr">id</span>: id, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Temp&quot;</span> &#125;);</code></pre><p>下面是 rest 参数与箭头函数结合的例子。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = <span class="hljs-function">(<span class="hljs-params">...nums</span>) =&gt;</span> nums;numbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">// [1,2,3,4,5]</span><span class="hljs-keyword">const</span> headAndTail = <span class="hljs-function">(<span class="hljs-params">head, ...tail</span>) =&gt;</span> [head, tail];headAndTail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">// [1,[2,3,4,5]]</span></code></pre><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p><h3 id="5-3-1-箭头函数不适用场景"><a href="#5-3-1-箭头函数不适用场景" class="headerlink" title="5.3.1 箭头函数不适用场景"></a>5.3.1 箭头函数不适用场景</h3><p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p><p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cat = &#123;  lives: <span class="hljs-number">9</span>,  jumps: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.lives--;  &#125;&#125;</code></pre><p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;press&#x27;</span>);button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">this</span>.classList.toggle(<span class="hljs-string">&#x27;on&#x27;</span>);&#125;);</code></pre><h1 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6. 数组的扩展"></a>6. 数组的扩展</h1><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><h2 id="6-1-数组合并的新写法"><a href="#6-1-数组合并的新写法" class="headerlink" title="6.1 数组合并的新写法"></a>6.1 数组合并的新写法</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;c&#x27;</span>];<span class="hljs-keyword">const</span> arr3 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<span class="hljs-comment">// ES5 的合并数组</span>arr1.concat(arr2, arr3);<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span><span class="hljs-comment">// ES6 的合并数组</span>[...arr1, ...arr2, ...arr3]<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></code></pre><h2 id="6-2-函数调用"><a href="#6-2-函数调用" class="headerlink" title="6.2 函数调用"></a>6.2 函数调用</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>];add(...numbers) <span class="hljs-comment">// 8</span></code></pre><p>上面代码中函数的调用，它使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">v, w, x, y, z</span>) </span>&#123; &#125;<span class="hljs-keyword">const</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];f(<span class="hljs-number">-1</span>, ...args, <span class="hljs-number">2</span>, ...[<span class="hljs-number">3</span>]);</code></pre><h2 id="6-3-复制数组的简便写法"><a href="#6-3-复制数组的简便写法" class="headerlink" title="6.3 复制数组的简便写法"></a>6.3 复制数组的简便写法</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<span class="hljs-comment">// 写法一</span><span class="hljs-keyword">const</span> a2 = [...a1];a2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;a1 <span class="hljs-comment">// [1, 2]</span><span class="hljs-comment">// 写法二</span><span class="hljs-keyword">const</span> [...a2] = a1;a2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;a1 <span class="hljs-comment">// [1, 2]</span></code></pre><p>上面的两种写法，a2 都是 a1 的克隆，且不会修改原来的数组。</p><h2 id="6-4-将字符串转为真正的数组"><a href="#6-4-将字符串转为真正的数组" class="headerlink" title="6.4 将字符串转为真正的数组"></a>6.4 将字符串转为真正的数组</h2><pre><code class="hljs js">[...<span class="hljs-string">&#x27;hello&#x27;</span>]<span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></code></pre><h2 id="6-5-数组实例的-entries-，keys-和-values"><a href="#6-5-数组实例的-entries-，keys-和-values" class="headerlink" title="6.5 数组实例的 entries()，keys() 和 values()"></a>6.5 数组实例的 entries()，keys() 和 values()</h2><p>用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].keys()) &#123;  <span class="hljs-built_in">console</span>.log(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].values()) &#123;  <span class="hljs-built_in">console</span>.log(elem);&#125;<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].entries()) &#123;  <span class="hljs-built_in">console</span>.log(index, elem);&#125;<span class="hljs-comment">// 0 &quot;a&quot;</span><span class="hljs-comment">// 1 &quot;b&quot;</span></code></pre><h2 id="6-6-includes-是否包含给定的值"><a href="#6-6-includes-是否包含给定的值" class="headerlink" title="6.6 includes() 是否包含给定的值"></a>6.6 includes() 是否包含给定的值</h2><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。</p><pre><code class="hljs yaml">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.includes(2)</span>     <span class="hljs-string">//</span> <span class="hljs-literal">true</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.includes(4)</span>     <span class="hljs-string">//</span> <span class="hljs-literal">false</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">NaN</span>]<span class="hljs-string">.includes(NaN)</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span></code></pre><p>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4，但数组长度为 3 ），则会重置为从 0 开始。</p><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// false</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// true</span></code></pre><h2 id="6-7-Array-from-转为真正的数组"><a href="#6-7-Array-from-转为真正的数组" class="headerlink" title="6.7 Array.from() 转为真正的数组"></a>6.7 Array.from() 转为真正的数组</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123;    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,    <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,    length: <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">// ES5的写法</span><span class="hljs-keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><span class="hljs-comment">// ES6的写法</span><span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre><h1 id="7-对象的扩展"><a href="#7-对象的扩展" class="headerlink" title="7. 对象的扩展"></a>7. 对象的扩展</h1><h2 id="7-1-属性和方法的简洁表示法"><a href="#7-1-属性和方法的简洁表示法" class="headerlink" title="7.1 属性和方法的简洁表示法"></a>7.1 属性和方法的简洁表示法</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> birth = <span class="hljs-string">&#x27;1997/04/05&#x27;</span>;<span class="hljs-keyword">const</span> Person = &#123;  name: <span class="hljs-string">&#x27;playlife&#x27;</span>,  <span class="hljs-comment">//等同于birth: birth</span>  birth,  <span class="hljs-comment">// 等同于hello: function ()...</span>  hello() &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我的名字是&#x27;</span>, <span class="hljs-built_in">this</span>.name); &#125;&#125;;</code></pre><h2 id="7-2-Object-assign"><a href="#7-2-Object-assign" class="headerlink" title="7.2 Object.assign()"></a>7.2 Object.assign()</h2><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-built_in">Object</span>.assign(target, source1, source2);target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span></code></pre><p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p><p><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-built_in">Object</span>.assign(target, source1, source2);target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span></code></pre><p>Object.assign 方法实行的是浅拷贝，而不是深拷贝。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);obj1.a.b = <span class="hljs-number">2</span>;obj2.a.b <span class="hljs-comment">// 2</span></code></pre><p>上面代码中，源对象 obj1 的 a 属性的值是一个对象，Object.assign 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p>补充：</p><p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p><p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><h2 id="7-3-属性遍历"><a href="#7-3-属性遍历" class="headerlink" title="7.3 属性遍历"></a>7.3 属性遍历</h2><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h2 id="7-4-super-关键字"><a href="#7-4-super-关键字" class="headerlink" title="7.4 super 关键字"></a>7.4 super 关键字</h2><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proto = &#123;  foo: <span class="hljs-string">&#x27;hello&#x27;</span>&#125;;<span class="hljs-keyword">const</span> obj = &#123;  foo: <span class="hljs-string">&#x27;world&#x27;</span>,  find() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.foo;  &#125;&#125;;<span class="hljs-built_in">Object</span>.setPrototypeOf(obj, proto);obj.find() <span class="hljs-comment">// &quot;hello&quot;</span></code></pre><p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p><p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p><h1 id="8-Set"><a href="#8-Set" class="headerlink" title="8. Set"></a>8. Set</h1><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.add(x));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;  <span class="hljs-built_in">console</span>.log(i);&#125;<span class="hljs-comment">// 2 3 5 4</span></code></pre><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p><p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><h2 id="8-1-Set-实例的属性和方法"><a href="#8-1-Set-实例的属性和方法" class="headerlink" title="8.1 Set 实例的属性和方法"></a>8.1 Set 实例的属性和方法</h2><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();ws.add(<span class="hljs-number">1</span>)<span class="hljs-comment">// TypeError: Invalid value used in weak set</span>ws.add(<span class="hljs-built_in">Symbol</span>())<span class="hljs-comment">// TypeError: invalid value used in weak set</span></code></pre><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><h1 id="9-Map"><a href="#9-Map" class="headerlink" title="9. Map"></a>9. Map</h1><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;;<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myDiv&#x27;</span>);data[element] = <span class="hljs-string">&#x27;metadata&#x27;</span>;data[<span class="hljs-string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="hljs-comment">// &quot;metadata&quot;</span></code></pre><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = [  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张三&#x27;</span>],  [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Author&#x27;</span>]];<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();items.forEach(  ([key, value]) =&gt; map.set(key, value));</code></pre><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><h2 id="9-1-Map-实例的属性和方法"><a href="#9-1-Map-实例的属性和方法" class="headerlink" title="9.1 Map 实例的属性和方法"></a>9.1 Map 实例的属性和方法</h2><p>Map 结构的实例有以下属性和操作方法。</p><ul><li><strong>size 属性</strong></li></ul><p><code>size</code>属性返回 Map 结构的成员总数。</p><ul><li><strong>Map.prototype.set(key, value)</strong></li></ul><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><ul><li><strong>Map.prototype.get(key)</strong></li></ul><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><ul><li><strong>Map.prototype.has(key)</strong></li></ul><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><ul><li><strong>Map.prototype.delete(key)</strong></li></ul><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><ul><li><strong>Map.prototype.clear()</strong></li></ul><p><code>clear</code>方法清除所有成员，没有返回值。</p><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><h1 id="10-Promise-对象"><a href="#10-Promise-对象" class="headerlink" title="10. Promise 对象"></a>10. Promise 对象</h1><p>Promise 是异步编程的一种解决方案。</p><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> someAsyncThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flag</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-keyword">if</span>(flag)&#123;        resolve(<span class="hljs-string">&#x27;ok&#x27;</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        reject(<span class="hljs-string">&#x27;error&#x27;</span>)    &#125;  &#125;);&#125;;someAsyncThing(<span class="hljs-literal">true</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data:&#x27;</span>,data); <span class="hljs-comment">// 输出 &#x27;ok&#x27;</span>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error:&#x27;</span>, error); <span class="hljs-comment">// 不执行</span>&#125;)someAsyncThing(<span class="hljs-literal">false</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data:&#x27;</span>,data); <span class="hljs-comment">// 不执行</span>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error:&#x27;</span>, error); <span class="hljs-comment">// 输出 &#x27;error&#x27;</span>&#125;)</code></pre><p>上面代码中，someAsyncThing 函数成功返回 ‘OK’, 失败返回 ‘error’, 只有失败时才会被 catch 捕捉到。</p><h2 id="10-1-Promise-实例方法"><a href="#10-1-Promise-实例方法" class="headerlink" title="10.1 Promise 实例方法"></a>10.1 Promise 实例方法</h2><ul><li><strong>Promise.all()</strong> </li></ul><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);</code></pre><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><ul><li><strong>Promise.race()</strong> </li></ul><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);</code></pre><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([  fetch(<span class="hljs-string">&#x27;/resource-that-may-take-a-while&#x27;</span>),  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>)), <span class="hljs-number">5000</span>)  &#125;)]);p.then(<span class="hljs-built_in">console</span>.log).catch(<span class="hljs-built_in">console</span>.error);</code></pre><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><ul><li><strong>Promise.allSettled()</strong> ES2020 引入</li></ul><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><ul><li><strong>Promise.any()</strong> ES2021 引入</li></ul><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><h1 id="11-async-await"><a href="#11-async-await" class="headerlink" title="11. async / await"></a>11. async / await</h1><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数的使用方式，直接在普通函数前面加上 async，表示这是一个异步函数，在要异步执行的语句前面加上 await，表示后面的表达式需要等待。async 是 Generator 的语法糖</p><ol><li>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</li><li>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。</li><li>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。 </li></ol><p>可以用写同步的方式来写异步操作</p><h1 id="12-Class-语法"><a href="#12-Class-语法" class="headerlink" title="12. Class 语法"></a>12. Class 语法</h1><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">typeof</span> Point <span class="hljs-comment">// &quot;function&quot;</span>Point === Point.prototype.constructor <span class="hljs-comment">// true</span></code></pre><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>&#123;  doStuff() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stuff&#x27;</span>);  &#125;&#125;<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Bar();b.doStuff() <span class="hljs-comment">// &quot;stuff&quot;</span></code></pre><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-comment">// ...</span>  &#125;  toString() &#123;    <span class="hljs-comment">// ...</span>  &#125;  toValue() &#123;    <span class="hljs-comment">// ...</span>  &#125;&#125;<span class="hljs-comment">// 等同于</span>Point.prototype = &#123;  <span class="hljs-keyword">constructor</span>() &#123;&#125;,  toString() &#123;&#125;,  toValue() &#123;&#125;,&#125;;</code></pre><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B();b.constructor === B.prototype.constructor <span class="hljs-comment">// true</span></code></pre><p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>()&#123;    <span class="hljs-comment">// ...</span>  &#125;&#125;<span class="hljs-built_in">Object</span>.assign(Point.prototype, &#123;  toString()&#123;&#125;,  toValue()&#123;&#125;&#125;);</code></pre><p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><pre><code class="hljs javascript">Point.prototype.constructor === Point <span class="hljs-comment">// true</span></code></pre><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><p>注意：Class 内部默认采用严格模式</p><ul><li>取值函数（getter）和存值函数（setter）</li></ul><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-comment">// ...</span>  &#125;  <span class="hljs-keyword">get</span> <span class="hljs-title">prop</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;  &#125;  <span class="hljs-keyword">set</span> <span class="hljs-title">prop</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span>+value);  &#125;&#125;<span class="hljs-keyword">let</span> inst = <span class="hljs-keyword">new</span> MyClass();inst.prop = <span class="hljs-number">123</span>;<span class="hljs-comment">// setter: 123</span>inst.prop<span class="hljs-comment">// &#x27;getter&#x27;</span></code></pre><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><h2 id="12-1-Class-继承"><a href="#12-1-Class-继承" class="headerlink" title="12.1 Class 继承"></a>12.1 Class 继承</h2><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;&#125;</code></pre><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(x, y, color) &#123;    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span>    <span class="hljs-built_in">this</span>.color = color;  &#125;  toString() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">super</span>.toString(); <span class="hljs-comment">// 调用父类的toString()</span>  &#125;&#125;</code></pre><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;  &#125;&#125;<span class="hljs-keyword">let</span> cp = <span class="hljs-keyword">new</span> ColorPoint(); <span class="hljs-comment">// ReferenceError</span></code></pre><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><h1 id="13-Symbol"><a href="#13-Symbol" class="headerlink" title="13. Symbol"></a>13. Symbol</h1><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</p><p>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Symbol</span>();<span class="hljs-keyword">typeof</span> s<span class="hljs-comment">// &quot;symbol&quot;</span></code></pre><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);s1 <span class="hljs-comment">// Symbol(foo)</span>s2 <span class="hljs-comment">// Symbol(bar)</span>s1.toString() <span class="hljs-comment">// &quot;Symbol(foo)&quot;</span>s2.toString() <span class="hljs-comment">// &quot;Symbol(bar)&quot;</span></code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。                                                                                                                         </p><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><p>但是，Symbol 值可以显式转为字符串。</p><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><h2 id="13-1-作为属性名"><a href="#13-1-作为属性名" class="headerlink" title="13.1 作为属性名"></a>13.1 作为属性名</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-built_in">Symbol</span>();<span class="hljs-comment">// 第一种写法</span><span class="hljs-keyword">let</span> a = &#123;&#125;;a[mySymbol] = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<span class="hljs-comment">// 第二种写法</span><span class="hljs-keyword">let</span> a = &#123;  [mySymbol]: <span class="hljs-string">&#x27;Hello!&#x27;</span>&#125;;<span class="hljs-comment">// 第三种写法</span><span class="hljs-keyword">let</span> a = &#123;&#125;;<span class="hljs-built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello!&#x27;</span> &#125;);<span class="hljs-comment">// 以上写法都得到同样结果</span>a[mySymbol] <span class="hljs-comment">// &quot;Hello!&quot;</span></code></pre><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p><p>注意，Symbol 值作为对象属性名时，不能用点运算符。因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><h2 id="13-2-属性名的遍历"><a href="#13-2-属性名的遍历" class="headerlink" title="13.2 属性名的遍历"></a>13.2 属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>不会被以下遍历：</p><ul><li><code>for...in</code></li><li><code>for...of</code></li></ul><p>不会被以下返回：</p><ul><li><code>Object.keys()</code></li><li><code>Object.getOwnPropertyNames()</code></li><li><code>JSON.stringify()</code></li></ul><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><h2 id="13-3-Symbol-for-Symbol-keyFor"><a href="#13-3-Symbol-for-Symbol-keyFor" class="headerlink" title="13.3 Symbol.for() Symbol.keyFor()"></a>13.3 Symbol.for() Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;foo&#x27;</span>);s1 === s2 <span class="hljs-comment">// true</span></code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><h1 id="14-Module-语法"><a href="#14-Module-语法" class="headerlink" title="14. Module 语法"></a>14. Module 语法</h1><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><h2 id="14-1-export"><a href="#14-1-export" class="headerlink" title="14.1 export"></a>14.1 export</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><pre><code class="hljs js"><span class="hljs-comment">// profile.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;</code></pre><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p>等价于：</p><pre><code class="hljs js"><span class="hljs-comment">// profile.js</span><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<span class="hljs-keyword">export</span> &#123; firstName, lastName, year &#125;;</code></pre><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v1</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v2</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<span class="hljs-keyword">export</span> &#123;  v1 <span class="hljs-keyword">as</span> streamV1,  v2 <span class="hljs-keyword">as</span> streamV2,  v2 <span class="hljs-keyword">as</span> streamLatestVersion&#125;;</code></pre><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><h2 id="14-2-import"><a href="#14-2-import" class="headerlink" title="14.2 import"></a>14.2 import</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> &#123; firstName, lastName, year &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params">element</span>) </span>&#123;  element.textContent = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;&#125;</code></pre><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><pre><code class="hljs javascript">foo();<span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;</code></pre><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;</code></pre><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><h2 id="14-3-export-default"><a href="#14-3-export-default" class="headerlink" title="14.3 export default"></a>14.3 export default</h2><p>用到<code>export default</code>命令，为模块指定默认输出。</p><pre><code class="hljs javascript"><span class="hljs-comment">// export-default.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);&#125;</code></pre><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><pre><code class="hljs javascript"><span class="hljs-comment">// import-default.js</span><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>;customName(); <span class="hljs-comment">// &#x27;foo&#x27;</span></code></pre><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用在非匿名函数前，也是可以的。</p><p>下面比较一下默认输出和正常输出。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 第一组</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">import</span> crc32 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crc32&#x27;</span>; <span class="hljs-comment">// 输入</span><span class="hljs-comment">// 第二组</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span>  <span class="hljs-comment">// ...</span>&#125;;<span class="hljs-keyword">import</span> &#123;crc32&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crc32&#x27;</span>; <span class="hljs-comment">// 输入</span></code></pre><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-comment">// export default add;</span><span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-comment">// import foo from &#x27;modules&#x27;;</span></code></pre><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">// 正确</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<span class="hljs-comment">// 错误</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</code></pre><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">42</span>;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">export</span> <span class="hljs-number">42</span>;</code></pre><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;</code></pre><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _, &#123; each, forEach &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;</code></pre><p>对应上面代码的<code>export</code>语句如下。</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-comment">// ···</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">obj, iterator, context</span>) </span>&#123;  <span class="hljs-comment">// ···</span>&#125;<span class="hljs-keyword">export</span> &#123; each <span class="hljs-keyword">as</span> forEach &#125;;</code></pre><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><p><code>export default</code>也可以用来输出类。</p><h1 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15. Reflect"></a>15. Reflect</h1><p><code>Reflect</code>是一个内置的对象，它提供拦截 JavaScript 操作的方法。Reflect 不是一个函数对象，因此它是不可构造的。<code>Reflect</code>的所有的方法都是静态的就和<code>Math</code>一样，目前它还没有静态属性。</p><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法相同。</p><p><code>Reflect</code> 一共有13个静态方法：</p><p>它可以分为一部分是是原来存在<code>Object</code>上的方法，将它转义到了<code>Reflect</code>上，并作了小改动，让方法更加合理。</p><ol><li><code>defineProperty</code> 与<a href="https://juejin.im/post/6844903788642484237#heading-1">Object.defineProperty</a>类似，但是当对象无法定义时<code>Object.defineProperty</code>会报错而<code>Reflect.defineProperty</code>不会，它会返回<code>false</code>，成功时返回<code>true</code>，如果不是对象还是会报错。</li><li><code>getPrototypeOf(target)</code> 与<code>Object.getPrototypeOf</code>一样，返回指定对象的原型。</li><li><code>setPrototypeOf(target, prototype)</code> 与<code>Object.setPrototypeOf</code>一样，它将指定对象的原型设置为另外一个对象。</li><li><code>getOwnPropertyDescriptor()</code> 与<code>Object.getOwnPropertyDescriptor</code>一样，如果在对象中存在，则返回给定的属性的<a href="https://juejin.im/post/6844903788642484237#heading-1">属性描述符</a>。</li><li><code>isExtensible(target)</code> 与<code>Object.isExtensible</code>类似，判断一个对象是否可扩展（是否可以在它上面添加新的属性），它们的不同点是，当参数不是对象时（原始值），<code>Object</code>的将它强制转变为一个对象，<code>Reflect</code>是直接报错。</li><li><code>preventExtensions(target)</code> 与<code>Object.preventExtensions</code>类似，阻止新属性添加到对象，不同点和上一条一样。</li><li><code>apply(func, thisArg, args)</code> 与<code>Function.prototype.apply.call(fn, obj, args)</code>一样。</li><li><code>ownKeys(target)</code> 与<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>一样，返回一个包含所有自身属性（不包含继承属性）的数组</li></ol><p>另一部分是将原来操作符的功能，变成函数行为。</p><ol><li><code>has(target, key)</code> 与<code>in</code>操作符一样，让判断操作都变成函数行为。</li><li><code>deleteProperty(target, key)</code> 与<code>delete</code>操作符一样，让删除操作变成函数行为，返回布尔值代表成功或失败。</li><li><code>construct(target, argumentsList[, newTarget])</code> 与<code>new</code>操作符一样，<code>target</code>构造函数，第二参数是构造函数参数类数组，第三个是<a href="https://juejin.im/post/6844903788642484237#heading-4">new.target</a>的值。</li><li><code>get(target, key[, receiver])</code> 与<code>obj[key]</code>一样，第三个参数是当要取值的<code>key</code>部署了<code>getter</code>时，访问其函数的<code>this</code>绑定为<code>receiver</code>对象。</li><li><code>set(target, key, value[, receiver])</code> 设置<code>target</code>对象的<code>key</code>属性等于<code>value</code>，第三个参数和<code>set</code>一样。返回一个布尔值。</li></ol><pre><code class="hljs js"><span class="hljs-comment">// 老写法</span><span class="hljs-string">&#x27;assign&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.has(<span class="hljs-built_in">Object</span>, <span class="hljs-string">&#x27;assign&#x27;</span>) <span class="hljs-comment">// true</span><span class="hljs-comment">// 老写法</span><span class="hljs-built_in">Function</span>.prototype.apply.call(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span><span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span><span class="hljs-comment">// 旧写法</span><span class="hljs-keyword">delete</span> myObj.foo;<span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.deleteProperty(myObj, <span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-comment">// new 的写法</span><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Greeting(<span class="hljs-string">&#x27;张三&#x27;</span>);<span class="hljs-comment">// Reflect.construct 的写法</span><span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Reflect</span>.construct(Greeting, [<span class="hljs-string">&#x27;张三&#x27;</span>]);<span class="hljs-comment">// 旧写法</span><span class="hljs-built_in">Object</span>.defineProperty(MyDate, <span class="hljs-string">&#x27;now&#x27;</span>, &#123;  value: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Date</span>.now()&#125;);<span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.defineProperty(MyDate, <span class="hljs-string">&#x27;now&#x27;</span>, &#123;  value: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Date</span>.now()&#125;);<span class="hljs-built_in">Reflect</span>.get(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">Reflect</span>.get(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">Reflect</span>.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">Reflect</span>.set(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="hljs-comment">// 报错</span><span class="hljs-comment">// ---------------</span><span class="hljs-keyword">var</span> myObject = &#123;  foo: <span class="hljs-number">1</span>,  bar: <span class="hljs-number">2</span>,  <span class="hljs-keyword">get</span> <span class="hljs-title">baz</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.foo + <span class="hljs-built_in">this</span>.bar;  &#125;,&#125;;<span class="hljs-keyword">var</span> myReceiverObject = &#123;  foo: <span class="hljs-number">4</span>,  bar: <span class="hljs-number">4</span>,&#125;;<span class="hljs-built_in">Reflect</span>.get(myObject, <span class="hljs-string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="hljs-comment">// 8</span></code></pre><h1 id="16-Proxy"><a href="#16-Proxy" class="headerlink" title="16. Proxy"></a>16. Proxy</h1><blockquote><p>ES6 Proxy 提供了强大的 Javascript 元编程接口</p></blockquote><p><strong>Proxy</strong> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等），等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p><strong>Proxy</strong> 就像在目标对象之间的一个代理，任何对目标的操作都要经过代理。代理就可以对外界的操作进行过滤和改写。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)</code></pre><p><code>Proxy</code>是构造函数，它有两个参数<code>target</code>和<code>handler</code>，</p><p><code>target</code>是用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p><p><code>handler</code>是一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);  &#125;,  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, value, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`setting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);  &#125;&#125;);obj.count = <span class="hljs-number">1</span><span class="hljs-comment">//  setting count!</span>++obj.count<span class="hljs-comment">//  getting count!</span><span class="hljs-comment">//  setting count!</span><span class="hljs-comment">//  2</span></code></pre><p><code>Proxy</code>只有一个静态方法<code>revocable(target, handler)</code>可以用来创建一个可撤销的代理对象。两个参数和构造函数的相同。它返回一个包含了所生成的代理对象本身以及该代理对象的撤销方法的对象。</p><p>一旦某个代理对象被撤销，它将变的几乎完全不可用，在它身上执行任何的可代理操作都会抛出 TypeError 异常（注意，可代理操作一共有 14 种，执行这 14 种操作以外的操作不会抛出异常）。</p><p>一旦被撤销，这个代理对象永远不可能恢复到原来的状态，同时和它关联的目标对象以及处理器对象将有可能被垃圾回收掉。调用撤销方法多次将不会有任何效果，当然，也不会报错。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> revocable = <span class="hljs-built_in">Proxy</span>.revocable(&#123;&#125;, &#123;  get(target, name) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[[&quot;</span> + name + <span class="hljs-string">&quot;]]&quot;</span>;  &#125;&#125;);<span class="hljs-comment">// revocable -&gt; &#123;&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke&#125;</span><span class="hljs-keyword">var</span> proxy = revocable.proxy;proxy.foo;              <span class="hljs-comment">// &quot;[[foo]]&quot;</span>revocable.revoke();     <span class="hljs-comment">// 执行撤销方法</span>proxy.foo;              <span class="hljs-comment">// TypeError</span>proxy.foo = <span class="hljs-number">1</span>           <span class="hljs-comment">// 同样 TypeError</span><span class="hljs-keyword">delete</span> proxy.foo;       <span class="hljs-comment">// 还是 TypeError</span><span class="hljs-keyword">typeof</span> proxy            <span class="hljs-comment">// &quot;object&quot;，因为 typeof 不属于可代理操作</span></code></pre><p><code>handler</code>参数是代理函数对象，它一共支持 13 种拦截函数。和<code>Reflect</code>的相同。如果没有定义某种操作，那么这种操作会被转发到目标对象身上。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, property, receiver</span>) </span>&#123;    <span class="hljs-keyword">return</span> receiver;    <span class="hljs-comment">// receiver 总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</span>  &#125;&#125;);proxy.getReceiver === proxy <span class="hljs-comment">// true</span></code></pre><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><ol><li><p><code>apply</code>方法拦截函数的<code>调用</code>、<code>call</code>和<code>apply</code>操作。</p></li><li><p><code>defineProperty</code>方法拦截了<code>Object.defineProperty</code>操作。</p></li><li><p><code>getPrototypeOf</code>方法主要用来拦截获取对象原型，会以下这些操作：</p><ol><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ol></li><li><p><code>ownKeys</code>方法用来拦截对象自身属性的读取操作，会拦截以下操作：</p><ol><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for...in</code></li></ol></li></ol><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。</p><p>主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ECMAScript6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 的运行机制</title>
    <link href="/2020/09/28/JavaScript%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/09/28/JavaScript%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的运行机制"><a href="#JavaScript-的运行机制" class="headerlink" title="JavaScript 的运行机制"></a>JavaScript 的运行机制</h1><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 Event Loop</h2><p>JavaScript 脚本加载完成时, JS 引擎会去预解析JS代码, 为代码中的「对象」预先在堆内存中分配地址空间, 然后按</p><p>顺序逐句解释执行( 即时编译 JIT)</p><p>第一次JS代码执行时, 会默认创建一个「全局执行上下文」, 并将其压入「执行栈」底,  然后每当引擎遇到一个函数</p><p>调用时, 都将会为其创建一个<strong>新</strong>的「函数执行上下文」, 并将其压入执行栈<strong>顶.</strong> 引擎会执行那些执行上下文位于<strong>栈顶</strong></p><p>的函数。当该函数执行结束时，「执行上下文」从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>每一个 JavaScript 程序都有且只有一个默认的「全局执行上下文」, 在浏览器环境中它指向 <code>Window</code></p><p><img src="/images/exceute_stack.jpg" alt="exceute_stack"></p><blockquote><p>macro-task(宏任务)：包括整体代码script（同步宏任务），setTimeout、setInterval（异步宏任务）</p><p>micro-task(微任务)：Promise，process.nextTick，ajax请求（异步微任务）</p></blockquote><p>当引擎在创建函数「执行上下文」之前, 会判断当前函数是 <strong>同步任务</strong>还是 <strong>异步任务</strong>, 如果是 <strong>同步任务</strong>,  就进入主</p><p>线程创建「函数执行上下文」并且压入 <strong>执行栈顶</strong>等待执行, 如果是 <strong>异步任务</strong> , 则不 进入主线程执行 ,  不创建函数 </p><p> 执行上下文  , 而是被<code>Event Table</code> 所记录, 当 <strong>异步任务</strong>准备好时, 为其注册回调用函数, 进入事件队列<code>Event </code></p><p><code>Quene</code>等待执行</p><p>当执行栈执行完毕时, 调用 事件队列 <code>Event Quene</code> 中的回调函数进栈执行, 在<strong>异步任务</strong>被 <code>Event Table</code> 所记录之</p><p>前, 会判断是 「宏任务」 还是 「微任务」 , 分别被 宏任务 Event Table 和 微任务Event Table 记录, 最后再注册回</p><p>调函数, 并进入相应的「宏任务事件队列 」和 「微任务事件队列」</p><blockquote><p>注意「宏任务」和「微任务」并不是严格意义上的 “平级关系”</p></blockquote><p>在主线程调取「任务队列」的 回调函数进入「执行栈」执行时, 优先调用「微任务事件队列」执行完毕 再调用 </p><p>「宏任务事件队列」 以上步骤循环,就是 「JavaScript」 的 <strong>事件循环</strong></p><p>talk is cheap show your code, 用代码解释:</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">// 记作 set1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);    <span class="hljs-comment">// set4</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);    &#125;);    <span class="hljs-comment">// pro2</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);    &#125;);&#125;);<span class="hljs-comment">// 记作 pro1</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);    <span class="hljs-comment">// set3</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);    &#125;);&#125;);<span class="hljs-comment">// 记作 set2</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>);    <span class="hljs-comment">// 记作 pro3</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>);    &#125;);&#125;);</code></pre><ol><li><p>整体代码 script 为一个大的宏任务,进入执行栈执行, 顺序执行 <code>打印1</code> </p></li><li><p>遇到定时器set1为异步的宏任务不进入主线程执行,注册进入宏任务队列 <code>(set1)</code> </p></li><li><p>继续执行遇到 Promise pro1 先执行其中的同步代码  <code>打印6</code>  , pro1中的<code>then()</code>为异步的微任务不进入主线程执行, 注册进入微任务队列 <code>(pro1)</code>,</p></li><li><p>继续执行遇到定时器 set2 为异步的宏任务不进入主线程执行, 注册进入宏任务队列 <code>(set1 set2)</code>,</p></li><li><p>此时执行栈空,检测任务队列是否有任务等待执行,优先执行微任务 <code>(pro1)</code></p></li><li><p>执行微任务队列 <code>(pro1)</code> pro1的 then()  <code>打印7</code>  </p><ol><li>继续执行遇到定时器set3 不进入主线程执行,注册进入宏任务队列 <code>(set1 set2 set3)</code></li></ol></li><li><p>微任务队列空, 执行宏任务队列 <code>(set1 set2 set3)</code> set1  <code>打印2</code>  ,</p><ol><li>遇到定时器set4为异步的宏任务不进入主线程执行,注册进入宏任务队列 <code>(set2 set3 set4)</code> </li><li>遇到 Promise pro2 先执行其中的同步任务,并且为其then 注册微任务队列 <code>(pro2)</code></li></ol></li><li><p>执行栈继续调用任务队列回调函数执行, 此时微任务队列 (pro2)不为空, pro2 的<code>then()</code>优先执行<code>打印5</code> </p></li><li><p>执行微任务完毕, 继续执行宏任务队列<code>(set2 set3 set4)</code> set2  <code>打印9</code> </p><ol><li>遇到 pro3 同样先执行其中同步代码<code>打印10</code>再为其then 注册微任务队列 <code>(pro3)</code></li></ol></li><li><p>执行栈继续调用任务队列回调函数执行, 优先执行微任务队列<code>(pro3)</code>  pro3的 then() <code>打印11</code>  ,</p></li><li><p>微任务队列空, 执行宏任务队列<code>(set3 set4)</code>set3 <code>打印8</code>  执行set4  <code>打印3</code></p></li></ol><pre><code class="hljs js"><span class="hljs-comment">//打印顺序:1 6 7 2 5 9 10 11 8 3</span></code></pre><p>以上就是JS中的 「事件循环」Event Loop</p><p>执行顺序为 同步(宏)任务-&gt;异步微任务-&gt;异步宏任务-&gt;…</p><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><p>ES6新引入了Promise标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念，在ECMAScript中，<code>microtask</code>也被称为<code>jobs</code></p><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><pre><code class="hljs clean">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>图解:</p><p><img src="/images/js_eventloop.jpg" alt="js_eventloop"></p><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>当 JavaScript 脚本加载完成, 第一次被JavaScript 引擎所读取时, 会默认创建一个「全局执行上下文」, 并将其压入执行栈底, 然后每当引擎遇到一个函数调用, 它都会为该函数创建一个新的「函数执行上下文」并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>每一个 JavaScript 程序都有且只有一个默认的「全局执行上下文」, 在浏览器环境中它指向 <code>Window</code></p><p>下面是一段模拟执行栈顺序</p><p>代码:</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);  second();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);&#125;first();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);</code></pre><p>打印台:</p><pre><code class="hljs js"><span class="hljs-comment">//Inside first function</span><span class="hljs-comment">//Inside second function</span><span class="hljs-comment">//Again inside first function</span><span class="hljs-comment">//Inside Global Execution Context</span></code></pre><p>图解执行栈:</p><p><img src="/images/exceute_stack.jpg" alt="exceute_stack"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
