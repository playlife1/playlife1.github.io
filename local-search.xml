<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JavaScript 的运行机制</title>
    <link href="/2020/09/28/JavaScript%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/09/28/JavaScript%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的运行机制"><a href="#JavaScript-的运行机制" class="headerlink" title="JavaScript 的运行机制"></a>JavaScript 的运行机制</h1><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 Event Loop</h2><p>JavaScript 脚本加载完成时, JS 引擎会去预解析JS代码, 为代码中的「对象」预先在堆内存中分配地址空间, 然后按</p><p>顺序逐句解释执行( 即时编译 JIT)</p><p>第一次JS代码执行时, 会默认创建一个「全局执行上下文」, 并将其压入「执行栈」底,  然后每当引擎遇到一个函数</p><p>调用时, 都将会为其创建一个<strong>新</strong>的「函数执行上下文」, 并将其压入执行栈<strong>顶.</strong> 引擎会执行那些执行上下文位于<strong>栈顶</strong></p><p>的函数。当该函数执行结束时，「执行上下文」从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>每一个 JavaScript 程序都有且只有一个默认的「全局执行上下文」, 在浏览器环境中它指向 <code>Window</code></p><p><img src="/images/exceute_stack.jpg" alt="exceute_stack"></p><blockquote><p>macro-task(宏任务)：包括整体代码script（同步宏任务），setTimeout、setInterval（异步宏任务）</p><p>micro-task(微任务)：Promise，process.nextTick，ajax请求（异步微任务）</p></blockquote><p>当引擎在创建函数「执行上下文」之前, 会判断当前函数是 <strong>同步任务</strong>还是 <strong>异步任务</strong>, 如果是 <strong>同步任务</strong>,  就进入主</p><p>线程创建「函数执行上下文」并且压入 <strong>执行栈顶</strong>等待执行, 如果是 <strong>异步任务</strong> , 则不 进入主线程执行 ,  不创建函数 </p><p> 执行上下文  , 而是被<code>Event Table</code> 所记录, 当 <strong>异步任务</strong>准备好时, 为其注册回调用函数, 进入事件队列<code>Event </code></p><p><code>Quene</code>等待执行</p><p>当执行栈执行完毕时, 调用 事件队列 <code>Event Quene</code> 中的回调函数进栈执行, 在**异步任务 **被 <code>Event Table</code> 所记录之</p><p>前, 会判断是 「宏任务」 还是 「微任务」 , 分别被 宏任务 Event Table 和 微任务Event Table 记录, 最后再注册回</p><p>调函数, 并进入相应的「宏任务事件队列 」和 「微任务事件队列」</p><blockquote><p>注意「宏任务」和「微任务」并不是严格意义上的 “平级关系”</p></blockquote><p>在主线程调取「任务队列」的 回调函数进入「执行栈」执行时, 优先调用「微任务事件队列」执行完毕 再调用 </p><p>「宏任务事件队列」 以上步骤循环,就是 「JavaScript」 的 <strong>事件循环</strong></p><p>talk is cheap show your code, 用代码解释:</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">// 记作 set1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);    <span class="hljs-comment">// set4</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);    &#125;);    <span class="hljs-comment">// pro2</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);    &#125;);&#125;);<span class="hljs-comment">// 记作 pro1</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);    <span class="hljs-comment">// set3</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);    &#125;);&#125;);<span class="hljs-comment">// 记作 set2</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>);    <span class="hljs-comment">// 记作 pro3</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>);    &#125;);&#125;);</code></pre><ol><li><p>整体代码 script 为一个大的宏任务,进入执行栈执行, 顺序执行 <code>打印1</code> </p></li><li><p>遇到定时器set1为异步的宏任务不进入主线程执行,注册进入宏任务队列 <code>(set1)</code> </p></li><li><p>继续执行遇到 Promise pro1 先执行其中的同步代码  <code>打印6</code>  , pro1中的<code>then()</code>为异步的微任务不进入主线程执行, 注册进入微任务队列 <code>(pro1)</code>,</p></li><li><p>继续执行遇到定时器 set2 为异步的宏任务不进入主线程执行, 注册进入宏任务队列 <code>(set1 set2)</code>,</p></li><li><p>此时执行栈空,检测任务队列是否有任务等待执行,优先执行微任务 <code>(pro1)</code></p></li><li><p>执行微任务队列 <code>(pro1)</code> pro1的 then()  <code>打印7</code>  </p><ol><li>继续执行遇到定时器set3 不进入主线程执行,注册进入宏任务队列 <code>(set1 set2 set3)</code></li></ol></li><li><p>微任务队列空, 执行宏任务队列 <code>(set1 set2 set3)</code> set1  <code>打印2</code>  ,</p><ol><li>遇到定时器set4为异步的宏任务不进入主线程执行,注册进入宏任务队列 <code>(set2 set3 set4)</code> </li><li>遇到 Promise pro2 先执行其中的同步任务,并且为其then 注册微任务队列 <code>(pro2)</code></li></ol></li><li><p>执行栈继续调用任务队列回调函数执行, 此时微任务队列 (pro2)不为空, pro2 的<code>then()</code>优先执行<code>打印5</code> </p></li><li><p>执行微任务完毕, 继续执行宏任务队列<code>(set2 set3 set4)</code> set2  <code>打印9</code> </p><ol><li>遇到 pro3 同样先执行其中同步代码<code>打印10</code>再为其then 注册微任务队列 <code>(pro3)</code></li></ol></li><li><p>执行栈继续调用任务队列回调函数执行, 优先执行微任务队列<code>(pro3)</code>  pro3的 then() <code>打印11</code>  ,</p></li><li><p>微任务队列空, 执行宏任务队列<code>(set3 set4)</code>set3 <code>打印8</code>  执行set4  <code>打印3</code></p></li></ol><pre><code class="hljs js"><span class="hljs-comment">//打印顺序:1 6 7 2 5 9 10 11 8 3</span></code></pre><p>以上就是JS中的 「事件循环」Event Loop</p><p>执行顺序为 同步(宏)任务-&gt;异步微任务-&gt;异步宏任务-&gt;…</p><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><p>ES6新引入了Promise标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念，在ECMAScript中，<code>microtask</code>也被称为<code>jobs</code></p><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><pre><code class="hljs clean">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>图解:</p><p><img src="/images/js_eventloop.jpg" alt="js_eventloop"></p><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>当 JavaScript 脚本加载完成, 第一次被JavaScript 引擎所读取时, 会默认创建一个「全局执行上下文」, 并将其压入执行栈底, 然后每当引擎遇到一个函数调用, 它都会为该函数创建一个新的「函数执行上下文」并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>每一个 JavaScript 程序都有且只有一个默认的「全局执行上下文」, 在浏览器环境中它指向 <code>Window</code></p><p>下面是一段模拟执行栈顺序</p><p>代码:</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);  second();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);&#125;first();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);</code></pre><p>打印台:</p><pre><code class="hljs js"><span class="hljs-comment">//Inside first function</span><span class="hljs-comment">//Inside second function</span><span class="hljs-comment">//Again inside first function</span><span class="hljs-comment">//Inside Global Execution Context</span></code></pre><p>图解执行栈:</p><p><img src="/images/exceute_stack.jpg" alt="exceute_stack"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Homebrew 🍺</title>
    <link href="/2020/09/26/HomeBrew%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2020/09/26/HomeBrew%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Homebrew-🍺"><a href="#Homebrew-🍺" class="headerlink" title="Homebrew 🍺"></a>Homebrew 🍺</h1><blockquote><p>Homebrew是一款自由及开放源代码的软件包管理系统，用以简化macOS系统上的软件安装过程，最初由马克斯·霍威尔写成。因其可扩展性得到了一致好评，而在Ruby on Rails社区广为人知。 Homebrew使用GitHub，通过用户的贡献扩大对软件包的支持。</p></blockquote><p><img src="https://github.com/playlife1/document/raw/master/pic/homebrew_logo.png"></p><p>Homebrew默认将工具安装在自己创建的/usr/local/Cellar目录下，并在/usr/local/bin建立这些工具的符号链接。</p><h2 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h2><p>官方推荐方法:</p><pre><code class="hljs bash">/bin/bash -c <span class="hljs-string">&quot;<span class="hljs-subst">$(curl -fsSLhttps://raw.githubusercontent.com/Homebrew/install/master/install.sh)</span>&quot;</span></code></pre><p>将上述代码复制粘贴至 「终端」</p><p>不出意外会出现443错误:</p><pre><code class="hljs bash">curl: (7) Failed to connect to raw.githubusercontent.com port 443: Connection refused</code></pre><blockquote><p> 显而易见被墙了 🤷🏻‍♂️🤷🏻‍♂️🤷🏻‍♂️</p></blockquote><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><blockquote><p>条条大路通罗马,解决的方法不止一种,以下为我个人实践可行的方法</p></blockquote><ol><li><p>使用mac自带的<code>ruby</code>执行脚本，采用镜像文件安装</p></li><li><p>下载我准备的好的<a href="https://github.com/playlife1/document/tree/master/resource">安装脚本</a>, 保存为<code>homebrew.rb</code> 在<strong>该文件所在的文件夹</strong>下打开终端并执行<code>ruby homebrew.rb</code></p><p>不出意外，应该还会出现以下错误</p></li></ol><pre><code class="hljs bash">Cloning into <span class="hljs-string">&#x27;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&#x27;</span>...fatal: unable to access <span class="hljs-string">&#x27;https://github.com/Homebrew/homebrew-core/&#x27;</span>: LibreSSL SSL_read:SSL_ERROR_SYSCALL, errno 54Error: Failure <span class="hljs-keyword">while</span> executing; `git <span class="hljs-built_in">clone</span> https://github.com/Homebrew/homebrew-core/usr/<span class="hljs-built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1` exited with 128.Error: Failure <span class="hljs-keyword">while</span> executing; `/usr/<span class="hljs-built_in">local</span>/bin/brew tap homebrew/core` exited with 1.</code></pre><ol start="3"><li>更换为中科院的镜像, 执行下面命令</li></ol><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> git://mirrors.ustc.edu.cn/homebrew-core.git/</code></pre><pre><code class="hljs bash">/usr/<span class="hljs-built_in">local</span>/Homebrew/Library/Taps/homebrew/homebrew-core --depth=1</code></pre><ol start="4"><li>把<code>homebrew-core</code>的镜像地址也设为中科院的国内镜像</li></ol><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>&quot;</span></code></pre><pre><code class="hljs bash">git remote set-url origin https://mirrors.ustc.edu.cn/brew.git</code></pre><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;<span class="hljs-subst">$(brew --repo)</span>/Library/Taps/homebrew/homebrew-core&quot;</span></code></pre><pre><code class="hljs bash">git remote set-url origin https://mirrors.ustc.edu.cn/homebrew-core.git</code></pre><ol start="5"><li>更新一下设置</li></ol><pre><code class="hljs bash">brew update</code></pre><ol start="6"><li>回到<code>homebrew.rb</code> 文件所在<strong>文件夹</strong>重新安装</li></ol><pre><code class="hljs bash">ruby homebrew.rb</code></pre><p>🎉🎉🎉bingo~ 现在 Homebrew 安装完成, enjoy it !🍺</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><p>cd 到 <code>uninstall.rb</code> 所在<strong>文件夹</strong> 执行文件</p><pre><code class="hljs bash">ruby uninstall.rb</code></pre><p><a href="https://github.com/playlife1/document/tree/master/resource">卸载脚本下载</a></p><h2 id="感谢🙏"><a href="#感谢🙏" class="headerlink" title="感谢🙏"></a>感谢🙏</h2><p>以上所使用脚本作者 <a href="https://github.com/ineo6">ineo6</a> ,请给原作者一个star⭐️⭐️⭐️</p>]]></content>
    
    
    
    <tags>
      
      <tag>tutorial</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
