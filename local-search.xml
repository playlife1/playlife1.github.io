<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浏览器输入URL发生了什么</title>
    <link href="/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2020/11/20/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%BE%93%E5%85%A5URL%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器输入URL发生了什么"><a href="#浏览器输入URL发生了什么" class="headerlink" title="浏览器输入URL发生了什么"></a>浏览器输入URL发生了什么</h1><p>从输入 <code>URL</code> 到页面呈现发生了什么？</p><p>整体过程：</p><p>在用户输入 URL，按下回车之后，走过的步骤：</p><ol><li><code>DNS</code> 解析</li><li><code>TCP</code> 连接</li><li>发送 <code>HTTP</code> 请求</li><li>服务器响应</li><li>浏览器解析渲染页面</li></ol><h1 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h1><blockquote><p><code>DNS</code> 解析过程就是通过网络查找哪台机器有你需要的资源的过程。</p></blockquote><p>浏览器输入 <code>github.com</code> 并不是真正意义上的去查找这个，而是查找这个域名解析到的 <code>IP</code> 地址。</p><p>互联网上每一台计算机的唯一标识是它的 <code>IP</code> 地址，但是 <code>IP</code> 地址并不方便记忆，所以互联网设计者为了方便，才会搞出 <code>github.com</code> 这样的域名。</p><ul><li>DNS 解析过程：</li></ul><ol><li>查询 <code>www.github.com</code></li><li>访问客户端 DNS 缓存：<strong>浏览器缓存</strong> → <strong>系统缓存（host）</strong> →  <strong>路由器缓存</strong></li><li>访问 <strong>ISP DNS 服务器</strong>（ISP，互联网服务提供商），如果本地服务器有，则直接返回；如果没有，让本地 DNS 服务器去咨询查找。</li><li>本地去咨询 <strong>DNS 根服务器</strong>，DNS 根服务器发现是 <code>.com 区域</code> 管理的，告诉本地去咨询它。</li><li>本地去咨询 <strong>.com 顶级域名服务器</strong>，.com 顶级域名服务器不太清楚，告诉本地去咨询 <code>github.com</code> 主区域 的服务器。</li><li>本地去咨询 <strong>github.com 主域名服务器</strong>，baidu.com 域服务器查找到对应的 IP 地址，返回给本地。</li><li>本地服务器通知用户，<code>github.com</code> 对应的 IP 地址，同时缓存这个 IP 地址，下次就直接访问了。</li></ol><h1 id="TCP-连接"><a href="#TCP-连接" class="headerlink" title="TCP 连接"></a>TCP 连接</h1><blockquote><p>TCP 连接的内容，详细请看 《TCP 三次握手和四次挥手》</p></blockquote><ul><li>建立连接阶段：3 次握手。建立客户端和服务器之间的连接。</li><li>传输数据阶段</li><li>断开连接阶段：4 次挥手。断开客户端和服务器之间的连接。</li></ul><h1 id="发送-HTTP-请求"><a href="#发送-HTTP-请求" class="headerlink" title="发送 HTTP 请求"></a>发送 HTTP 请求</h1><p>发送 <code>HTTP</code> 请求的过程就是构建 <code>HTTP</code> 请求报文，并通过 <code>TCP</code> 协议发送到服务器指定端口（<code>HTTP</code> 协议默认端口 <code>80/8080</code>，<code>HTTPS</code> 协议默认端口 <code>443</code>）。</p><p><code>HTTP</code> 请求报文由 3 部分组成：<strong>请求行</strong>、<strong>请求报文</strong> 和 <strong>请求正文</strong>。</p><ul><li>请求行：常用方法有：GET、POST、PUT、DELETE、OPTIONS、HEAD。</li><li>请求报头：允许客户端向服务器传递请求的附加信息和客户端自身的信息。</li><li>请求正文：通过 POST、PUT 等方法时，通常需要客户端向服务器传递数据，这些数据就储存在请求正文中。</li></ul><p>当然，<code>HTTP</code> 请求需要注意是否跨域，如何解决跨域问题：</p><ul><li><p>JSONP</p></li><li><p>跨域资源共享（CORS）服务端设置 <code>Access-Control-Allow-Origin</code></p></li><li><p>Nginx 反向代理跨域</p><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p></li></ul><h1 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h1><p>服务器处理请求完毕后，会返回 <code>HTTP</code> 报文。</p><p><code>HTTP</code> 响应报文也是由 3 部分组成：<strong>状态码</strong>、<strong>响应报头</strong> 和 <strong>响应报文</strong>。</p><p><strong>状态码</strong>：<code>1xx</code> 指示信息-表示请求已接收；<code>2xx</code> 请求成功-表示请求成功接收并解析；<code>3xx</code> 重定向-表示要完成请求需要更进一步操作；<code>4xx</code> 客户端错误-请求有语法错误或者请求无法实现；<code>5xx</code>：服务端错误-服务端未能实现合法的请求。</p><p><strong>常见状态码</strong>：200（成功）、304（请求内容有缓存，不需要更新）、404（网页或者文件找不到）、500（服务器-后端处理错误）。</p><p><strong>响应报头</strong>：常见的响应报头字段 <code>Server</code>、<code>Connection</code> 等。</p><p><strong>响应报文</strong>：服务器返回给浏览器的文本信息，通常 HTML、CSS、JS、图片等文件就放在这一部分。</p><h1 id="浏览器解析渲染页面"><a href="#浏览器解析渲染页面" class="headerlink" title="浏览器解析渲染页面"></a>浏览器解析渲染页面</h1><p>浏览器的渲染过程为：</p><ol><li>解析 HTML，生成 <code>DOM</code> 树</li><li>解析 CSS，生成 <code>CSS 规则树（CSS Rule Tree）</code></li><li>将 <code>DOM Tree</code> 和 <code>CSS Rule Tree</code> 相结合，生成 <strong>渲染树</strong>（<code>Render Tree</code>）</li><li>从根节点开始，计算每一个元素的大小、位置，给出每个节点所应该出现的屏幕精确坐标，从而得到基于渲染树的 <strong>布局渲染树</strong>（<code>Layout of the render tree</code>）。</li><li>遍历渲染树，将每个节点用 UI 渲染引擎来绘制，从而将整棵树绘制到页面上，这个步骤叫 <strong>绘制渲染树</strong>（<code>Painting the render tree</code>）</li></ol><p>在解析渲染过程中，可能会产生 <strong>回流</strong> 和 <strong>重绘</strong>：</p><ul><li>重绘 (repaint)：当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要 UI 层面的重新像素绘制，因此<strong>损耗较少</strong>。</li><li>回流 (reflow)：又叫重排（<code>layout</code>）。当元素的尺寸、结构或者触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</li></ul><h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p>JavaScript 的加载、解析和执行会阻塞 DOM 的构建。</p><p>在渲染的过程中，遇到一个 script 标记时，就会停止渲染，去请求脚本文件并执行脚本文件，因为浏览器渲染和 JavaScript 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。</p><p>JavaScript 的加载、解析与执行会严重阻塞DOM的构建。只有等到脚本文件执行完毕，才会去继续构建DOM。</p><p>JavaScript 不单会阻塞DOM构建，还会导致 CSSOM 也阻塞 DOM 的构建，如果 JavaScript 脚本还操作了CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM的下载和构建，然后再执行 JavaScript，最后在继续构建 DOM。</p><p>因此 script 的位置很重要，在实际使用过程中遵循以下两个原则：</p><p>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。<br>JavaScript 置后：我们通常把JS代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。</p><p>也就是说：首屏渲染越快，就越不应该在首屏的时候加载 JS 文件，这也就是建议将 <code>script</code> 标签放到 <code>body</code> 标签底部，或者给 <code>script</code> 标签添加 <code>defer/async</code> 属性的原因。</p><h2 id="为什么操作-DOM-慢"><a href="#为什么操作-DOM-慢" class="headerlink" title="为什么操作 DOM 慢"></a>为什么操作 DOM 慢</h2><ol><li>涉及 JS 引擎和渲染引擎两个线程间的通信，损耗性能。</li><li>操作 DOM 可能会重复回流，加剧性能损耗。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP 三次握手四次挥手</title>
    <link href="/2020/11/20/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <url>/2020/11/20/TCP%20%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="TCP-的概述"><a href="#TCP-的概述" class="headerlink" title="TCP 的概述"></a>TCP 的概述</h1><p>TCP 把连接作为最基本的对象，每一条 TCP 连接都有两个端点，这种端点我们叫作套接字（socket），它的定义为端口号拼接到 IP 地址即构成了套接字，例如，若 IP 地址为192.3.4.16 而端口号为 80，那么得到的套接字为192.3.4.16:80。</p><p><strong>常用的熟知端口号</strong></p><table><thead><tr><th align="center">应用程序</th><th align="center">FTP</th><th align="center">TFTP</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">HTTP/HTTPS</th><th align="center">SSH</th><th align="center">MYSQL</th></tr></thead><tbody><tr><td align="center">熟知端口</td><td align="center">21,20</td><td align="center">69</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">80/443</td><td align="center">22</td><td align="center">3306</td></tr><tr><td align="center">传输层协议</td><td align="center">TCP</td><td align="center">UDP</td><td align="center">TCP</td><td align="center">TCP</td><td align="center">UDP</td><td align="center">TCP</td><td align="center">TCP</td><td align="center">TCP</td></tr></tbody></table><h1 id="TCP-的特性"><a href="#TCP-的特性" class="headerlink" title="TCP 的特性"></a>TCP 的特性</h1><ul><li>TCP 提供一种<strong>面向连接的、可靠的</strong>字节流服务</li><li>在一个 TCP 连接中，仅有两方进行彼此通信。广播和多播不能用于 TCP</li><li>TCP 使用校验和，确认和重传机制来保证可靠传输</li><li>TCP 给数据分节进行排序，并使用累积确认保证数据的顺序不变和非重复</li><li>TCP 使用滑动窗口机制来实现流量控制，通过动态改变窗口的大小进行拥塞控制</li></ul><p><strong>注意</strong>：TCP 并不能保证数据一定会被对方接收到，因为这是不可能的。TCP 能够做到的是，如果有可能，就把数据递送到接收方，否则就（通过放弃重传并且中断连接这一手段）通知用户。因此准确说 TCP 也不是 100% 可靠的协议，它所能提供的是数据的可靠递送或故障的可靠通知。</p><h1 id="TCP-报文首部"><a href="#TCP-报文首部" class="headerlink" title="TCP 报文首部"></a>TCP 报文首部</h1><ol><li><p><strong>源端口</strong>和<strong>目的端口</strong>，各占2个字节，分别写入源端口和目的端口；</p></li><li><p><strong>序号</strong>，占4个字节，TCP 连接中传送的字节流中的每个字节都按顺序编号。</p><blockquote><p>例如，一段报文的序号字段值是 301 ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从 401 开始；</p></blockquote></li><li><p><strong>确认号</strong>，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。</p><blockquote><p>例如，B 收到了 A 发送过来的报文，其序列号字段是 501，而数据长度是 200字节，这表明 B 正确的收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给A 的确认报文段中把确认号置为 701；</p></blockquote></li><li><p><strong>数据偏移</strong>，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；</p></li><li><p><strong>保留</strong>，占6位，保留今后使用，但目前应都位0；</p></li><li><p>紧急<code>URG</code>，当 <code>URG=1</code>，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；</p></li><li><p>确认<code>ACK</code>，仅当<code>ACK=1</code>时，确认号字段才有效。TCP 规定，在连接建立后所有报文的传输都必须把 <code>ACK</code> 置1；</p></li><li><p>推送<code>PSH</code>，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将 <code>PSH=1</code>；</p></li><li><p>复位<code>RST</code>，当 <code>RST=1</code>，表明 TCP 连接中出现严重差错，必须释放连接，然后再重新建立连接；</p></li><li><p>同步<code>SYN</code>，在连接建立时用来同步序号。</p><blockquote><p>当 <code>SYN=1</code>，<code>ACK=0</code>，表明是连接请求报文，若同意连接，则响应报文中应该使 <code>SYN=1</code>，<code>ACK=1</code>；</p></blockquote></li><li><p>终止<code>FIN</code>，用来释放连接。</p><blockquote><p>当 <code>FIN=1</code>，表明此报文的发送方的数据已经发送完毕，并且要求释放；</p></blockquote></li><li><p><strong>窗口</strong>，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；</p></li><li><p><strong>检验和</strong>，占2字节，校验首部和数据这两部分；</p></li><li><p><strong>紧急指针</strong>，占2字节，指出本报文段中的紧急数据的字节数；</p></li><li><p><strong>选项</strong>，长度可变，定义一些其他的可选的参数。</p></li></ol><h1 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h1><blockquote><p>拟人化场景解释 TCP 三次握手和四次挥手：</p></blockquote><p>三次握手：</p><p>Browser：先告诉服务器 “我要开始发起请求了，你那边可以吗？”<br>Server：服务器回复浏览器 “没问题，你发吧！”<br>Browser：告诉服务器 “好的，那我开始发了。”</p><p>四次挥手：</p><p>Browser：先告诉服务器 “我数据都发完了，你可以关闭连接了。”<br>Server：回复浏览器 “我先看看我这边还有没有数据没传完。”<br>Server：确认过以后，再次回复浏览器 “我这边数据传输完成了，你可以关闭连接了。”<br>Browser：告诉服务器 “好的，那我真的关闭了。你不用回复我了。”</p><p>Browser 又等了 2MSL，确认确实没有再收到请求了，才会真的关闭TCP连接。</p><h1 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h1><blockquote><p>最开始的时候客户端和服务器都是处于 CLOSED 状态。主动打开连接的为客户端，被动打开连接的是服务器</p></blockquote><p>所谓三次握手 (Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。</p><p><img src="/images/3handshakes.gif" alt="3handshakes"><br>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p><ul><li><p>第一次握手( <code>SYN=1</code>，<code>seq=x</code> ):</p><p>客户端发送一个 TCP 的 <code>SYN</code> 标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里。</p><p>发送完毕后，客户端进入 <strong>SYN_SEND</strong> 状态。</p></li><li><p>第二次握手( <code>SYN=1</code>， <code>ACK=1</code>，<code>seq=y</code>， <code>ACKnum=x+1</code> ):</p><p>服务器发回确认包(ACK) 应答。即 <code>SYN</code> 标志位和 <code>ACK</code> 标志位均为 1。服务器端选择自己 <code>ISN</code> 序列号，放到 <code>Seq</code> 域里，同时将确认序号 (Acknowledgement Number) 设置为客户的 <code>ISN</code> 加1，即 X+1。 发送完毕后，服务器端进入 <strong>SYN_RCVD</strong> 状态。</p></li><li><p>第三次握手( <code>ACK=1</code>，<code>ACKnum=y+1</code> )</p><p>客户端再次发送确认包(ACK)，<code>SYN</code> 标志位为 0，<code>ACK</code> 标志位为1，并且把服务器发来 <code>ACK</code> 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写<code>ISN</code>的+1</p><p>发送完毕后，客户端进入 <strong>ESTABLISHED</strong> 状态，当服务器端接收到这个包时，也进入 <strong>ESTABLISHED</strong> 状态，TCP 握手结束。</p></li></ul><h1 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h1><p>TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。</p><p>客户端或服务器均可主动发起挥手动作。</p><p><img src="/images/4handshakes.gif" alt="4handshakes"></p><ul><li><p>第一次挥手( <code>FIN=1</code>，<code>seq=x</code> )</p><p>假设客户端想要关闭连接，客户端发送一个 <code>FIN</code> 标志位置为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。</p><p>发送完毕后，客户端进入 <strong>FIN_WAIT_1</strong> 状态。</p></li><li><p>第二次挥手( <code>ACK=1</code>，<code>ACKnum=x+1</code> )</p><p>服务器端确认客户端的 <code>FIN</code> 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。</p><p>发送完毕后，服务器端进入 <strong>CLOSE_WAIT</strong> 状态，客户端接收到这个确认包之后，进入 <strong>FIN_WAIT_2</strong> 状态，等待服务器端关闭连接。</p></li><li><p>第三次挥手( <code>FIN=1</code>，<code>seq=y</code> )</p><p>服务器端准备好关闭连接时，向客户端发送结束连接请求，<code>FIN</code> 置为1。</p><p>发送完毕后，服务器端进入 <strong>LAST_ACK</strong> 状态，等待来自客户端的最后一个 <code>ACK</code>。</p></li><li><p>第四次挥手( <code>ACK=1</code>，<code>ACKnum=y+1</code> )</p><p>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 <strong>TIME_WAIT</strong> 状态，等待可能出现的要求重传的 <code>ACK</code> 包。</p><p>服务器端接收到这个确认包之后，关闭连接，进入 <strong>CLOSED</strong> 状态。</p></li></ul><p>客户端等待了两个最大段生命周期（2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 <code>ACK</code> ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 <strong>CLOSED</strong> 状态。</p><h1 id="三次握手的过程为什么是三次而不是两次、四次？"><a href="#三次握手的过程为什么是三次而不是两次、四次？" class="headerlink" title="三次握手的过程为什么是三次而不是两次、四次？"></a>三次握手的过程为什么是三次而不是两次、四次？</h1><h2 id="为什么不是两次？"><a href="#为什么不是两次？" class="headerlink" title="为什么不是两次？"></a>为什么不是两次？</h2><blockquote><p>为什么TCP客户端最后还要发送一次确认呢？</p></blockquote><p>一句话，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，<strong>客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了</strong>，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。</p><p>此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h2 id="为什么不是四次？"><a href="#为什么不是四次？" class="headerlink" title="为什么不是四次？"></a>为什么不是四次？</h2><p>可以是四次，但是三次就可以安全建立连接，四次会浪费资源不必要。</p><h1 id="为什么是四次挥手而不是三次？"><a href="#为什么是四次挥手而不是三次？" class="headerlink" title="为什么是四次挥手而不是三次？"></a>为什么是四次挥手而不是三次？</h1><blockquote><p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？</p></blockquote><p>建立连接的时候， 服务器在 <strong>LISTEN</strong> 状态下，收到建立连接请求的 <code>SYN</code> 报文后，把 <code>ACK</code> 和 <code>SYN</code> 放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的 <code>FIN</code> 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 <code>FIN</code> 报文给对方来表示同意现在关闭连接，因此，己方 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而导致多了一次。</p><h2 id="为什么客户端最后还要等待2MSL？"><a href="#为什么客户端最后还要等待2MSL？" class="headerlink" title="为什么客户端最后还要等待2MSL？"></a>为什么客户端最后还要等待2MSL？</h2><p>MSL 是 Maximum Segment Lifetime 的英文缩写，可译为“最长报文段寿命”，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。TCP 允许不同的实现可以设置不同的 MSL 值。</p><p>第一，保证客户端发送的最后一个 <code>ACK</code> 报文能够到达服务器，因为这个 <code>ACK</code> 报文可能丢失，<strong>站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次</strong>，而客户端就能在这个 2MSL 时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个 2MSL 时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h1 id="TCP-KeepAlive"><a href="#TCP-KeepAlive" class="headerlink" title="TCP KeepAlive"></a>TCP KeepAlive</h1><p>TCP 的连接，实际上是一种纯软件层面的概念，在物理层面并没有“连接”这种概念。</p><p>TCP 通信双方建立交互的连接，但是并不是一直存在数据交互，有些连接会在数据交互完毕后，主动释放连接，而有些不会。</p><p>在长时间无数据交互的时间段内，交互双方都有可能出现掉电、死机、异常重启等各种意外，当这些意外发生之后，这些 TCP 连接并未来得及正常释放，在软件层面上，连接的另一方并不知道对端的情况，它会一直维护这个连接，长时间的积累会导致非常多的半打开连接，造成端系统资源的消耗和浪费，为了解决这个问题，在传输层可以利用 TCP 的 KeepAlive 机制实现来实现。主流的操作系统基本都在内核里支持了这个特性。</p><p>TCP KeepAlive 的基本原理是，隔一段时间给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接。</p>]]></content>
    
    
    
    <tags>
      
      <tag>TCP</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的继承</title>
    <link href="/2020/11/16/JavaScript%20%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <url>/2020/11/16/JavaScript%20%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-中的继承"><a href="#JavaScript-中的继承" class="headerlink" title="JavaScript 中的继承"></a>JavaScript 中的继承</h1><p>在 JavaScript 中的继承可以以是否使用<code>Object.create</code>大致分为两类：</p><p><img src="/images/js-extends.jpg" alt="js-extends">  </p><p>不使用<code>Object.create</code>：</p><ol><li>原型链继承</li><li>构造函数继承</li><li>组合继承</li></ol><p>使用<code>Object.create</code>：</p><ol start="4"><li>原型式继承</li><li>寄生式继承</li><li>寄生组合继承</li></ol><p>以及ES6 Class 继承</p><h1 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create"></a>Object.create</h1><p><code>Object.create()</code> 方法创建一个新对象，使用现有的对象来提供新创建的对象的 <code>__proto__</code>。</p><p>语法：</p><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.create(proto，[propertiesObject])</code></pre><p>参数:</p><ul><li><p><code>proto</code></p><p> 新创建对象的原型对象。</p></li><li><p><code>propertiesObject</code></p><p>可选。需要传入一个对象，该对象的属性类型参照<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties"><code>Object.defineProperties()</code></a>的第二个参数。</p></li></ul><p>返回值:</p><p>一个新对象，带着指定的原型对象和属性。</p><p><code>Object.create()</code>的 Polyfill 方法：</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  F.prototype = o  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()&#125;<span class="hljs-comment">//等价于</span><span class="hljs-built_in">Object</span>.create(o)</code></pre><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>首先，先准备一个父类：</p><pre><code class="hljs js"><span class="hljs-comment">// 定义一个动物类</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Animal</span> (<span class="hljs-params">name</span>) </span>&#123;  <span class="hljs-comment">// 属性</span>  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Animal&#x27;</span>  <span class="hljs-comment">// 实例方法</span>  <span class="hljs-built_in">this</span>.sleep = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在睡觉！&#x27;</span>)  &#125;&#125;<span class="hljs-comment">// 原型方法</span>Animal.prototype.eat = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">food</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name + <span class="hljs-string">&#x27;正在吃：&#x27;</span> + food)&#125;;</code></pre><h1 id="1、原型链继承"><a href="#1、原型链继承" class="headerlink" title="1、原型链继承"></a>1、原型链继承</h1><blockquote><p>核心： 将父类的实例作为子类的原型</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params"></span>)</span>&#123; &#125;Cat.prototype = <span class="hljs-keyword">new</span> Animal()Cat.prototype.name = <span class="hljs-string">&#x27;cat&#x27;</span><span class="hljs-comment">//　Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<span class="hljs-built_in">console</span>.log(cat.name);cat.eat(<span class="hljs-string">&#x27;fish&#x27;</span>)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">//true </span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">//true </span></code></pre><p>特点：</p><ol><li>非常纯粹的继承关系，实例是子类的实例，也是父类的实例</li><li>父类新增原型方法/原型属性，子类都能访问到</li><li>简单，易于实现</li></ol><p>缺点：</p><ol><li>要想为子类新增属性和方法，必须要在<code>new Animal()</code>这样的语句之后执行，不能放到构造器中<br>无法实现多继承</li><li>来自原型对象的引用属性是所有实例共享的</li><li>创建子类实例时，无法向父类构造函数传参</li></ol><h1 id="2、构造继承"><a href="#2、构造继承" class="headerlink" title="2、构造继承"></a>2、构造继承</h1><blockquote><p>核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;  Animal.call(<span class="hljs-built_in">this</span>)  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<span class="hljs-built_in">console</span>.log(cat.name)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span></code></pre><p>特点：</p><ol><li>解决了「原型链继承」中，子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多继承（call多个父类对象） </li></ol><p>缺点：</p><ol><li>实例并不是父类的实例，只是子类的实例</li><li>只能继承父类的实例属性和方法，不能继承原型属性/方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能</li></ol><h1 id="3、组合继承"><a href="#3、组合继承" class="headerlink" title="3、组合继承"></a>3、组合继承</h1><blockquote><p>核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用</p></blockquote><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>)</span>&#123;  Animal.call(<span class="hljs-built_in">this</span>)  <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;Cat.prototype = <span class="hljs-keyword">new</span> Animal()<span class="hljs-comment">//组合继承也是需要修复构造函数指向的。</span>Cat.prototype.constructor = Cat<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat()<span class="hljs-built_in">console</span>.log(cat.name)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span></code></pre><p>特点：</p><ol><li>弥补了「构造继承」的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法</li><li>既是子类的实例，也是父类的实例</li><li>不存在引用属性共享问题</li><li>可传参</li><li>函数可复用</li></ol><p>缺点：</p><ol><li>调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）</li></ol><h1 id="4、原型式继承"><a href="#4、原型式继承" class="headerlink" title="4、原型式继承"></a>4、原型式继承</h1><blockquote><p>核心：原型式继承的 object方法 本质上是对参数对象的一个浅复制。</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">//利用一个空对象作为中介，将某个对象直接赋值给空对象构造函数的原型。</span><span class="hljs-comment">//就是 ES5 Object.create 的模拟实现，将传入的对象作为创建的对象的原型。</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span>(<span class="hljs-params">o</span>)</span>&#123;  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>)</span>&#123;&#125;  F.prototype = o  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()&#125;<span class="hljs-keyword">var</span> person = &#123;  name: <span class="hljs-string">&quot;Nicholas&quot;</span>,  friends: [<span class="hljs-string">&quot;Shelby&quot;</span>, <span class="hljs-string">&quot;Court&quot;</span>, <span class="hljs-string">&quot;Van&quot;</span>]&#125;<span class="hljs-keyword">var</span> anotherPerson = object(person)anotherPerson.name = <span class="hljs-string">&quot;Greg&quot;</span>anotherPerson.friends.push(<span class="hljs-string">&quot;Rob&quot;</span>)<span class="hljs-keyword">var</span> yetAnotherPerson = object(person)yetAnotherPerson.name = <span class="hljs-string">&quot;Linda&quot;</span>yetAnotherPerson.friends.push(<span class="hljs-string">&quot;Barbie&quot;</span>)alert(person.friends);  <span class="hljs-comment">//&quot;Shelby,Court,Van,Rob,Barbie&quot;</span><span class="hljs-comment">//注意：修改anotherPerson.name的值，yetAnotherPerson.name的值并未发生改变，并不是因为anotherPerson 和 yetAnotherPerson 有独立的 name 值，而是因为 anotherPerson.name = &quot;Greg&quot;，给anotherPerson添加了 name 值，并非修改了原型上的 name 值。</span></code></pre><p>缺点：</p><ol><li>包含引用类型的属性值始终都会共享相应的值，这点跟原型链继承一样。</li></ol><h1 id="5、寄生继承"><a href="#5、寄生继承" class="headerlink" title="5、寄生继承"></a>5、寄生继承</h1><blockquote><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 寄生继承</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>) </span>&#123;    Animal.call(<span class="hljs-built_in">this</span>)    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<span class="hljs-comment">// function object(o) &#123;</span><span class="hljs-comment">//     function F()&#123;&#125;</span><span class="hljs-comment">//     F.prototype = o</span><span class="hljs-comment">//     return new F()</span><span class="hljs-comment">// &#125;</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createAnother</span>(<span class="hljs-params">original</span>) </span>&#123;    <span class="hljs-comment">// 通过调用函数创建一个新对象</span>    <span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">Object</span>.create(original)    <span class="hljs-comment">// 以某种方式来增强这个对象</span>    clone.sayHi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        alert(<span class="hljs-string">&quot;hi&quot;</span>)    &#125;clone.name = <span class="hljs-string">&#x27;Tom&#x27;</span>    <span class="hljs-keyword">return</span> clone&#125;<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = createAnother(<span class="hljs-keyword">new</span> Animal())<span class="hljs-built_in">console</span>.log(cat.name)cat.sayHi()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat)</code></pre><p>特点：</p><ol><li>可以增强子例对象功</li><li>例子中使用的 Object.create(original) 函数不是必须的，可以使用任何能够返回新对象的函数都适用于此模式</li></ol><p>缺点：</p><ol><li>不能做到函数复用而降低效率</li><li>只是借用了一个没有属性子类实例作为原型，并没有真正的意义上的子类，constructor 依然指向父类</li></ol><h2 id="6、寄生组合继承"><a href="#6、寄生组合继承" class="headerlink" title="6、寄生组合继承"></a>6、寄生组合继承</h2><blockquote><p>核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 寄生组合继承</span><span class="hljs-comment">// 该实现没有修复constructor</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">name</span>) </span>&#123;    Animal.call(<span class="hljs-built_in">this</span>)    <span class="hljs-built_in">this</span>.name = name || <span class="hljs-string">&#x27;Tom&#x27;</span>&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Class&#125;</span> </span>Father 父类构造函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Class&#125;</span> </span>Son 子类构造函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> </span>子类实例 </span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parasiteExtend</span>(<span class="hljs-params">Father, Son</span>) </span>&#123;    <span class="hljs-comment">// 没有实例方法的临时类</span>    <span class="hljs-comment">// let Super = function () &#123;&#125;</span>    <span class="hljs-comment">// Super.prototype = Father.prototype</span><span class="hljs-comment">// Son.prototype = new Super()</span>    Son.prototype = <span class="hljs-built_in">Object</span>.create(Father.prototype)    <span class="hljs-comment">// 修复constructor</span>    Son.prototype.constructor = Son    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Son()&#125;<span class="hljs-comment">// Test Code</span><span class="hljs-keyword">var</span> cat = parasiteExtend(Animal,Cat)<span class="hljs-built_in">console</span>.log(cat.name)cat.sleep()<span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal) <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat) <span class="hljs-comment">// true</span></code></pre><p>特点：</p><ol><li>堪称完美</li></ol><p>缺点：</p><ol><li>实现较为复杂</li></ol><h1 id="ES6-Class-extends"><a href="#ES6-Class-extends" class="headerlink" title="ES6 Class extends"></a>ES6 Class extends</h1><blockquote><p>核心： ES6继承的结果和寄生组合继承相似，本质上，ES6继承是一种语法糖。</p></blockquote><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(name, gender) &#123;    <span class="hljs-built_in">super</span>(name)    <span class="hljs-built_in">this</span>.gender = gender  &#125;  like() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cat like fish&#x27;</span>)  &#125;&#125;<span class="hljs-comment">//　Test Code</span><span class="hljs-keyword">var</span> cat = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&#x27;Tom&#x27;</span>,<span class="hljs-string">&#x27;Man&#x27;</span>)<span class="hljs-built_in">console</span>.log(cat.name)<span class="hljs-comment">//Tom</span><span class="hljs-built_in">console</span>.log(cat.gender)<span class="hljs-comment">//Man</span>cat.eat(<span class="hljs-string">&#x27;fish&#x27;</span>)<span class="hljs-comment">//Tom正在吃fish</span>cat.sleep()<span class="hljs-comment">//我的name是Tom</span>cat.like()<span class="hljs-comment">//cat like fish</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Animal)<span class="hljs-comment">//true</span><span class="hljs-built_in">console</span>.log(cat <span class="hljs-keyword">instanceof</span> Cat)<span class="hljs-comment">//true</span></code></pre><p>寄生组合继承是先创建子类实例 this 对象，然后再对其增强；</p><p>而 ES6 先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用super方法），然后再用子类的构造函数修改this。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">A</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-built_in">super</span>();  &#125;&#125;</code></pre><p>ES6 实现继承的具体原理：</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-built_in">Object</span>.setPrototypeOf = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj, proto</span>) </span>&#123;  obj.__proto__ = proto;  <span class="hljs-keyword">return</span> obj;&#125;<span class="hljs-comment">// B 的实例继承 A 的实例</span><span class="hljs-built_in">Object</span>.setPrototypeOf(B.prototype, A.prototype);<span class="hljs-comment">// B 继承 A 的静态属性</span><span class="hljs-built_in">Object</span>.setPrototypeOf(B, A);</code></pre><p>ES6 继承与 ES5 继承的异同：<br>相同点：</p><ul><li>本质上ES6继承是ES5继承的语法糖</li></ul><p>不同点：</p><ul><li>ES6 继承中子类的构造函数的原型链指向父类的构造函数，ES5 中使用的是构造函数复制，没有原型链指向。</li><li>ES6 子类实例的构建，基于父类实例，ES5 中不是。</li></ul><h1 id="ES5-ES6-的继承除了写法以外还有什么区别？"><a href="#ES5-ES6-的继承除了写法以外还有什么区别？" class="headerlink" title="ES5/ES6 的继承除了写法以外还有什么区别？"></a>ES5/ES6 的继承除了写法以外还有什么区别？</h1><ol><li><code>class</code> 声明会提升，但不会初始化赋值。<code>Foo</code> 进入暂时性死区，类似于 <code>let</code>、<code>const</code> 声明变量。</li><li><code>class</code> 声明内部会启用严格模式。</li><li><code>class</code> 的所有方法（包括静态方法和实例方法）都是不可枚举的。</li><li><code>class</code> 的所有方法（包括静态方法和实例方法）都没有原型对象 prototype，所以也没有<code>[[construct]]</code>，不能使用 <code>new</code> 来调用。</li><li>必须使用 <code>new</code> 调用 <code>class</code>。</li><li><code>class</code> 内部无法重写类名</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的渲染机制</title>
    <link href="/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器组成"><a href="#浏览器组成" class="headerlink" title="浏览器组成"></a>浏览器组成</h1><p>浏览器主要由7个部分组成：</p><ul><li>用户界面（User Interface）：定义了一些常用的浏览器组件，比如地址栏，返回、书签等等</li><li>数据持久化（Data Persistence）：指浏览器的 cookie、localStorage 等组件</li><li>浏览器引擎（Browser engine）：平台应用的相关接口，在用户界面和呈现引擎之间传送指令。</li><li>渲染引擎（Rendering engine）：处理 HTML、CSS 的解析与渲染</li><li>JavaScript解释器（JavaScript Interpreter）：解析和执行 JavaScript 代码</li><li>用户界面后端（UI Backend）：指浏览器的的图形库等</li><li>网络（Networking）：用于网络调用，比如 HTTP 请求</li></ul><h1 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h1><p>浏览器内核分为两部分：渲染引擎 (layout engineer 或 Rendering Engine) 和 JavaScript 引擎</p><p>渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机</p><p>JavaScript 引擎：负责解析和执行 JavaScript 来实现网页的动态效果 浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核，最开始渲染引擎和  JavaScript  引擎并没有区分的很明确，后来 JavaScript 引擎越来越独立，内核就倾向于只指渲染引擎</p><blockquote><p>常见的浏览器内核：Trident（IE）、Gecko（火狐）、Blink（Chrome、Opera）、Webkit（Safari）</p></blockquote><h1 id="渲染引擎简介"><a href="#渲染引擎简介" class="headerlink" title="渲染引擎简介"></a>渲染引擎简介</h1><p>Firefox 使用的是 Gecko，这是 Mozilla 公司“自制”的渲染引擎。而 Safari 和 Chrome(28版本以前) 浏览器使用的都是 Webkit。</p><blockquote><p>2013年7月10日发布的 Chrome 28 版本中，Chrome浏览器开始正式使用 Blink 内核。所以，Webkit 已经成为了Chrome浏览器的前内核。</p></blockquote><h1 id="浏览器渲染页面的过程"><a href="#浏览器渲染页面的过程" class="headerlink" title="浏览器渲染页面的过程"></a>浏览器渲染页面的过程</h1><p>从耗时的角度，浏览器请求、加载、渲染一个页面，时间花在下面五件事情上：</p><ol><li>DNS 查询</li><li>TCP 连接</li><li>HTTP 请求即响应</li><li>服务器响应</li><li>客户端渲染：浏览器对内容的渲染</li></ol><h1 id="浏览器渲染机制"><a href="#浏览器渲染机制" class="headerlink" title="浏览器渲染机制"></a>浏览器渲染机制</h1><ol><li>处理 HTML 标记并构建 DOM 树。</li><li>处理 CSS 标记并构建 CSSOM 树。</li><li>将 DOM 与 CSSOM 合并成一个渲染树。</li><li>根据渲染树来布局，以计算每个节点的几何信息。</li><li>将各个节点绘制到屏幕上。</li></ol><h2 id="解析-HTML-成-DOM-树"><a href="#解析-HTML-成-DOM-树" class="headerlink" title="解析 HTML 成 DOM 树"></a>解析 HTML 成 DOM 树</h2><p>这个解析过程大概可以分为几个步骤：</p><blockquote><p>字节（Byte）→ 字符串（Characters）→ Tokens →节点（Nodes）→ DOM</p></blockquote><p>第一步：浏览器从磁盘或网络读取 HTML 的原始字节，也就是传输的 0 和 1这样的字节数据，并根据文件的指定编码（例如 UTF-8）将它们转换成字符串。</p><p>第二步：将字符串转换成 Token。例如：“”、“” 等。Token 中会标识出当前 Token 是“开始标签”或是“结束标签”亦或是“文本”等信息。</p><p>第三步：在每个 Token 被生成后，会立刻消耗这个 Token 创建出节点对象，因此在构建 DOM 的过程中，不是等待所有的 Token 都生成后才去构建 DOM，而是一边生成 Token 一边消耗来生成节点对象。</p><blockquote><p>注意：带有结束标签标识的 Token 不会创建节点对象 </p></blockquote><p>第四步：通过“开始标签”与“结束标签”来识别并关联节点之间的关系。当所有 Token 都生成并消耗完毕后，我们就得到了一颗完整的 DOM 树。</p><h2 id="构建-CSSOM"><a href="#构建-CSSOM" class="headerlink" title="构建 CSSOM"></a>构建 CSSOM</h2><p>解析 CSS 构建 CSSOM 的过程和构建 DOM 的过程非常的相似。当浏览器接收到一段 CSS，浏览器首先要做的是识别出 Token，然后构建节点并生成 CSSOM</p><blockquote><p>字节（Byte）→ 字符串（Characters）→ Tokens →节点（Nodes）→ CSSOM</p></blockquote><p>节点中样式可以通过继承得到，也可以自己设置，因此在构建的过程中浏览器得递归 CSSOM 树，然后确定具体的元素到底是什么样式。</p><p>为了 CSSOM 的完整性，也只有等构建完毕才能进入到下一个阶段，哪怕 DOM 已经构建完，它也得等 CSSOM，然后才能进入下一个阶段。</p><p>CSS 匹配 HTML 元素是一个相当复杂和有性能问题的事情</p><p>所以，DOM 树要小，CSS 尽量用 id 和 class，千万不要过渡层叠下去。所以，CSS 的加载速度与构建 CSSOM 的速度将直接影响首屏渲染速度，因此在默认情况下 CSS 被视为阻塞渲染的资源</p><h2 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h2><p>当我们生成 DOM 树和 CSSOM 树后，我们需要将这两颗树合并成渲染树，在构建渲染树的过程中浏览器需要做如下工作：</p><ul><li>从 DOM 树的根节点开始遍历每个可见节点。</li><li>有些节点不可见（例如脚本 Token、元 Token等），因为它们不会体现在渲染输出中，所以会被忽略。</li><li>某些节点被 CSS 隐藏，因此在渲染树中也会被忽略。例如某些节点设置了 display: none 属性。</li><li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们</li></ul><h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p>在渲染的过程中，遇到一个 script 标记时，就会停止渲染，去请求脚本文件并执行脚本文件，因为浏览器渲染和 JavaScript 执行共用一个线程，而且这里必须是单线程操作，多线程会产生渲染 DOM 冲突。</p><p>JavaScript 的加载、解析与执行会严重阻塞 DOM 的构建。只有等到脚本文件执行完毕，才会去继续构建 DOM。</p><p>JavaScript 不单会阻塞 DOM 构建，还会导致 CSSOM 也阻塞 DOM 的构建，如果 JavaScript 脚本还操作了CSSOM，而正好这个 CSSOM 还没有下载和构建，浏览器甚至会延迟脚本执行和构建 DOM，直至完成其 CSSOM的下载和构建，然后再执行 JavaScript，最后在继续构建 DOM。</p><p>因此 script 的位置很重要，在实际使用过程中遵循以下两个原则：</p><ul><li>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。</li><li>JavaScript 置后：我们通常把 JS代码放到页面底部，且 JavaScript 应尽量少影响 DOM 的构建。</li></ul><h2 id="布局与绘制"><a href="#布局与绘制" class="headerlink" title="布局与绘制"></a>布局与绘制</h2><p>浏览器拿到渲染树后，就会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，通常这一行为也被称为“自动重排”。</p><p>布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小，所有相对测量值都将转换为屏幕上的绝对像素。这一过程也可称为回流</p><p>布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。</p><h1 id="性能优化策略"><a href="#性能优化策略" class="headerlink" title="性能优化策略"></a>性能优化策略</h1><h2 id="回流-reflow-与-重绘-repaint"><a href="#回流-reflow-与-重绘-repaint" class="headerlink" title="回流(reflow) 与 重绘(repaint)"></a>回流(reflow) 与 重绘(repaint)</h2><p>当元素的样式发生变化时，浏览器需要触发更新，重新绘制元素。这个过程中，有两种类型的操作，即重绘与回流。</p><ul><li><p>重绘(repaint): 当元素样式的改变不影响布局时，浏览器将使用重绘对元素进行更新，此时由于只需要UI层面的重新像素绘制，因此损耗较少</p></li><li><p>回流(reflow): 当元素的尺寸、结构或触发某些属性时，浏览器会重新渲染页面，称为回流。此时，浏览器需要重新经过计算，计算后还需要重新页面布局，因此是较重的操作。</p></li></ul><p>会触发回流的操作:</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素的位置发生变化</li><li>元素的尺寸发生变化（包括外边距、内边框、边框大小、高度和宽度等）</li><li>内容发生变化，比如文本变化或图片被另一个不同尺寸的图片所替代。</li><li>页面一开始渲染的时候（这肯定避免不了）</li><li>浏览器的窗口尺寸变化（因为回流是根据视口的大小来计算元素的位置和大小的</li><li>注意：回流一定会触发重绘，而重绘不一定会回流,重绘的开销较小，回流的代价较高</li></ul><p>因此为了减少性能优化，我们可以尽量避免回流或者重绘操作 CSS</p><ul><li><p>避免使用table布局</p></li><li><p>将动画效果应用到 position 属性为 absolute 或 fixed 的元素上</p></li></ul><p>JavaScript</p><ul><li>避免频繁操作样式，可汇总后统一 一次修改</li><li>尽量使用class进行样式修改</li><li>减少dom的增删次数，可使用 字符串 或者 documentFragment 一次性插入</li><li>极限优化时，修改样式可将其 display: none 后修改</li><li>避免多次触发上面提到的那些会触发回流的方法，可以的话尽量用变量存住</li></ul><h1 id="探讨-requestAnimationFrame"><a href="#探讨-requestAnimationFrame" class="headerlink" title="探讨 requestAnimationFrame"></a>探讨 requestAnimationFrame</h1><p>在 JavaScript 中，我们可以使用 <code>setTimeout</code> 和 <code>setIntarval</code> 实现动画，但是 H5 的出现，让我们又多了两种实现动画的方式，分别是 CSS 动画（<code>transition</code>、<code>animation</code>）和 H5 的<code>canvas</code> 实现。</p><p>由于 JavaScript 是单线程的，所以定时器的实现是在当前任务队列完成后再执行定时器的回调的，假如当前队列任务执行时间大于定时器设置的延迟时间，那么定时器就不是那么可靠了。</p><p>所以，H5 还提供了一个专门用于请求动画的 API，让 DOM 动画、canvas 动画、svg 动画、webGL 动画等有一个专门的刷新机制。</p><h2 id="是什么？"><a href="#是什么？" class="headerlink" title="是什么？"></a>是什么？</h2><p>动画是由浏览器按照一定的频率一帧一帧的绘制的，由 CSS 实现的动画的优势就是浏览器知道动画的开始及每一帧的循环间隔，能够在恰当的时间刷新 UI，给用户一种流畅的体验。</p><p>而<code>setInterval</code>或<code>setTimeout</code>实现的 JavaScript 动画就没有这么可靠了，因为浏览器压根就无法保证每一帧渲染的时间间隔。</p><p>一般情况下，每秒平均刷新次数能够达到 60帧，就能够给人流畅的体验，即每过 1000/60 毫秒渲染新一帧即可，这一点单靠定时器是无法保证的。 为此，<code>requestAnimationFrame</code> 应运而生，其作用就是让浏览器流畅的执行动画效果。</p><p>可以将其理解为专门用来实现动画效果的 API，通过这个 API 可以告诉浏览器某个 JavaScript 代码要执行动画，浏览器收到通知后，则会运行这些代码的时候进行优化，实现流畅的效果，而不再需要开发人员烦心刷新频率的问题了。</p><p><code>requestAnimationFrame</code> 方法会告诉浏览器希望执行动画并请求浏览器在下一次重绘之前调用回调函数来更新动画。</p><pre><code class="hljs js"><span class="hljs-built_in">window</span>.requestAnimationFrame(callback)</code></pre><ul><li>callback：下一次重绘之前更新动画帧所调用的函数，<strong>callback仅有一个参数，为DOMHighResTimeStamp参数，表示requestAnimationFrame()开始执行回调函数的时刻。</strong></li><li>返回值：一个 long 类型整数，唯一标志元组在列表中的位置，你可以传这个值给<code>cancelAnimationFrame()</code> 以取消动画。</li></ul><p>在使用和实现上， <code>requestAnimationFrame</code> 与 <code>setTimeout</code> 类似。举个例子：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>;<span class="hljs-keyword">let</span> rafId = <span class="hljs-literal">null</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 回调函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param </span>time requestAnimationFrame 调用该函数时，自动传入的一个时间</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">requestAnimation</span>(<span class="hljs-params">time</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(time); <span class="hljs-comment">// 打印执行requestAnimation函数的时刻</span>  <span class="hljs-comment">// 动画没有执行完，则递归渲染</span>  <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">5</span>) &#123;    count++;    <span class="hljs-comment">// 渲染下一帧</span>    rafId = <span class="hljs-built_in">window</span>.requestAnimationFrame(requestAnimation);  &#125;&#125;<span class="hljs-comment">// 渲染第一帧</span><span class="hljs-built_in">window</span>.requestAnimationFrame(requestAnimation);</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器的缓存机制</title>
    <link href="/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/11/10/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="headerlink" title="浏览器缓存机制"></a>浏览器缓存机制</h1><blockquote><p>浏览器缓存作为性能优化的重要一环，对于前端而言，重要性不言而喻。</p></blockquote><p>缓存可以说是性能优化中简单高效的一种优化方式了。</p><p>一个优秀的缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。</p><p>对于一个数据请求来说，可以分为：</p><ol><li><p>发起网络请求</p></li><li><p>后端处理</p></li><li><p>浏览器响应</p></li></ol><p>三个步骤。浏览器缓存可以帮助我们在第一和第三步骤中优化性能。</p><p>比如说直接使用缓存而不发起请求，或者发起了请求但后端存储的数据和前端一致，那么就没有必要再将数据回传回来，这样就减少了响应数据。</p><h1 id="缓存位置"><a href="#缓存位置" class="headerlink" title="缓存位置"></a>缓存位置</h1><p>从缓存位置上来说分为四种，并且各自有优先级，当依次查找缓存且都没有命中的时候，才会去请求网络。</p><ul><li><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能</li><li><code>Memory Cache</code> 是内存中的缓存，主要是页面上已经下载的样式、脚本、图片等已经抓取到的资源。</li><li><code>Disk Cache</code> 是存储在硬盘中的缓存，读取速度相对慢点。</li><li><code>Push Cache</code> 是 <code>HTTP/2</code> 中的内容，当以上 3 种缓存都没有命中的时候，它才会被使用。</li></ul><h1 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h1><p><code>Service Worker</code> 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。</p><p>注意点：</p><ol><li>必须是 <code>HTTPS</code>。因为它涉及请求拦截，所以必须使用 <code>HTTPS</code> 协议来保障安全。</li><li><code>Service Worker</code> 缓存不同于其他机制，它可以让我们自由控制缓存哪些文件、如何匹配缓存、如何读取缓存，并且缓存是持续性的。</li></ol><p>实现：</p><p>Service Worker 实现缓存功能一般分为三个步骤：</p><p>首先需要先注册 Service Worker，然后监听到 install 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。</p><p>当 Service Worker 没有命中缓存的时候，我们需要去调用 fetch 函数获取数据。</p><p>如果我们没有在 Service Worker 命中缓存的话，会根据缓存查找优先级去查找数据。但是不管我们是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示我们是从 Service Worker 中获取的内容。</p><h1 id="Memory-Cache"><a href="#Memory-Cache" class="headerlink" title="Memory Cache"></a>Memory Cache</h1><blockquote><p><code>Memory Cache</code>：内存中的缓存，主要是页面上已经下载的样式、脚本、图片等已经抓取到的资源。</p></blockquote><p>注意点：</p><ol><li>读取内存中的数据肯定比磁盘快，读取高效。</li><li>缓存持续性很短，会随着进程的释放而释放。关闭页面内存中的缓存也就释放了。</li></ol><p>当我们访问过页面以后，再次刷新页面，可以发现很多数据都来自于内存缓存</p><p>内存缓存中有一块重要的缓存资源是 <code>preloader</code>相关指令（例如<code>&lt;link rel=&quot;prefetch&quot;&gt;</code>）下载的资源。</p><p><code>preloader</code> 的相关指令已经是页面优化的常见手段之一，它可以一边解析 js/css 文件，一边网络请求下一个资源。</p><p>内存缓存在缓存资源时并不关心返回资源的 HTTP 缓存头 <code>Cache-Control</code> 是什么值，同时资源的匹配也并非仅仅是对 <strong>URL</strong> 做匹配，还可能会对 <strong>Content-Type</strong>，<strong>CORS</strong> 等其他特征做校验。</p><h1 id="Disk-Cache"><a href="#Disk-Cache" class="headerlink" title="Disk Cache"></a>Disk Cache</h1><p><code>Disk Cache</code> 是存储在硬盘中的缓存，读取速度相对慢点。</p><p>注意点：</p><ol><li>比起 <code>Memory Cache</code> 胜在容量和存储时效性上。</li></ol><p>在所有浏览器缓存中，<code>Disk Cache</code> 覆盖面基本是最大的。</p><p>它会根据 HTTP Header 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</p><p>绝大部分的缓存都来自 <code>Disk Cache</code></p><ul><li>对于大文件来说，大概率是不存储在内存中的，反之优先</li><li>当前系统内存使用率高的话，文件优先存储进硬盘</li></ul><h1 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h1><p><code>Push Cache</code>（推送缓存） 是 <code>HTTP/2</code> 中的内容，当以上 3 种缓存都没有命中的时候，它才会被使用。</p><p>注意点：</p><ol><li>它只在会话（<code>Session</code>）中存在，一旦会话结束就被释放，并且缓存也很短暂。</li></ol><p><code>Push Cache</code>是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。它只在会话（Session）中存在，一旦会话结束就被释放，并且缓存时间也很短暂，在 Chrome浏览器中只有 5分钟左右，同时它也并非严格执行 HTTP头中的缓存指令。</p><p>如果以上四种缓存都没有命中的话，那么只能发起请求来获取资源了。</p><p><strong>通常浏览器缓存策略分为两种：强缓存和协商缓存，并且缓存策略都是通过设置 HTTP Header 来实现的。</strong></p><h1 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h1><p>浏览器第一次向服务器发起该请求后拿到请求结果后，将请求结果和缓存标识存入浏览器缓存，<strong>浏览器对于缓存的处理是根据第一次请求资源时返回的响应头来确定的</strong>。</p><ul><li><p>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</p></li><li><p>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</p></li></ul><p><img src="/images/brower-cache.jpg" alt="brower-cache">  </p><p>过程：</p><ol><li><strong>浏览器</strong> 发起一次 HTTP 请求</li><li><strong>浏览器缓存</strong> 告诉浏览器这边没有该请求的缓存结果和缓存标识</li><li><strong>浏览器</strong> 向 <strong>服务器</strong> 发起 HTTP 请求</li><li><strong>服务器</strong> 返回该请求结果和缓存规则</li><li><strong>浏览器</strong> 将该请求结果和缓存标识存入浏览器缓存中</li></ol><h1 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h1><p>缓存分为 <strong>强缓存</strong> 和 <strong>协商缓存</strong>。</p><p><strong>强缓存</strong>优先于<strong>协商缓存</strong>进行，若<strong>强制缓存</strong>生效则直接使用缓存，若不生效则进行<strong>协商缓存</strong>。</p><p><strong>协商缓存</strong>由服务器决定是否使用缓存，若<strong>协商缓存</strong>失效，那么该请求的缓存失效，返回 200，重新返回资源和缓存标识，再存入浏览器中；生效则返回 304，继续使用缓存。</p><p>如果强缓存和协商缓存都没有设置，那么浏览器会采用启发式的算法，通常会取响应头中的 <code>Date</code> 减去 <code>Last-Modified</code> 的值的 <code>10%</code> 作为缓存时间。</p><p>当浏览器再次访问一个已经访问过的资源时，它会这样做：</p><ol><li>看看是否命中强缓存，如果命中，就直接使用缓存了；</li><li>如果没有命中强缓存，就发请求到服务器检查是否命中协商缓存；</li><li>如果命中协商缓存，服务器会返回 <code>304</code> 告诉浏览器使用本地缓存；</li><li>否则，返回最新的资源。</li></ol><h1 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h1><p><strong>强缓存</strong>：不会向服务器发送请求，直接从缓存中读取资源。</p><p><strong>强缓存</strong> 判断是否缓存的依据来自于是否超出某个时间或者某个时间段，而不关心服务器端文件是否已经更新，这可能会导致加载文件不是服务器端最新的内容（如果需要判断，那就要用 <strong>协商缓存</strong>）。</p><p><strong>强缓存</strong>可以通过设置两种 HTTP请求头实现：<code>Expires</code> 和 <code>Cache-Control</code>。</p><ul><li><strong>表示方式</strong>：在 Chrome 控制台的 Network 选项中可以看到该请求返回 <code>200</code> 状态码，并且 <code>Size</code> 显示为 <code>from disk cache</code> 或者 <code>from memory cache</code>。</li><li><strong>实现方式</strong>：</li></ul><ol><li><code>Expires</code></li><li><code>Cache-Control</code></li></ol><h2 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h2><p>缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。</p><p><code>Expires = max-age + 请求时间</code>，需要和 <code>Last-modified</code> 结合使用。</p><p><code>Expires</code> 是 Web服务器 响应消息头字段，在响应 HTTP请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。</p><p><code>Expires</code> 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。</p><h2 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h2><p>在 HTTP/1.1中，<code>Cache-Control</code> 是最重要的规则，主要用于控制网页缓存。</p><p>比如当<code>Cache-Control:max-age=300</code> 时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。</p><p>Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令：</p><ul><li><p>public：所有内容都将被缓存（客户端和代理服务器都可缓存）。</p></li><li><p>private：所有内容只有客户端可以缓存，Cache-Control的默认取值。</p></li><li><p>no-cache：客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。</p><blockquote><p>设置了no-cache之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致。</p></blockquote></li><li><p>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</p></li><li><p>max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效</p></li><li><p>s-maxage（单位为s)：同max-age作用一样，只在代理服务器中生效（比如CDN缓存）。</p></li><li><p>max-stale：能容忍的最大过期时间。</p></li><li><p>min-fresh：能够容忍的最小新鲜度。</p></li></ul><h2 id="Expires和Cache-Control两者对比"><a href="#Expires和Cache-Control两者对比" class="headerlink" title="Expires和Cache-Control两者对比"></a>Expires和Cache-Control两者对比</h2><p>区别就在于 <code>Expires</code> 是 http1.0的产物，<code>Cache-Control</code> 是 HTTP1.1的产物。</p><p>两者同时存在的话，<code>Cache-Control</code> 优先级高于 <code>Expires</code>；</p><p>在某些不支持 HTTP1.1的环境下，<code>Expires</code> 就会发挥用处。所以 <code>Expires</code> 其实是过时的产物，现阶段它的存在只是一种兼容性的写法。</p><h1 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h1><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程。</p><p>主要有以下两种情况：</p><ul><li>协商缓存生效，返回304和Not Modified</li></ul><p><img src="/images/consult-cache-1.jpg" alt="consult-cache-1">  </p><ol><li><strong>浏览器</strong> 发起 HTTP 请求，先经过 <strong>浏览器缓存</strong></li><li><strong>浏览器缓存</strong> 判断该请求的缓存结果，返回缓存标识</li><li><strong>浏览器</strong> 携带该标识，向 <strong>服务器</strong> 发起 HTTP 请求</li><li><strong>服务器</strong> 返回 304 告诉 <strong>浏览器</strong> 资源没有更新</li><li><strong>浏览器</strong> 再次请求这个缓存结果</li><li><strong>浏览器缓存</strong> 返回该请求的缓存结果</li></ol><ul><li>协商缓存失效，返回200和请求结果</li></ul><p><img src="/images/consult-cache-2.jpg" alt="consult-cache-2">  </p><ol><li><strong>浏览器</strong> 发起 HTTP 请求，先经过 <strong>浏览器缓存</strong></li><li><strong>浏览器缓存</strong> 判断该请求的缓存结果失效，返回缓存标识</li><li><strong>浏览器</strong> 携带该标识，向 <strong>服务器</strong> 发起 HTTP 请求</li><li><strong>服务器</strong> 返回 200 告诉 <strong>浏览器</strong> 资源可以更新了</li><li><strong>浏览器</strong> 读取并将请求结果和缓存标识存入 <strong>浏览器缓存</strong> 中</li></ol><h2 id="Last-Modified-和-If-Modified-Since"><a href="#Last-Modified-和-If-Modified-Since" class="headerlink" title="Last-Modified 和 If-Modified-Since"></a>Last-Modified 和 If-Modified-Since</h2><p>浏览器第一次请求资源的时候，服务器返回的响应头上会带有一个 <code>Last-Modified</code> 字段，表示资源<strong>最后修改</strong>的时间。</p><pre><code class="hljs http"><span class="hljs-attribute">Last-Modified</span>: Fri, 27 Oct 2017 07:55:30 GMT</code></pre><p>当浏览器再次请求该资源时，请求头中会带有一个 <code>If-Modified-Since</code> 字段，这个值是第一次请求返回的 <code>Last-Modified</code> 的值。</p><p>服务器收到这个请求后，将 <code>If-Modified-Since</code> 和当前的 <code>Last-Modified</code> 进行对比。</p><p>如果相等，则说明资源未修改，返回 <code>304</code>，浏览器使用本地缓存。</p><p>这个方法也是有缺点的：</p><ul><li>最小单位是秒。也就是说如果我短时间内资源发生了改变，<code>Last-Modified</code> 并不会发生变化；</li><li>周期性变化。如果这个资源在一个周期内修改回原来的样子了，我们认为是可以使用缓存的，但是 <code>Last-Modified</code> 可不这样认为。</li></ul><p>所以，后来又引入一个 <code>Etag</code>。</p><h2 id="Etag"><a href="#Etag" class="headerlink" title="Etag"></a>Etag</h2><p><code>Etag</code> 一般是由文件内容 <code>hash</code> 生成的，也就是说它可以保证资源的唯一性，资源发生改变就会导致 <code>Etag</code> 发生改变。</p><p>同样地，在浏览器第一次请求资源时，服务器会返回一个 <code>Etag</code> 标识。</p><p>当再次请求该资源时， 会通过 <code>If-no-match</code> 字段将 <code>Etag</code> 发送回服务器，然后服务器进行比较，如果相等，则返回 <code>304</code> 表示未修改。</p><p><code>Last-Modified</code> 和 <code>Etag</code> 是可以同时设置的，服务器会优先校验 <code>Etag</code>，如果 <code>Etag</code> 相等就会继续比对 <code>Last-Modified</code>，最后才会决定是否返回 <code>304</code>。</p><h1 id="实际场景应用缓存策略"><a href="#实际场景应用缓存策略" class="headerlink" title="实际场景应用缓存策略"></a>实际场景应用缓存策略</h1><ol><li>频繁变动的资源</li></ol><blockquote><p><code>Cache-Control: no-cache</code></p></blockquote><p>对于频繁变动的资源，首先需要使用 <code>Cache-Control: no-cache</code> 使浏览器每次都请求服务器，然后配合 <code>ETag</code>或者 <code>Last-Modified</code> 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。</p><ol start="2"><li>不常变化的资源</li></ol><blockquote><p><code>Cache-Control: max-age=31536000</code></p></blockquote><p>通常在处理这类资源时，给它们的 <code>Cache-Control</code> 配置一个很大的 <code>max-age=31536000</code> (一年)，这样浏览器之后请求相同的 URL 会命中强制缓存。</p><p>而为了解决更新的问题，就需要在文件名(或者路径) 中添加 hash， 版本号等动态字符，之后更改动态字符，从而达到更改引用 URL 的目的，让之前的强制缓存失效 (其实并未立即失效，只是不再使用了而已)。</p><p>在线提供的类库 (如 <code>jquery-3.3.1.min.js</code>, <code>lodash.min.js</code> 等) 均采用这个模式。</p><h1 id="用户行为对浏览器缓存的影响"><a href="#用户行为对浏览器缓存的影响" class="headerlink" title="用户行为对浏览器缓存的影响"></a>用户行为对浏览器缓存的影响</h1><p>用户在浏览器如何操作时，会触发 3种缓存策略 ：</p><ul><li>打开网页，地址栏输入地址： 查找 <strong>disk cache</strong> 中是否有匹配。如有则使用；如没有则发送网络请求。</li><li>普通刷新 (F5)：因为 TAB 并没有关闭，因此 <strong>memory cache</strong> 是可用的，会被优先使用(如果匹配的话)。其次才是 <strong>disk cache</strong>。</li><li>强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 <code>Cache-control: no-cache</code> (为了兼容，还带了 <code>Pragma: no-cache</code>),服务器直接返回 200 和最新内容。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>浏览器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈 HTTP 协议</title>
    <link href="/2020/11/08/%E6%B5%85%E8%B0%88%20HTTP%20%E5%8D%8F%E8%AE%AE/"/>
    <url>/2020/11/08/%E6%B5%85%E8%B0%88%20HTTP%20%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><blockquote><p>HTTP（超文本传输协议，HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议。所有的 WWW 文件都必须遵守这个标准。</p></blockquote><p>设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。是用于从 WWW 服务器传输超文本到本地浏览器的传输协议。</p><p>默认使用 80 端口，HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的 TCP 连接。</p><p>HTTP 协议和 TCP 协议是不冲突的，HTTP 定义在七层协议中的应用层，TCP 解决的是传输层的逻辑。</p><h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><p>HTTP1.0 是第一个在通讯中指定版本号的 HTTP 协议版本，至今仍被广泛采用，特别是在代理服务器中。</p><p>HTTP1.1 是当前版本，持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。</p><p>HTTP2.0 在 HTTP1.x 的基础上，大幅度的提高了 Web 性能，减少了网络延迟。</p><p>HTTP1.0 和 1.1 在之后很长的一段时间内会一直并存，这是由于网络基础设施更新缓慢所决定的。</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><p>HTTP1.0 是 HTTP 协议老的标准，其为了提高系统系统的效率，规定浏览器与服务器只保持短暂的连接，浏览器每一次请求都需要与服务器建立一个 TCP 连接。</p><p>TCP 协议提供传输控制，按顺序组织数据，和错误纠正。HTTP 协议的瓶颈和优化都是基于 TCP 协议本身的。如 TCP 建立连接时需要三次握手，三次握手有 1.5 个 RTT（Round-Trip-Time）的延迟，TCP 在建立初期还有慢启动（Slow Start）的特性，所有连接的重用总是比新建连接性能要好。</p><p>HTTP1.0 支持长连接，需要设置 <code>Connection: keep-alive</code> 参数来告诉服务器端要建立一个长连接。</p><p>HTTP1.0 在请求方式新增了POST、DELETE、PUT、HEADER 等方式</p><p>增添了请求头和响应头的概念，在通信中指定了 HTTP 协议版本号，以及其他的一些元信息 (比如: 状态码、权限、缓存、内容编码)</p><p>扩充了传输内容格式，图片、音视频资源、二进制等都可以进行传输</p><p>在这个版本主要的就是对请求和响应的元信息进行了扩展，客户端和服务端有更多的获取当前请求的所有信息，进而更好更快的处理请求相关内容。</p><p>HTTP1.0 特性：</p><ul><li>无状态：服务器不跟踪不记录请求过程的状态</li><li>无连接：浏览器每次请求都需要建立 TCP 连接</li></ul><p>对于「无状态」的特性可以借助 cookie/session 机制来做身认证和状态记录</p><p>无连接则导致性能缺陷：</p><ol><li><p>无法复用连接</p><blockquote><p>每次发送请求都需要一次 TCP 连接 （3次握手，4次挥手），使网路的传输效率非常低</p></blockquote></li><li><p>队头堵塞</p><blockquote><p>HTTP1.0 规定在前一个请求响应到达之后，下一个请求才能发送。如果前一个阻塞，后面的请求也阻塞</p></blockquote></li></ol><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>HTTP1.1 是 HTTP1.0 发布之后半年就推出的版本。为了解决传输效率的问题，HTTP1.1 完善了 HTTP1.0 版本。</p><p>HTTP1.1 默认支持长连接（持久连接）无需手动设置 <code>Connection: keep-alive</code>，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p><p>基于上面的长连接基础，HTTP1.1 还引入了管道机制（Pipelining）。管道化可以不等第一个请求响应继续发送后面的请求，但响应的顺序还是按照请求的顺序返回</p><p>HTTP1.1 的默认模式是使用管道机制的长连接。</p><p>在 HTTP1.1 中默认允许 <code>Connection: keep-alive</code>  但是在一个 TCP 连接里面数据通信是按次序进行的，服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为”队头堵塞”（Head-of-line blocking）。</p><p>HTTP1.1 特性：</p><ul><li><p>基于管道化的长连接</p><blockquote><p>默认支持管道化的长连接，无需设置请求头<code>Connection: keep-alive</code> 。可以不等第一请求响应，继续发送请求。但是响应的顺序还是按照请求的顺序返回，第一个响应如果阻塞后面请求的响应也一样阻塞。队头堵塞的问题依然没有得到解决</p></blockquote></li><li><p>缓存处理</p><blockquote><p>新增加字段 <code>Cache-Control</code></p><p>当浏览器请求资源时，先看是否有缓存的资源，如果有缓存，直接取，不会再发请求，如果没有缓存，则发送请求。</p></blockquote></li><li><p>支持断点续传</p><blockquote><p>在上传/下载资源时，如果资源过大，将其分割为多个部分，分别上传/下载，如果遇到网络故障，可以从已经上传/下载好的地方继续请求，不用从头开始，提高效率</p></blockquote></li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><blockquote><p>HTTP2.0 比之前的协议在性能上有很大的提升。</p></blockquote><p><strong>HTTP2.0 协议拥有了新的特性：</strong></p><p><strong>多路复用 (Multiplexing)</strong></p><p>多路复用允许同时通过单一的 HTTP2.0 连接发起多重的 <em>请求-响应</em> 消息。</p><p>在 HTTP1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制，超过限制数目的请求会被阻塞。</p><p>HTTP2.0 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。</p><p>帧（frame）和流（stream）是 HTTP2.0 中两个很重要的概念：</p><p>帧代表着最小的数据单位，每个帧都会标识出该帧属于哪个流，流就是由多个帧组成的数据流。</p><p>多路复用，也就是在一个 TCP 连接中可以存在多条流，就是我们所说的可以发送多个请求，对端可以通过帧的标示知道，该帧属于哪个流（请求），通过这个技术及意义避免 HTTP1.x 中的队头阻塞问题，极大的提高传输性能。</p><p><strong>二进制分帧</strong></p><p>HTTP1.x 的解析是基于文本，HTTP2.0 之后将所有传输的信息分割为更小的消息和帧，并对它们采用二进制格式的编码，提高传输效率。</p><p>HTTP2.0 在 应用层 (HTTP2.0) 和传输层 (TCP or UDP) 之间增加一个二进制分帧层。在不改动 HTTP1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。</p><p>HTTP2.0 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。</p><p><strong>首部压缩（Header Compression）</strong></p><p>由于 HTTP 是无状态的，每一个请求都需要头部信息标识这次请求相关信息，所以会造成传输很多重复的信息，当请求数量增大的时候，消耗的资源就会慢慢积累上去。</p><p>HTTP1.1并不支持 HTTP 首部压缩， HTTP2.0 使用了专门为首部压缩而设计的 HPACK 算法。</p><p>HTTP2.0 可以维护一个头部信息字典，差量进行更新头信息，减少头部信息传输占用的资源。</p><p><strong>服务端推送（Server Push）</strong></p><p>HTTP2.0 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。</p><blockquote><p>服务端推送是一种在客户端请求之前发送数据的机制。</p></blockquote><p>在 HTTP2.0 中，服务器可以对客户端的一个请求发送多个响应。服务器可以额外的向客户端推送资源，而无需客户端明确的请求。</p><p>当我们对支持 HTTP2.0 的服务器请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源！</p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p>HTTP 协议传输的数据都是未加密的，也就是明文的，因此使用 HTTP 协议传输隐私信息非常不安全。</p><p>为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对 HTTP 协议传输的数据进行加密，从而就诞生了HTTPS。</p><p>HTTPS 在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。</p><p>TLS/SSL 协议不仅仅是一套加密传输的协议，TLS/SSL 中使用了非对称加密，对称加密以及 HASH 算法。</p><p>握手过程的简单描述如下：</p><ol><li><p>浏览器将自己支持的一套加密规则发送给网站。</p></li><li><p>网站从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。</p><blockquote><p>证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息</p></blockquote></li><li><p>获得网站证书之后浏览器要做以下工作：</p><ol><li>验证证书的合法性</li><li>如果证书受信任，或者是用户接受了不受信的证书，浏览器会生成一串随机数的密码，并用证书中提供的公钥加密</li><li>使用约定好的HASH计算握手消息，并使用生成的随机数对消息进行加密，最后将之前生成的所有信息发送给网站</li></ol></li><li><p>网站接收浏览器发来的数据之后要做以下的操作：</p><ol><li>使用自己的私钥将信息解密取出密码，使用密码解密浏览器发来的握手消息，并验证 HASH 是否与浏览器发来的一致</li><li>使用密码加密一段握手消息，发送给浏览器</li></ol></li><li><p>浏览器解密并计算握手消息的 HASH，如果与服务端发来的 HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p></li></ol><p>这里浏览器与网站互相发送加密的握手消息并验证，目的是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据。</p><p>TLS 握手过程中如果有任何错误，都会使加密连接断开，从而阻止了隐私信息的传输。</p><p>正是由于 HTTPS 非常的安全，攻击者无法从中找到下手的地方，于是更多的是采用了假证书的手法来欺骗客户端，从而获取明文的信息。默认 HTTP 的端口号为 80，HTTPS 的端口号为 443。</p><h3 id="HTTPS-和-HTTP-对比"><a href="#HTTPS-和-HTTP-对比" class="headerlink" title="HTTPS 和 HTTP 对比"></a>HTTPS 和 HTTP 对比</h3><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和 HTTPS 使用端口不一样，前者是 80，后者是 443</li><li>HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，HTTPS 行在 SSL/TLS 之上，SSL/TLS 运行在 TCP 之上，所有传输的内容都经过加密的</li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>网络</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ECMAScript6 精粹</title>
    <link href="/2020/11/02/ECMAScript6/"/>
    <url>/2020/11/02/ECMAScript6/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>整理一些在学习、工作中用到的 ES6</p></blockquote><h1 id="1-let-和-const"><a href="#1-let-和-const" class="headerlink" title="1. let 和 const"></a>1. let 和 const</h1><p>let 的作用域与 const 相同：只在声明所在的「块」级作用域内有效。且不存在变量提升 。</p><p>对于 数值、字符串、布尔值 经常会变的，用 let 声明。</p><p>对象、数组和函数用 const 来声明</p><h2 id="1-1-let"><a href="#1-1-let" class="headerlink" title="1.1 let"></a>1.1 let</h2><p>let 声明的变量，可以改变</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">4396</span>a = <span class="hljs-number">5678</span><span class="hljs-keyword">let</span> b = <span class="hljs-string">&#x27;playlife&#x27;</span>b = <span class="hljs-string">&#x27;Johnny&#x27;</span></code></pre><h2 id="1-2-const"><a href="#1-2-const" class="headerlink" title="1.2 const"></a>1.2 const</h2><p>const 声明一个只读的常量。一旦声明，常量的值就不能改变。</p><p>简单类型的数据（数值、字符串、布尔值），不可以变动</p><p>复合类型的数据（主要是对象和数组），可以这样子变动</p><pre><code class="hljs stylus">const <span class="hljs-selector-tag">a</span> = [<span class="hljs-number">4396</span>]<span class="hljs-selector-tag">a</span>.push(<span class="hljs-number">2233</span>)const <span class="hljs-selector-tag">b</span> = &#123;&#125;<span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.name</span> = <span class="hljs-string">&#x27;playlife&#x27;</span></code></pre><h2 id="1-3-不存在变量提升"><a href="#1-3-不存在变量提升" class="headerlink" title="1.3 不存在变量提升"></a>1.3 不存在变量提升</h2><p>let 和 const 的暂时性死区：let 和 const 不存在变量提升是因为 let/const 命令会使区块形成封闭的作用域，</p><p>用 let/const 声明的变量会先在作用域中被创建出来，但因此时还未进行词法绑定，所以是不能被访问的，如果访问就会抛出错误。</p><p>因此，在这运行流程进入作用域创建变量，到变量可以被访问之间的这一段时间，就称之为暂时死区。这在语法上，称为 “暂时性死区”（ temporal dead zone，简称 TDZ）。</p><h1 id="2-解构-Destructuring"><a href="#2-解构-Destructuring" class="headerlink" title="2. 解构 (Destructuring)"></a>2. 解构 (Destructuring)</h1><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构 （Destructuring）。</p><h2 id="2-1-数组"><a href="#2-1-数组" class="headerlink" title="2.1 数组"></a>2.1 数组</h2><p>一次性声明多个变量：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> [a, b, c] = [ <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span> ];</code></pre><p>结合扩展运算符：</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> [head, ...tail] = [ <span class="hljs-number">4</span> , <span class="hljs-number">3</span> , <span class="hljs-number">2</span> ,<span class="hljs-number">5</span> ]<span class="hljs-built_in">console</span>.log(head) <span class="hljs-comment">// 4</span><span class="hljs-built_in">console</span>.log(tail) <span class="hljs-comment">// [3, 2, 5]</span></code></pre><p>解构赋值允许指定默认值:</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> [foo = <span class="hljs-literal">true</span>] = [];foo <span class="hljs-comment">// true</span><span class="hljs-keyword">let</span> [x, y = <span class="hljs-string">&#x27;b&#x27;</span>] = [<span class="hljs-string">&#x27;a&#x27;</span>];<span class="hljs-comment">// x=&#x27;a&#x27;, y=&#x27;b&#x27;</span></code></pre><blockquote><p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。</p></blockquote><p>如果解构不成功，变量的值就等于<code>undefined</code>。</p><h2 id="2-2-对象-（常用）"><a href="#2-2-对象-（常用）" class="headerlink" title="2.2 对象 （常用）"></a>2.2 对象 （常用）</h2><p>解构不仅可以用于数组，还可以用于对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123; foo, bar &#125; = &#123; <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;aaa&#x27;</span>, <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;bbb&#x27;</span> &#125;;foo <span class="hljs-comment">// &quot;aaa&quot;</span>bar <span class="hljs-comment">// &quot;bbb&quot;</span></code></pre><p>数组的结构赋值取决于变量的排列位置，在对象中，结构赋值变量必须于对象的属性同名才能正确的赋值。（对象的解构赋值在开发中常用，它帮助我们代码更加简洁，更加优雅）</p><p>如果解构失败，变量的值等于<code>undefined</code>。</p><p>对象的解构也可以指定默认值。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> &#123;x = <span class="hljs-number">3</span>&#125; = &#123;&#125;;x <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123;x, y = <span class="hljs-number">5</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;;x <span class="hljs-comment">// 1</span>y <span class="hljs-comment">// 5</span><span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">x</span>: y = <span class="hljs-number">3</span>&#125; = &#123;&#125;;y <span class="hljs-comment">// 3</span><span class="hljs-keyword">var</span> &#123;<span class="hljs-attr">x</span>: y = <span class="hljs-number">3</span>&#125; = &#123;<span class="hljs-attr">x</span>: <span class="hljs-number">5</span>&#125;;y <span class="hljs-comment">// 5</span><span class="hljs-keyword">var</span> &#123; <span class="hljs-attr">message</span>: msg = <span class="hljs-string">&#x27;Something went wrong&#x27;</span> &#125; = &#123;&#125;;msg <span class="hljs-comment">// &quot;Something went wrong&quot;</span></code></pre><h2 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h2><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> [a, b, c, d, e] = <span class="hljs-string">&#x27;hello&#x27;</span>;a <span class="hljs-comment">// &quot;h&quot;</span>b <span class="hljs-comment">// &quot;e&quot;</span>c <span class="hljs-comment">// &quot;l&quot;</span>d <span class="hljs-comment">// &quot;l&quot;</span>e <span class="hljs-comment">// &quot;o&quot;</span></code></pre><p>类似数组的对象都有一个<code>length</code>属性，因此还可以对这个属性解构赋值。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span> : len&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;len <span class="hljs-comment">// 5</span></code></pre><h2 id="2-4-解构赋值用途"><a href="#2-4-解构赋值用途" class="headerlink" title="2.4 解构赋值用途"></a>2.4 解构赋值用途</h2><h3 id="2-4-1-交换变量的值"><a href="#2-4-1-交换变量的值" class="headerlink" title="2.4.1 交换变量的值"></a>2.4.1 交换变量的值</h3><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span><span class="hljs-keyword">let</span> y = <span class="hljs-number">3</span>[ x , y ] = [ y , x ]</code></pre><h3 id="2-4-2-接受函数返回的值"><a href="#2-4-2-接受函数返回的值" class="headerlink" title="2.4.2 接受函数返回的值"></a>2.4.2 接受函数返回的值</h3><blockquote><p>常用于 ajax请求返回数据的获取</p></blockquote><p>简单例子：</p><pre><code class="hljs js">cont &#123;status , data&#125; = <span class="hljs-keyword">await</span> axios.get(<span class="hljs-string">&#x27;localhost:33301&#x27;</span>)</code></pre><h3 id="2-4-3-导入模块指定的方法"><a href="#2-4-3-导入模块指定的方法" class="headerlink" title="2.4.3 导入模块指定的方法"></a>2.4.3 导入模块指定的方法</h3><p>举例子：vuex中的方法</p><pre><code class="hljs js"><span class="hljs-comment">//导入 vuex 的 mapGetters 方法</span><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span></code></pre><h1 id="3-模版字符串"><a href="#3-模版字符串" class="headerlink" title="3. 模版字符串"></a>3. 模版字符串</h1><blockquote><p>可以在字符串中嵌入变量，可以换行，可以调用方法，比普通的拼接字符串更加高效优雅</p></blockquote><pre><code class="hljs js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;<span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`输出值为：<span class="hljs-subst">$&#123;x&#125;</span>`</span>) <span class="hljs-comment">// &quot;输出值为：1&quot;</span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`输出值为：<span class="hljs-subst">$&#123;x + y&#125;</span>`</span>) <span class="hljs-comment">// &quot;输出值为：3&quot;</span></code></pre><p>常用于模版引擎</p><h1 id="4-字符串的新增方法"><a href="#4-字符串的新增方法" class="headerlink" title="4. 字符串的新增方法"></a>4. 字符串的新增方法</h1><blockquote><p>仅列举常用的新增方法，更多的请查看《ES6标准入门》阮一峰老师的书学习</p></blockquote><p>传统上，JavaScript 只有<code>indexOf</code>方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p><ul><li><code>includes()</code>：返回布尔值，表示是否找到了参数字符串。</li><li><code>startsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的头部。</li><li><code>endsWith()</code>：返回布尔值，表示参数字符串是否在原字符串的尾部。</li></ul><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;s.startsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>) <span class="hljs-comment">// true</span>s.endsWith(<span class="hljs-string">&#x27;!&#x27;</span>) <span class="hljs-comment">// true</span>s.includes(<span class="hljs-string">&#x27;o&#x27;</span>) <span class="hljs-comment">// true</span></code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;s.startsWith(<span class="hljs-string">&#x27;world&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// true</span>s.endsWith(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// true</span>s.includes(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-number">6</span>) <span class="hljs-comment">// false</span></code></pre><p>上面代码表示，使用第二个参数<code>n</code>时，<code>endsWith</code>的行为与其他两个方法有所不同。它针对前<code>n</code>个字符，而其他两个方法针对从第<code>n</code>个位置直到字符串结束。</p><p>扩展眼界列举出其他新增方法但是不详细展开，有需要再去查阅资料💾</p><ol><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#String.fromCodePoint()">String.fromCodePoint()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#String.raw()">String.raw()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AcodePointAt()">实例方法：codePointAt()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Anormalize()">实例方法：normalize()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Aincludes(">实例方法：includes(), startsWith(), endsWith()</a>, startsWith(), endsWith())</li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9Arepeat()">实例方法：repeat()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9ApadStart()%EF%BC%8CpadEnd()">实例方法：padStart()，padEnd()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AtrimStart()%EF%BC%8CtrimEnd()">实例方法：trimStart()，trimEnd()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AmatchAll()">实例方法：matchAll()</a></li><li><a href="https://es6.ruanyifeng.com/#docs/string-methods#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%EF%BC%9AreplaceAll()">实例方法：replaceAll()</a></li></ol><h1 id="5-函数的扩展"><a href="#5-函数的扩展" class="headerlink" title="5. 函数的扩展"></a>5. 函数的扩展</h1><h2 id="5-1-函数参数的默认值"><a href="#5-1-函数参数的默认值" class="headerlink" title="5.1 函数参数的默认值"></a>5.1 函数参数的默认值</h2><p>可以为函数参数声明一个默认值</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Point</span>(<span class="hljs-params">x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span></span>) </span>&#123;  <span class="hljs-built_in">this</span>.x = x;  <span class="hljs-built_in">this</span>.y = y;&#125;<span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> Point();p <span class="hljs-comment">// &#123; x: 0, y: 0 &#125;</span></code></pre><p>参数变量是默认声明的，所以不能用<code>let</code>或<code>const</code>再次声明。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">x = <span class="hljs-number">5</span></span>) </span>&#123;  <span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>; <span class="hljs-comment">// error</span>  <span class="hljs-keyword">const</span> x = <span class="hljs-number">2</span>; <span class="hljs-comment">// error</span>&#125;</code></pre><p>上面代码中，参数变量<code>x</code>是默认声明的，在函数体中，不能用<code>let</code>或<code>const</code>再次声明，否则会报错。</p><p>使用参数默认值时，函数不能有同名参数。</p><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p><pre><code class="hljs js">参数默认值可以与解构赋值的默认值，结合起来使用。<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">&#123;x, y = <span class="hljs-number">5</span>&#125;</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(x, y);&#125;foo(&#123;&#125;) <span class="hljs-comment">// undefined 5</span>foo(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>&#125;) <span class="hljs-comment">// 1 5</span>foo(&#123;<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>&#125;) <span class="hljs-comment">// 1 2</span>foo() <span class="hljs-comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span></code></pre><h2 id="5-2-rest-参数"><a href="#5-2-rest-参数" class="headerlink" title="5.2 rest 参数"></a>5.2 rest 参数</h2><p>ES6 引入 rest 参数（形式为<code>...变量名</code>），用于获取函数的多余参数，这样就不需要使用<code>arguments</code>对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...values</span>) </span>&#123;  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> val <span class="hljs-keyword">of</span> values) &#123;    sum += val;  &#125;  <span class="hljs-keyword">return</span> sum;&#125;add(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// 10</span></code></pre><p>上面代码的 add 函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">a, ...b, c</span>) </span>&#123;  <span class="hljs-comment">// ...</span>&#125;</code></pre><p>函数的<code>length</code>属性，不包括 rest 参数。</p><pre><code class="hljs javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) </span>&#123;&#125;).length  <span class="hljs-comment">// 1</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...a</span>) </span>&#123;&#125;).length  <span class="hljs-comment">// 0</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, ...b</span>) </span>&#123;&#125;).length  <span class="hljs-comment">// 1</span></code></pre><h2 id="5-3-箭头函数"><a href="#5-3-箭头函数" class="headerlink" title="5.3 箭头函数"></a>5.3 箭头函数</h2><p>ES6 允许使用“箭头”（<code>=&gt;</code>）定义函数。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;<span class="hljs-comment">// 等同于</span><span class="hljs-keyword">var</span> f = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) </span>&#123;  <span class="hljs-keyword">return</span> v;&#125;;</code></pre><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 报错</span><span class="hljs-keyword">let</span> getTempItem = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123; <span class="hljs-attr">id</span>: id, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Temp&quot;</span> &#125;;<span class="hljs-comment">// 不报错</span><span class="hljs-keyword">let</span> getTempItem = <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> (&#123; <span class="hljs-attr">id</span>: id, <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Temp&quot;</span> &#125;);</code></pre><p>下面是 rest 参数与箭头函数结合的例子。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> numbers = <span class="hljs-function">(<span class="hljs-params">...nums</span>) =&gt;</span> nums;numbers(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">// [1,2,3,4,5]</span><span class="hljs-keyword">const</span> headAndTail = <span class="hljs-function">(<span class="hljs-params">head, ...tail</span>) =&gt;</span> [head, tail];headAndTail(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<span class="hljs-comment">// [1,[2,3,4,5]]</span></code></pre><p>箭头函数有几个使用注意点。</p><p>（1）函数体内的<code>this</code>对象，就是定义时所在的对象，而不是使用时所在的对象。</p><p>（2）不可以当作构造函数，也就是说，不可以使用<code>new</code>命令，否则会抛出一个错误。</p><p>（3）不可以使用<code>arguments</code>对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p><p>（4）不可以使用<code>yield</code>命令，因此箭头函数不能用作 Generator 函数。</p><p>上面四点中，第一点尤其值得注意。<code>this</code>对象的指向是可变的，但是在箭头函数中，它是固定的。</p><h3 id="5-3-1-箭头函数不适用场景"><a href="#5-3-1-箭头函数不适用场景" class="headerlink" title="5.3.1 箭头函数不适用场景"></a>5.3.1 箭头函数不适用场景</h3><p>由于箭头函数使得<code>this</code>从“动态”变成“静态”，下面两个场合不应该使用箭头函数。</p><p>第一个场合是定义对象的方法，且该方法内部包括<code>this</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> cat = &#123;  lives: <span class="hljs-number">9</span>,  jumps: <span class="hljs-function">() =&gt;</span> &#123;    <span class="hljs-built_in">this</span>.lives--;  &#125;&#125;</code></pre><p>第二个场合是需要动态<code>this</code>的时候，也不应使用箭头函数。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;press&#x27;</span>);button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;  <span class="hljs-built_in">this</span>.classList.toggle(<span class="hljs-string">&#x27;on&#x27;</span>);&#125;);</code></pre><h1 id="6-数组的扩展"><a href="#6-数组的扩展" class="headerlink" title="6. 数组的扩展"></a>6. 数组的扩展</h1><p>扩展运算符（spread）是三个点（<code>...</code>）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p><h2 id="6-1-数组合并的新写法"><a href="#6-1-数组合并的新写法" class="headerlink" title="6.1 数组合并的新写法"></a>6.1 数组合并的新写法</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];<span class="hljs-keyword">const</span> arr2 = [<span class="hljs-string">&#x27;c&#x27;</span>];<span class="hljs-keyword">const</span> arr3 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<span class="hljs-comment">// ES5 的合并数组</span>arr1.concat(arr2, arr3);<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span><span class="hljs-comment">// ES6 的合并数组</span>[...arr1, ...arr2, ...arr3]<span class="hljs-comment">// [ &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27; ]</span></code></pre><h2 id="6-2-函数调用"><a href="#6-2-函数调用" class="headerlink" title="6.2 函数调用"></a>6.2 函数调用</h2><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x + y;&#125;<span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">4</span>, <span class="hljs-number">4</span>];add(...numbers) <span class="hljs-comment">// 8</span></code></pre><p>上面代码中函数的调用，它使用了扩展运算符。该运算符将一个数组，变为参数序列。</p><p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">v, w, x, y, z</span>) </span>&#123; &#125;<span class="hljs-keyword">const</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];f(<span class="hljs-number">-1</span>, ...args, <span class="hljs-number">2</span>, ...[<span class="hljs-number">3</span>]);</code></pre><h2 id="6-3-复制数组的简便写法"><a href="#6-3-复制数组的简便写法" class="headerlink" title="6.3 复制数组的简便写法"></a>6.3 复制数组的简便写法</h2><pre><code class="hljs js"><span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<span class="hljs-comment">// 写法一</span><span class="hljs-keyword">const</span> a2 = [...a1];a2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;a1 <span class="hljs-comment">// [1, 2]</span><span class="hljs-comment">// 写法二</span><span class="hljs-keyword">const</span> [...a2] = a1;a2[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;a1 <span class="hljs-comment">// [1, 2]</span></code></pre><p>上面的两种写法，a2 都是 a1 的克隆，且不会修改原来的数组。</p><h2 id="6-4-将字符串转为真正的数组"><a href="#6-4-将字符串转为真正的数组" class="headerlink" title="6.4 将字符串转为真正的数组"></a>6.4 将字符串转为真正的数组</h2><pre><code class="hljs js">[...<span class="hljs-string">&#x27;hello&#x27;</span>]<span class="hljs-comment">// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]</span></code></pre><h2 id="6-5-数组实例的-entries-，keys-和-values"><a href="#6-5-数组实例的-entries-，keys-和-values" class="headerlink" title="6.5 数组实例的 entries()，keys() 和 values()"></a>6.5 数组实例的 entries()，keys() 和 values()</h2><p>用 for…of 循环进行遍历，唯一的区别是 keys() 是对键名的遍历、values() 是对键值的遍历，entries() 是对键值对的遍历。</p><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].keys()) &#123;  <span class="hljs-built_in">console</span>.log(index);&#125;<span class="hljs-comment">// 0</span><span class="hljs-comment">// 1</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> elem <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].values()) &#123;  <span class="hljs-built_in">console</span>.log(elem);&#125;<span class="hljs-comment">// &#x27;a&#x27;</span><span class="hljs-comment">// &#x27;b&#x27;</span><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> [index, elem] <span class="hljs-keyword">of</span> [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>].entries()) &#123;  <span class="hljs-built_in">console</span>.log(index, elem);&#125;<span class="hljs-comment">// 0 &quot;a&quot;</span><span class="hljs-comment">// 1 &quot;b&quot;</span></code></pre><h2 id="6-6-includes-是否包含给定的值"><a href="#6-6-includes-是否包含给定的值" class="headerlink" title="6.6 includes() 是否包含给定的值"></a>6.6 includes() 是否包含给定的值</h2><p>Array.prototype.includes 方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的 includes 方法类似。ES2016 引入了该方法。</p><pre><code class="hljs yaml">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.includes(2)</span>     <span class="hljs-string">//</span> <span class="hljs-literal">true</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-string">.includes(4)</span>     <span class="hljs-string">//</span> <span class="hljs-literal">false</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">NaN</span>]<span class="hljs-string">.includes(NaN)</span> <span class="hljs-string">//</span> <span class="hljs-literal">true</span></code></pre><p>该方法的第二个参数表示搜索的起始位置，默认为 0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为 -4，但数组长度为 3 ），则会重置为从 0 开始。</p><pre><code class="hljs js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>);  <span class="hljs-comment">// false</span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">3</span>, <span class="hljs-number">-1</span>); <span class="hljs-comment">// true</span></code></pre><h2 id="6-7-Array-from-转为真正的数组"><a href="#6-7-Array-from-转为真正的数组" class="headerlink" title="6.7 Array.from() 转为真正的数组"></a>6.7 Array.from() 转为真正的数组</h2><p><code>Array.from</code>方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p><p>下面是一个类似数组的对象，<code>Array.from</code>将它转为真正的数组。</p><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123;    <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,    <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,    <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,    length: <span class="hljs-number">3</span>&#125;;<span class="hljs-comment">// ES5的写法</span><span class="hljs-keyword">var</span> arr1 = [].slice.call(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><span class="hljs-comment">// ES6的写法</span><span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span></code></pre><h1 id="7-对象的扩展"><a href="#7-对象的扩展" class="headerlink" title="7. 对象的扩展"></a>7. 对象的扩展</h1><h2 id="7-1-属性和方法的简洁表示法"><a href="#7-1-属性和方法的简洁表示法" class="headerlink" title="7.1 属性和方法的简洁表示法"></a>7.1 属性和方法的简洁表示法</h2><pre><code class="hljs js"><span class="hljs-keyword">let</span> birth = <span class="hljs-string">&#x27;1997/04/05&#x27;</span>;<span class="hljs-keyword">const</span> Person = &#123;  name: <span class="hljs-string">&#x27;playlife&#x27;</span>,  <span class="hljs-comment">//等同于birth: birth</span>  birth,  <span class="hljs-comment">// 等同于hello: function ()...</span>  hello() &#123; <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我的名字是&#x27;</span>, <span class="hljs-built_in">this</span>.name); &#125;&#125;;</code></pre><h2 id="7-2-Object-assign"><a href="#7-2-Object-assign" class="headerlink" title="7.2 Object.assign()"></a>7.2 Object.assign()</h2><p>Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-built_in">Object</span>.assign(target, source1, source2);target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span></code></pre><p>Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。</p><p><strong>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</strong></p><pre><code class="hljs js"><span class="hljs-keyword">const</span> target = &#123; <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">1</span> &#125;;<span class="hljs-keyword">const</span> source1 = &#123; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">c</span>: <span class="hljs-number">2</span> &#125;;<span class="hljs-keyword">const</span> source2 = &#123; <span class="hljs-attr">c</span>: <span class="hljs-number">3</span> &#125;;<span class="hljs-built_in">Object</span>.assign(target, source1, source2);target <span class="hljs-comment">// &#123;a:1, b:2, c:3&#125;</span></code></pre><p>Object.assign 方法实行的是浅拷贝，而不是深拷贝。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj1 = &#123;<span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">b</span>: <span class="hljs-number">1</span>&#125;&#125;;<span class="hljs-keyword">const</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj1);obj1.a.b = <span class="hljs-number">2</span>;obj2.a.b <span class="hljs-comment">// 2</span></code></pre><p>上面代码中，源对象 obj1 的 a 属性的值是一个对象，Object.assign 拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p><p>补充：</p><p>描述对象的<code>enumerable</code>属性，称为“可枚举性”，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p><p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p><ul><li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li><li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li><li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li><li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li></ul><h2 id="7-3-属性遍历"><a href="#7-3-属性遍历" class="headerlink" title="7.3 属性遍历"></a>7.3 属性遍历</h2><p>ES6 一共有 5 种方法可以遍历对象的属性。</p><p><strong>（1）for…in</strong></p><p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p><p><strong>（2）Object.keys(obj)</strong></p><p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p><p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p><p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p><p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p><p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p><p><strong>（5）Reflect.ownKeys(obj)</strong></p><p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的（不含继承的）所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p><p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p><ul><li>首先遍历所有数值键，按照数值升序排列。</li><li>其次遍历所有字符串键，按照加入时间升序排列。</li><li>最后遍历所有 Symbol 键，按照加入时间升序排列。</li></ul><h2 id="7-4-super-关键字"><a href="#7-4-super-关键字" class="headerlink" title="7.4 super 关键字"></a>7.4 super 关键字</h2><p><code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> proto = &#123;  foo: <span class="hljs-string">&#x27;hello&#x27;</span>&#125;;<span class="hljs-keyword">const</span> obj = &#123;  foo: <span class="hljs-string">&#x27;world&#x27;</span>,  find() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.foo;  &#125;&#125;;<span class="hljs-built_in">Object</span>.setPrototypeOf(obj, proto);obj.find() <span class="hljs-comment">// &quot;hello&quot;</span></code></pre><p>上面代码中，对象<code>obj.find()</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p><p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p><h1 id="8-Set"><a href="#8-Set" class="headerlink" title="8. Set"></a>8. Set</h1><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set 本身是一个构造函数，用来生成 Set 数据结构。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();[<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>].forEach(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> s.add(x));<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">of</span> s) &#123;  <span class="hljs-built_in">console</span>.log(i);&#125;<span class="hljs-comment">// 2 3 5 4</span></code></pre><p>上面代码通过<code>add()</code>方法向 Set 结构加入成员，结果表明 Set 结构不会添加重复的值。</p><p><code>Set</code>函数可以接受一个数组（或者具有 iterable 接口的其他数据结构）作为参数，用来初始化。</p><p>向 Set 加入值的时候，不会发生类型转换，所以<code>5</code>和<code>&quot;5&quot;</code>是两个不同的值。</p><p>Set 内部判断两个值是否不同，使用的算法叫做“Same-value-zero equality”，它类似于精确相等运算符（<code>===</code>），主要的区别是向 Set 加入值时认为<code>NaN</code>等于自身，而精确相等运算符认为<code>NaN</code>不等于自身。</p><h2 id="8-1-Set-实例的属性和方法"><a href="#8-1-Set-实例的属性和方法" class="headerlink" title="8.1 Set 实例的属性和方法"></a>8.1 Set 实例的属性和方法</h2><p>Set 结构的实例有以下属性。</p><ul><li><code>Set.prototype.constructor</code>：构造函数，默认就是<code>Set</code>函数。</li><li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li></ul><p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p><ul><li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li><li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li><li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li><li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li></ul><p>Set 结构的实例有四个遍历方法，可以用于遍历成员。</p><ul><li><code>Set.prototype.keys()</code>：返回键名的遍历器</li><li><code>Set.prototype.values()</code>：返回键值的遍历器</li><li><code>Set.prototype.entries()</code>：返回键值对的遍历器</li><li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li></ul><p>需要特别指出的是，<code>Set</code>的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用 Set 保存一个回调函数列表，调用时就能保证按照添加顺序调用。</p><h2 id="WeakSet"><a href="#WeakSet" class="headerlink" title="WeakSet"></a>WeakSet</h2><p>WeakSet 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。</p><p>首先，WeakSet 的成员只能是对象，而不能是其他类型的值。</p><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> ws = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>();ws.add(<span class="hljs-number">1</span>)<span class="hljs-comment">// TypeError: Invalid value used in weak set</span>ws.add(<span class="hljs-built_in">Symbol</span>())<span class="hljs-comment">// TypeError: invalid value used in weak set</span></code></pre><p>上面代码试图向 WeakSet 添加一个数值和<code>Symbol</code>值，结果报错，因为 WeakSet 只能放置对象。</p><p>其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p><p>WeakSet 结构有以下三个方法。</p><ul><li>**WeakSet.prototype.add(value)**：向 WeakSet 实例添加一个新成员。</li><li>**WeakSet.prototype.delete(value)**：清除 WeakSet 实例的指定成员。</li><li>**WeakSet.prototype.has(value)**：返回一个布尔值，表示某个值是否在 WeakSet 实例之中。</li></ul><p>WeakSet 没有<code>size</code>属性，没有办法遍历它的成员。</p><h1 id="9-Map"><a href="#9-Map" class="headerlink" title="9. Map"></a>9. Map</h1><p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;&#125;;<span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;myDiv&#x27;</span>);data[element] = <span class="hljs-string">&#x27;metadata&#x27;</span>;data[<span class="hljs-string">&#x27;[object HTMLDivElement]&#x27;</span>] <span class="hljs-comment">// &quot;metadata&quot;</span></code></pre><p>上面代码原意是将一个 DOM 节点作为对象<code>data</code>的键，但是由于对象只接受字符串作为键名，所以<code>element</code>被自动转为字符串<code>[object HTMLDivElement]</code>。</p><p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。</p><p><code>Map</code>构造函数接受数组作为参数，实际上执行的是下面的算法。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> items = [  [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张三&#x27;</span>],  [<span class="hljs-string">&#x27;title&#x27;</span>, <span class="hljs-string">&#x27;Author&#x27;</span>]];<span class="hljs-keyword">const</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();items.forEach(  ([key, value]) =&gt; map.set(key, value));</code></pre><p>事实上，不仅仅是数组，任何具有 Iterator 接口、且每个成员都是一个双元素的数组的数据结构（详见《Iterator》一章）都可以当作<code>Map</code>构造函数的参数。这就是说，<code>Set</code>和<code>Map</code>都可以用来生成新的 Map。</p><h2 id="9-1-Map-实例的属性和方法"><a href="#9-1-Map-实例的属性和方法" class="headerlink" title="9.1 Map 实例的属性和方法"></a>9.1 Map 实例的属性和方法</h2><p>Map 结构的实例有以下属性和操作方法。</p><ul><li><strong>size 属性</strong></li></ul><p><code>size</code>属性返回 Map 结构的成员总数。</p><ul><li><strong>Map.prototype.set(key, value)</strong></li></ul><p><code>set</code>方法设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</p><ul><li><strong>Map.prototype.get(key)</strong></li></ul><p><code>get</code>方法读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</p><ul><li><strong>Map.prototype.has(key)</strong></li></ul><p><code>has</code>方法返回一个布尔值，表示某个键是否在当前 Map 对象之中。</p><ul><li><strong>Map.prototype.delete(key)</strong></li></ul><p><code>delete</code>方法删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</p><ul><li><strong>Map.prototype.clear()</strong></li></ul><p><code>clear</code>方法清除所有成员，没有返回值。</p><p>Map 结构原生提供三个遍历器生成函数和一个遍历方法。</p><ul><li><code>Map.prototype.keys()</code>：返回键名的遍历器。</li><li><code>Map.prototype.values()</code>：返回键值的遍历器。</li><li><code>Map.prototype.entries()</code>：返回所有成员的遍历器。</li><li><code>Map.prototype.forEach()</code>：遍历 Map 的所有成员。</li></ul><p>需要特别注意的是，Map 的遍历顺序就是插入顺序。</p><h1 id="10-Promise-对象"><a href="#10-Promise-对象" class="headerlink" title="10. Promise 对象"></a>10. Promise 对象</h1><p>Promise 是异步编程的一种解决方案。</p><p>Promise 对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p><p>所谓<code>Promise</code>，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p><code>Promise</code>对象有以下两个特点。</p><p>（1）对象的状态不受外界影响。<code>Promise</code>对象代表一个异步操作，有三种状态：<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）和<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是<code>Promise</code>这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</p><p>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。如果改变已经发生了，你再对<code>Promise</code>对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</p><p>有了<code>Promise</code>对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，<code>Promise</code>对象提供统一的接口，使得控制异步操作更加容易。</p><p><code>Promise</code>也有一些缺点。首先，无法取消<code>Promise</code>，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，<code>Promise</code>内部抛出的错误，不会反应到外部。第三，当处于<code>pending</code>状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> someAsyncThing = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">flag</span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-keyword">if</span>(flag)&#123;        resolve(<span class="hljs-string">&#x27;ok&#x27;</span>);    &#125;<span class="hljs-keyword">else</span>&#123;        reject(<span class="hljs-string">&#x27;error&#x27;</span>)    &#125;  &#125;);&#125;;someAsyncThing(<span class="hljs-literal">true</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data:&#x27;</span>,data); <span class="hljs-comment">// 输出 &#x27;ok&#x27;</span>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error:&#x27;</span>, error); <span class="hljs-comment">// 不执行</span>&#125;)someAsyncThing(<span class="hljs-literal">false</span>).then(<span class="hljs-function">(<span class="hljs-params">data</span>)=&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;data:&#x27;</span>,data); <span class="hljs-comment">// 不执行</span>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error:&#x27;</span>, error); <span class="hljs-comment">// 输出 &#x27;error&#x27;</span>&#125;)</code></pre><p>上面代码中，someAsyncThing 函数成功返回 ‘OK’, 失败返回 ‘error’, 只有失败时才会被 catch 捕捉到。</p><h2 id="10-1-Promise-实例方法"><a href="#10-1-Promise-实例方法" class="headerlink" title="10.1 Promise 实例方法"></a>10.1 Promise 实例方法</h2><ul><li><strong>Promise.all()</strong> </li></ul><p><code>Promise.all()</code>方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3]);</code></pre><p><code>p</code>的状态由<code>p1</code>、<code>p2</code>、<code>p3</code>决定，分成两种情况。</p><p>（1）只有<code>p1</code>、<code>p2</code>、<code>p3</code>的状态都变成<code>fulfilled</code>，<code>p</code>的状态才会变成<code>fulfilled</code>，此时<code>p1</code>、<code>p2</code>、<code>p3</code>的返回值组成一个数组，传递给<code>p</code>的回调函数。</p><p>（2）只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个被<code>rejected</code>，<code>p</code>的状态就变成<code>rejected</code>，此时第一个被<code>reject</code>的实例的返回值，会传递给<code>p</code>的回调函数。</p><ul><li><strong>Promise.race()</strong> </li></ul><p><code>Promise.race()</code>方法同样是将多个 Promise 实例，包装成一个新的 Promise 实例。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([p1, p2, p3]);</code></pre><p>上面代码中，只要<code>p1</code>、<code>p2</code>、<code>p3</code>之中有一个实例率先改变状态，<code>p</code>的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给<code>p</code>的回调函数。</p><p><code>Promise.race()</code>方法的参数与<code>Promise.all()</code>方法一样，如果不是 Promise 实例，就会先调用下面讲到的<code>Promise.resolve()</code>方法，将参数转为 Promise 实例，再进一步处理。</p><p>下面是一个例子，如果指定时间内没有获得结果，就将 Promise 的状态变为<code>reject</code>，否则变为<code>resolve</code>。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.race([  fetch(<span class="hljs-string">&#x27;/resource-that-may-take-a-while&#x27;</span>),  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;request timeout&#x27;</span>)), <span class="hljs-number">5000</span>)  &#125;)]);p.then(<span class="hljs-built_in">console</span>.log).catch(<span class="hljs-built_in">console</span>.error);</code></pre><p>上面代码中，如果 5 秒之内<code>fetch</code>方法无法返回结果，变量<code>p</code>的状态就会变为<code>rejected</code>，从而触发<code>catch</code>方法指定的回调函数。</p><ul><li><strong>Promise.allSettled()</strong> ES2020 引入</li></ul><p><code>Promise.allSettled()</code>方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例。只有等到所有这些参数实例都返回结果，不管是<code>fulfilled</code>还是<code>rejected</code>，包装实例才会结束。</p><ul><li><strong>Promise.any()</strong> ES2021 引入</li></ul><p>ES2021 引入了<a href="https://github.com/tc39/proposal-promise-any"><code>Promise.any()</code>方法</a>。该方法接受一组 Promise 实例作为参数，包装成一个新的 Promise 实例返回。只要参数实例有一个变成<code>fulfilled</code>状态，包装实例就会变成<code>fulfilled</code>状态；如果所有参数实例都变成<code>rejected</code>状态，包装实例就会变成<code>rejected</code>状态。</p><p><code>Promise.any()</code>跟<code>Promise.race()</code>方法很像，只有一点不同，就是不会因为某个 Promise 变成<code>rejected</code>状态而结束。</p><h1 id="11-async-await"><a href="#11-async-await" class="headerlink" title="11. async / await"></a>11. async / await</h1><p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p><p>async 函数的使用方式，直接在普通函数前面加上 async，表示这是一个异步函数，在要异步执行的语句前面加上 await，表示后面的表达式需要等待。async 是 Generator 的语法糖</p><ol><li>async 函数内部 return 语句返回的值，会成为 then 方法回调函数的参数。</li><li>async 函数内部抛出错误，会导致返回的 Promise 对象变为 reject 状态。抛出的错误对象会被 catch 方法回调函数接收到。</li><li>async 函数返回的 Promise 对象，必须等到内部所有 await 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 return 语句或者抛出错误。也就是说，只有 async 函数内部的异步操作执行完，才会执行 then 方法指定的回调函数。 </li></ol><p>可以用写同步的方式来写异步操作</p><h1 id="12-Class-语法"><a href="#12-Class-语法" class="headerlink" title="12. Class 语法"></a>12. Class 语法</h1><p>ES6 的类，完全可以看作构造函数的另一种写法。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">typeof</span> Point <span class="hljs-comment">// &quot;function&quot;</span>Point === Point.prototype.constructor <span class="hljs-comment">// true</span></code></pre><p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p><p>使用的时候，也是直接对类使用<code>new</code>命令，跟构造函数的用法完全一致</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bar</span> </span>&#123;  doStuff() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stuff&#x27;</span>);  &#125;&#125;<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Bar();b.doStuff() <span class="hljs-comment">// &quot;stuff&quot;</span></code></pre><p>构造函数的<code>prototype</code>属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的<code>prototype</code>属性上面。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-comment">// ...</span>  &#125;  toString() &#123;    <span class="hljs-comment">// ...</span>  &#125;  toValue() &#123;    <span class="hljs-comment">// ...</span>  &#125;&#125;<span class="hljs-comment">// 等同于</span>Point.prototype = &#123;  <span class="hljs-keyword">constructor</span>() &#123;&#125;,  toString() &#123;&#125;,  toValue() &#123;&#125;,&#125;;</code></pre><p>在类的实例上面调用方法，其实就是调用原型上的方法。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-keyword">new</span> B();b.constructor === B.prototype.constructor <span class="hljs-comment">// true</span></code></pre><p>上面代码中，<code>b</code>是<code>B</code>类的实例，它的<code>constructor</code>方法就是<code>B</code>类原型的<code>constructor</code>方法。</p><p>由于类的方法都定义在<code>prototype</code>对象上面，所以类的新方法可以添加在<code>prototype</code>对象上面。<code>Object.assign</code>方法可以很方便地一次向类添加多个方法。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>()&#123;    <span class="hljs-comment">// ...</span>  &#125;&#125;<span class="hljs-built_in">Object</span>.assign(Point.prototype, &#123;  toString()&#123;&#125;,  toValue()&#123;&#125;&#125;);</code></pre><p><code>prototype</code>对象的<code>constructor</code>属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p><pre><code class="hljs javascript">Point.prototype.constructor === Point <span class="hljs-comment">// true</span></code></pre><p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p><p>注意：Class 内部默认采用严格模式</p><ul><li>取值函数（getter）和存值函数（setter）</li></ul><p>与 ES5 一样，在“类”的内部可以使用<code>get</code>和<code>set</code>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;    <span class="hljs-comment">// ...</span>  &#125;  <span class="hljs-keyword">get</span> <span class="hljs-title">prop</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;getter&#x27;</span>;  &#125;  <span class="hljs-keyword">set</span> <span class="hljs-title">prop</span>(<span class="hljs-params">value</span>) &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;setter: &#x27;</span>+value);  &#125;&#125;<span class="hljs-keyword">let</span> inst = <span class="hljs-keyword">new</span> MyClass();inst.prop = <span class="hljs-number">123</span>;<span class="hljs-comment">// setter: 123</span>inst.prop<span class="hljs-comment">// &#x27;getter&#x27;</span></code></pre><p>上面代码中，<code>prop</code>属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</p><h2 id="12-1-Class-继承"><a href="#12-1-Class-继承" class="headerlink" title="12.1 Class 继承"></a>12.1 Class 继承</h2><p>Class 可以通过<code>extends</code>关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123;&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;&#125;</code></pre><p>上面代码定义了一个<code>ColorPoint</code>类，该类通过<code>extends</code>关键字，继承了<code>Point</code>类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个<code>Point</code>类。下面，我们在<code>ColorPoint</code>内部加上代码。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>(x, y, color) &#123;    <span class="hljs-built_in">super</span>(x, y); <span class="hljs-comment">// 调用父类的constructor(x, y)</span>    <span class="hljs-built_in">this</span>.color = color;  &#125;  toString() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.color + <span class="hljs-string">&#x27; &#x27;</span> + <span class="hljs-built_in">super</span>.toString(); <span class="hljs-comment">// 调用父类的toString()</span>  &#125;&#125;</code></pre><p>上面代码中，<code>constructor</code>方法和<code>toString</code>方法之中，都出现了<code>super</code>关键字，它在这里表示父类的构造函数，用来新建父类的<code>this</code>对象。</p><p>子类必须在<code>constructor</code>方法中调用<code>super</code>方法，否则新建实例时会报错。这是因为子类自己的<code>this</code>对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用<code>super</code>方法，子类就得不到<code>this</code>对象。</p><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span> </span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColorPoint</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Point</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;  &#125;&#125;<span class="hljs-keyword">let</span> cp = <span class="hljs-keyword">new</span> ColorPoint(); <span class="hljs-comment">// ReferenceError</span></code></pre><p>上面代码中，<code>ColorPoint</code>继承了父类<code>Point</code>，但是它的构造函数没有调用<code>super</code>方法，导致新建实例时报错。</p><h1 id="13-Symbol"><a href="#13-Symbol" class="headerlink" title="13. Symbol"></a>13. Symbol</h1><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</p><p>如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p><p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Symbol</span>();<span class="hljs-keyword">typeof</span> s<span class="hljs-comment">// &quot;symbol&quot;</span></code></pre><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p><p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p><p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);s1 <span class="hljs-comment">// Symbol(foo)</span>s2 <span class="hljs-comment">// Symbol(bar)</span>s1.toString() <span class="hljs-comment">// &quot;Symbol(foo)&quot;</span>s2.toString() <span class="hljs-comment">// &quot;Symbol(bar)&quot;</span></code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p><p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。                                                                                                                         </p><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p><p>Symbol 值不能与其他类型的值进行运算，会报错。</p><p>但是，Symbol 值可以显式转为字符串。</p><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p><h2 id="13-1-作为属性名"><a href="#13-1-作为属性名" class="headerlink" title="13.1 作为属性名"></a>13.1 作为属性名</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> mySymbol = <span class="hljs-built_in">Symbol</span>();<span class="hljs-comment">// 第一种写法</span><span class="hljs-keyword">let</span> a = &#123;&#125;;a[mySymbol] = <span class="hljs-string">&#x27;Hello!&#x27;</span>;<span class="hljs-comment">// 第二种写法</span><span class="hljs-keyword">let</span> a = &#123;  [mySymbol]: <span class="hljs-string">&#x27;Hello!&#x27;</span>&#125;;<span class="hljs-comment">// 第三种写法</span><span class="hljs-keyword">let</span> a = &#123;&#125;;<span class="hljs-built_in">Object</span>.defineProperty(a, mySymbol, &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;Hello!&#x27;</span> &#125;);<span class="hljs-comment">// 以上写法都得到同样结果</span>a[mySymbol] <span class="hljs-comment">// &quot;Hello!&quot;</span></code></pre><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p><p>注意，Symbol 值作为对象属性名时，不能用点运算符。因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p><h2 id="13-2-属性名的遍历"><a href="#13-2-属性名的遍历" class="headerlink" title="13.2 属性名的遍历"></a>13.2 属性名的遍历</h2><p>Symbol 作为属性名，遍历对象的时候，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。</p><p>不会被以下遍历：</p><ul><li><code>for...in</code></li><li><code>for...of</code></li></ul><p>不会被以下返回：</p><ul><li><code>Object.keys()</code></li><li><code>Object.getOwnPropertyNames()</code></li><li><code>JSON.stringify()</code></li></ul><p>但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols()</code>方法，可以获取指定对象的所有 Symbol 属性名。该方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p><h2 id="13-3-Symbol-for-Symbol-keyFor"><a href="#13-3-Symbol-for-Symbol-keyFor" class="headerlink" title="13.3 Symbol.for() Symbol.keyFor()"></a>13.3 Symbol.for() Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for()</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建一个以该字符串为名称的 Symbol 值，并将其注册到全局。</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;foo&#x27;</span>);s1 === s2 <span class="hljs-comment">// true</span></code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是由同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p><h1 id="14-Module-语法"><a href="#14-Module-语法" class="headerlink" title="14. Module 语法"></a>14. Module 语法</h1><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p><h2 id="14-1-export"><a href="#14-1-export" class="headerlink" title="14.1 export"></a>14.1 export</h2><p>一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。下面是一个 JS 文件，里面使用<code>export</code>命令输出变量。</p><pre><code class="hljs js"><span class="hljs-comment">// profile.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;</code></pre><p>上面代码是<code>profile.js</code>文件，保存了用户信息。ES6 将其视为一个模块，里面用<code>export</code>命令对外部输出了三个变量。</p><p>等价于：</p><pre><code class="hljs js"><span class="hljs-comment">// profile.js</span><span class="hljs-keyword">var</span> firstName = <span class="hljs-string">&#x27;Michael&#x27;</span>;<span class="hljs-keyword">var</span> lastName = <span class="hljs-string">&#x27;Jackson&#x27;</span>;<span class="hljs-keyword">var</span> year = <span class="hljs-number">1958</span>;<span class="hljs-keyword">export</span> &#123; firstName, lastName, year &#125;;</code></pre><p><code>export</code>命令除了输出变量，还可以输出函数或类（class）。</p><p>通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字重命名。</p><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v1</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">v2</span>(<span class="hljs-params"></span>) </span>&#123; ... &#125;<span class="hljs-keyword">export</span> &#123;  v1 <span class="hljs-keyword">as</span> streamV1,  v2 <span class="hljs-keyword">as</span> streamV2,  v2 <span class="hljs-keyword">as</span> streamLatestVersion&#125;;</code></pre><p>上面代码使用<code>as</code>关键字，重命名了函数<code>v1</code>和<code>v2</code>的对外接口。重命名后，<code>v2</code>可以用不同的名字输出两次。</p><p>需要特别注意的是，<code>export</code>命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。</p><p>同样的，<code>function</code>和<code>class</code>的输出，也必须遵守这样的写法。</p><h2 id="14-2-import"><a href="#14-2-import" class="headerlink" title="14.2 import"></a>14.2 import</h2><p>使用<code>export</code>命令定义了模块的对外接口以后，其他 JS 文件就可以通过<code>import</code>命令加载这个模块。</p><pre><code class="hljs javascript"><span class="hljs-comment">// main.js</span><span class="hljs-keyword">import</span> &#123; firstName, lastName, year &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./profile.js&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setName</span>(<span class="hljs-params">element</span>) </span>&#123;  element.textContent = firstName + <span class="hljs-string">&#x27; &#x27;</span> + lastName;&#125;</code></pre><p>上面代码的<code>import</code>命令，用于加载<code>profile.js</code>文件，并从中输入变量。<code>import</code>命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（<code>profile.js</code>）对外接口的名称相同。</p><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径。如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p><pre><code class="hljs javascript">foo();<span class="hljs-keyword">import</span> &#123; foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;my_module&#x27;</span>;</code></pre><p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p><p>最后，<code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;</code></pre><p>上面代码仅仅执行<code>lodash</code>模块，但是不输入任何值。</p><h2 id="14-3-export-default"><a href="#14-3-export-default" class="headerlink" title="14.3 export default"></a>14.3 export default</h2><p>用到<code>export default</code>命令，为模块指定默认输出。</p><pre><code class="hljs javascript"><span class="hljs-comment">// export-default.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;foo&#x27;</span>);&#125;</code></pre><p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p><p>其他模块加载该模块时，<code>import</code>命令可以为该匿名函数指定任意名字。</p><pre><code class="hljs javascript"><span class="hljs-comment">// import-default.js</span><span class="hljs-keyword">import</span> customName <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./export-default&#x27;</span>;customName(); <span class="hljs-comment">// &#x27;foo&#x27;</span></code></pre><p>上面代码的<code>import</code>命令，可以用任意名称指向<code>export-default.js</code>输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时<code>import</code>命令后面，不使用大括号。</p><p><code>export default</code>命令用在非匿名函数前，也是可以的。</p><p>下面比较一下默认输出和正常输出。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 第一组</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span>  <span class="hljs-comment">// ...</span>&#125;<span class="hljs-keyword">import</span> crc32 <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crc32&#x27;</span>; <span class="hljs-comment">// 输入</span><span class="hljs-comment">// 第二组</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crc32</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 输出</span>  <span class="hljs-comment">// ...</span>&#125;;<span class="hljs-keyword">import</span> &#123;crc32&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;crc32&#x27;</span>; <span class="hljs-comment">// 输入</span></code></pre><p>上面代码的两组写法，第一组是使用<code>export default</code>时，对应的<code>import</code>语句不需要使用大括号；第二组是不使用<code>export default</code>时，对应的<code>import</code>语句需要使用大括号。</p><p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能唯一对应<code>export default</code>命令。</p><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p><pre><code class="hljs javascript"><span class="hljs-comment">// modules.js</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x, y</span>) </span>&#123;  <span class="hljs-keyword">return</span> x * y;&#125;<span class="hljs-keyword">export</span> &#123;add <span class="hljs-keyword">as</span> <span class="hljs-keyword">default</span>&#125;;<span class="hljs-comment">// 等同于</span><span class="hljs-comment">// export default add;</span><span class="hljs-comment">// app.js</span><span class="hljs-keyword">import</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> foo &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;modules&#x27;</span>;<span class="hljs-comment">// 等同于</span><span class="hljs-comment">// import foo from &#x27;modules&#x27;;</span></code></pre><p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-comment">// 正确</span><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> a;<span class="hljs-comment">// 错误</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;</code></pre><p>上面代码中，<code>export default a</code>的含义是将变量<code>a</code>的值赋给变量<code>default</code>。所以，最后一种写法会报错。</p><p>同样地，因为<code>export default</code>命令的本质是将后面的值，赋给<code>default</code>变量，所以可以直接将一个值写在<code>export default</code>之后。</p><pre><code class="hljs javascript"><span class="hljs-comment">// 正确</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-number">42</span>;<span class="hljs-comment">// 报错</span><span class="hljs-keyword">export</span> <span class="hljs-number">42</span>;</code></pre><p>上面代码中，后一句报错是因为没有指定对外的接口，而前一句指定对外接口为<code>default</code>。</p><p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入 lodash 模块为例。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;</code></pre><p>如果想在一条<code>import</code>语句中，同时输入默认方法和其他接口，可以写成下面这样。</p><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> _, &#123; each, forEach &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;lodash&#x27;</span>;</code></pre><p>对应上面代码的<code>export</code>语句如下。</p><pre><code class="hljs javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;  <span class="hljs-comment">// ···</span>&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">each</span>(<span class="hljs-params">obj, iterator, context</span>) </span>&#123;  <span class="hljs-comment">// ···</span>&#125;<span class="hljs-keyword">export</span> &#123; each <span class="hljs-keyword">as</span> forEach &#125;;</code></pre><p>上面代码的最后一行的意思是，暴露出<code>forEach</code>接口，默认指向<code>each</code>接口，即<code>forEach</code>和<code>each</code>指向同一个方法。</p><p><code>export default</code>也可以用来输出类。</p><h1 id="15-Reflect"><a href="#15-Reflect" class="headerlink" title="15. Reflect"></a>15. Reflect</h1><p><code>Reflect</code>是一个内置的对象，它提供拦截 JavaScript 操作的方法。Reflect 不是一个函数对象，因此它是不可构造的。<code>Reflect</code>的所有的方法都是静态的就和<code>Math</code>一样，目前它还没有静态属性。</p><p><code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法相同。</p><p><code>Reflect</code> 一共有13个静态方法：</p><p>它可以分为一部分是是原来存在<code>Object</code>上的方法，将它转义到了<code>Reflect</code>上，并作了小改动，让方法更加合理。</p><ol><li><code>defineProperty</code> 与<a href="https://juejin.im/post/6844903788642484237#heading-1">Object.defineProperty</a>类似，但是当对象无法定义时<code>Object.defineProperty</code>会报错而<code>Reflect.defineProperty</code>不会，它会返回<code>false</code>，成功时返回<code>true</code>，如果不是对象还是会报错。</li><li><code>getPrototypeOf(target)</code> 与<code>Object.getPrototypeOf</code>一样，返回指定对象的原型。</li><li><code>setPrototypeOf(target, prototype)</code> 与<code>Object.setPrototypeOf</code>一样，它将指定对象的原型设置为另外一个对象。</li><li><code>getOwnPropertyDescriptor()</code> 与<code>Object.getOwnPropertyDescriptor</code>一样，如果在对象中存在，则返回给定的属性的<a href="https://juejin.im/post/6844903788642484237#heading-1">属性描述符</a>。</li><li><code>isExtensible(target)</code> 与<code>Object.isExtensible</code>类似，判断一个对象是否可扩展（是否可以在它上面添加新的属性），它们的不同点是，当参数不是对象时（原始值），<code>Object</code>的将它强制转变为一个对象，<code>Reflect</code>是直接报错。</li><li><code>preventExtensions(target)</code> 与<code>Object.preventExtensions</code>类似，阻止新属性添加到对象，不同点和上一条一样。</li><li><code>apply(func, thisArg, args)</code> 与<code>Function.prototype.apply.call(fn, obj, args)</code>一样。</li><li><code>ownKeys(target)</code> 与<code>Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))</code>一样，返回一个包含所有自身属性（不包含继承属性）的数组</li></ol><p>另一部分是将原来操作符的功能，变成函数行为。</p><ol><li><code>has(target, key)</code> 与<code>in</code>操作符一样，让判断操作都变成函数行为。</li><li><code>deleteProperty(target, key)</code> 与<code>delete</code>操作符一样，让删除操作变成函数行为，返回布尔值代表成功或失败。</li><li><code>construct(target, argumentsList[, newTarget])</code> 与<code>new</code>操作符一样，<code>target</code>构造函数，第二参数是构造函数参数类数组，第三个是<a href="https://juejin.im/post/6844903788642484237#heading-4">new.target</a>的值。</li><li><code>get(target, key[, receiver])</code> 与<code>obj[key]</code>一样，第三个参数是当要取值的<code>key</code>部署了<code>getter</code>时，访问其函数的<code>this</code>绑定为<code>receiver</code>对象。</li><li><code>set(target, key, value[, receiver])</code> 设置<code>target</code>对象的<code>key</code>属性等于<code>value</code>，第三个参数和<code>set</code>一样。返回一个布尔值。</li></ol><pre><code class="hljs js"><span class="hljs-comment">// 老写法</span><span class="hljs-string">&#x27;assign&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">Object</span> <span class="hljs-comment">// true</span><span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.has(<span class="hljs-built_in">Object</span>, <span class="hljs-string">&#x27;assign&#x27;</span>) <span class="hljs-comment">// true</span><span class="hljs-comment">// 老写法</span><span class="hljs-built_in">Function</span>.prototype.apply.call(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span><span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.apply(<span class="hljs-built_in">Math</span>.floor, <span class="hljs-literal">undefined</span>, [<span class="hljs-number">1.75</span>]) <span class="hljs-comment">// 1</span><span class="hljs-comment">// 旧写法</span><span class="hljs-keyword">delete</span> myObj.foo;<span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.deleteProperty(myObj, <span class="hljs-string">&#x27;foo&#x27;</span>);<span class="hljs-comment">// new 的写法</span><span class="hljs-keyword">const</span> instance = <span class="hljs-keyword">new</span> Greeting(<span class="hljs-string">&#x27;张三&#x27;</span>);<span class="hljs-comment">// Reflect.construct 的写法</span><span class="hljs-keyword">const</span> instance = <span class="hljs-built_in">Reflect</span>.construct(Greeting, [<span class="hljs-string">&#x27;张三&#x27;</span>]);<span class="hljs-comment">// 旧写法</span><span class="hljs-built_in">Object</span>.defineProperty(MyDate, <span class="hljs-string">&#x27;now&#x27;</span>, &#123;  value: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Date</span>.now()&#125;);<span class="hljs-comment">// 新写法</span><span class="hljs-built_in">Reflect</span>.defineProperty(MyDate, <span class="hljs-string">&#x27;now&#x27;</span>, &#123;  value: <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">Date</span>.now()&#125;);<span class="hljs-built_in">Reflect</span>.get(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">Reflect</span>.get(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;foo&#x27;</span>) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">Reflect</span>.set(<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="hljs-comment">// 报错</span><span class="hljs-built_in">Reflect</span>.set(<span class="hljs-literal">false</span>, <span class="hljs-string">&#x27;foo&#x27;</span>, &#123;&#125;) <span class="hljs-comment">// 报错</span><span class="hljs-comment">// ---------------</span><span class="hljs-keyword">var</span> myObject = &#123;  foo: <span class="hljs-number">1</span>,  bar: <span class="hljs-number">2</span>,  <span class="hljs-keyword">get</span> <span class="hljs-title">baz</span>() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.foo + <span class="hljs-built_in">this</span>.bar;  &#125;,&#125;;<span class="hljs-keyword">var</span> myReceiverObject = &#123;  foo: <span class="hljs-number">4</span>,  bar: <span class="hljs-number">4</span>,&#125;;<span class="hljs-built_in">Reflect</span>.get(myObject, <span class="hljs-string">&#x27;baz&#x27;</span>, myReceiverObject) <span class="hljs-comment">// 8</span></code></pre><h1 id="16-Proxy"><a href="#16-Proxy" class="headerlink" title="16. Proxy"></a>16. Proxy</h1><blockquote><p>ES6 Proxy 提供了强大的 Javascript 元编程接口</p></blockquote><p><strong>Proxy</strong> 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等），等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p><p><strong>Proxy</strong> 就像在目标对象之间的一个代理，任何对目标的操作都要经过代理。代理就可以对外界的操作进行过滤和改写。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(target, handler)</code></pre><p><code>Proxy</code>是构造函数，它有两个参数<code>target</code>和<code>handler</code>，</p><p><code>target</code>是用Proxy包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p><p><code>handler</code>是一个对象，其属性是当执行一个操作时定义代理的行为的函数。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`getting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, key, receiver);  &#125;,  set: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">target, key, value, receiver</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`setting <span class="hljs-subst">$&#123;key&#125;</span>!`</span>);    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, key, value, receiver);  &#125;&#125;);obj.count = <span class="hljs-number">1</span><span class="hljs-comment">//  setting count!</span>++obj.count<span class="hljs-comment">//  getting count!</span><span class="hljs-comment">//  setting count!</span><span class="hljs-comment">//  2</span></code></pre><p><code>Proxy</code>只有一个静态方法<code>revocable(target, handler)</code>可以用来创建一个可撤销的代理对象。两个参数和构造函数的相同。它返回一个包含了所生成的代理对象本身以及该代理对象的撤销方法的对象。</p><p>一旦某个代理对象被撤销，它将变的几乎完全不可用，在它身上执行任何的可代理操作都会抛出 TypeError 异常（注意，可代理操作一共有 14 种，执行这 14 种操作以外的操作不会抛出异常）。</p><p>一旦被撤销，这个代理对象永远不可能恢复到原来的状态，同时和它关联的目标对象以及处理器对象将有可能被垃圾回收掉。调用撤销方法多次将不会有任何效果，当然，也不会报错。</p><pre><code class="hljs js"><span class="hljs-keyword">var</span> revocable = <span class="hljs-built_in">Proxy</span>.revocable(&#123;&#125;, &#123;  get(target, name) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;[[&quot;</span> + name + <span class="hljs-string">&quot;]]&quot;</span>;  &#125;&#125;);<span class="hljs-comment">// revocable -&gt; &#123;&quot;proxy&quot;: proxy, &quot;revoke&quot;: revoke&#125;</span><span class="hljs-keyword">var</span> proxy = revocable.proxy;proxy.foo;              <span class="hljs-comment">// &quot;[[foo]]&quot;</span>revocable.revoke();     <span class="hljs-comment">// 执行撤销方法</span>proxy.foo;              <span class="hljs-comment">// TypeError</span>proxy.foo = <span class="hljs-number">1</span>           <span class="hljs-comment">// 同样 TypeError</span><span class="hljs-keyword">delete</span> proxy.foo;       <span class="hljs-comment">// 还是 TypeError</span><span class="hljs-keyword">typeof</span> proxy            <span class="hljs-comment">// &quot;object&quot;，因为 typeof 不属于可代理操作</span></code></pre><p><code>handler</code>参数是代理函数对象，它一共支持 13 种拦截函数。和<code>Reflect</code>的相同。如果没有定义某种操作，那么这种操作会被转发到目标对象身上。</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxy = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(&#123;&#125;, &#123;  get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">target, property, receiver</span>) </span>&#123;    <span class="hljs-keyword">return</span> receiver;    <span class="hljs-comment">// receiver 总是指向原始的读操作所在的那个对象，一般情况下就是 Proxy 实例。</span>  &#125;&#125;);proxy.getReceiver === proxy <span class="hljs-comment">// true</span></code></pre><p>如果一个属性不可配置（configurable）且不可写（writable），则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错。</p><ol><li><p><code>apply</code>方法拦截函数的<code>调用</code>、<code>call</code>和<code>apply</code>操作。</p></li><li><p><code>defineProperty</code>方法拦截了<code>Object.defineProperty</code>操作。</p></li><li><p><code>getPrototypeOf</code>方法主要用来拦截获取对象原型，会以下这些操作：</p><ol><li><code>Object.prototype.__proto__</code></li><li><code>Object.prototype.isPrototypeOf()</code></li><li><code>Object.getPrototypeOf()</code></li><li><code>Reflect.getPrototypeOf()</code></li><li><code>instanceof</code></li></ol></li><li><p><code>ownKeys</code>方法用来拦截对象自身属性的读取操作，会拦截以下操作：</p><ol><li><code>Object.getOwnPropertyNames()</code></li><li><code>Object.getOwnPropertySymbols()</code></li><li><code>Object.keys()</code></li><li><code>for...in</code></li></ol></li></ol><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><p>虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。</p><p>主要原因就是在 Proxy 代理的情况下，目标对象内部的<code>this</code>关键字会指向 Proxy 代理。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>ECMAScript6</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 的运行机制</title>
    <link href="/2020/09/28/JavaScript%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/"/>
    <url>/2020/09/28/JavaScript%20%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-的运行机制"><a href="#JavaScript-的运行机制" class="headerlink" title="JavaScript 的运行机制"></a>JavaScript 的运行机制</h1><h2 id="事件循环-Event-Loop"><a href="#事件循环-Event-Loop" class="headerlink" title="事件循环 Event Loop"></a>事件循环 Event Loop</h2><p>JavaScript 脚本加载完成时, JS 引擎会去预解析JS代码, 为代码中的「对象」预先在堆内存中分配地址空间, 然后按</p><p>顺序逐句解释执行( 即时编译 JIT)</p><p>第一次JS代码执行时, 会默认创建一个「全局执行上下文」, 并将其压入「执行栈」底,  然后每当引擎遇到一个函数</p><p>调用时, 都将会为其创建一个<strong>新</strong>的「函数执行上下文」, 并将其压入执行栈<strong>顶.</strong> 引擎会执行那些执行上下文位于<strong>栈顶</strong></p><p>的函数。当该函数执行结束时，「执行上下文」从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>每一个 JavaScript 程序都有且只有一个默认的「全局执行上下文」, 在浏览器环境中它指向 <code>Window</code></p><p><img src="/images/exceute_stack.jpg" alt="exceute_stack"></p><blockquote><p>macro-task(宏任务)：包括整体代码script（同步宏任务），setTimeout、setInterval（异步宏任务）</p><p>micro-task(微任务)：Promise，process.nextTick，ajax请求（异步微任务）</p></blockquote><p>当引擎在创建函数「执行上下文」之前, 会判断当前函数是 <strong>同步任务</strong>还是 <strong>异步任务</strong>, 如果是 <strong>同步任务</strong>,  就进入主</p><p>线程创建「函数执行上下文」并且压入 <strong>执行栈顶</strong>等待执行, 如果是 <strong>异步任务</strong> , 则不 进入主线程执行 ,  不创建函数 </p><p> 执行上下文  , 而是被<code>Event Table</code> 所记录, 当 <strong>异步任务</strong>准备好时, 为其注册回调用函数, 进入事件队列<code>Event </code></p><p><code>Quene</code>等待执行</p><p>当执行栈执行完毕时, 调用 事件队列 <code>Event Quene</code> 中的回调函数进栈执行, 在<strong>异步任务</strong>被 <code>Event Table</code> 所记录之</p><p>前, 会判断是 「宏任务」 还是 「微任务」 , 分别被 宏任务 Event Table 和 微任务Event Table 记录, 最后再注册回</p><p>调函数, 并进入相应的「宏任务事件队列 」和 「微任务事件队列」</p><blockquote><p>注意「宏任务」和「微任务」并不是严格意义上的 “平级关系”</p></blockquote><p>在主线程调取「任务队列」的 回调函数进入「执行栈」执行时, 优先调用「微任务事件队列」执行完毕 再调用 </p><p>「宏任务事件队列」 以上步骤循环,就是 「JavaScript」 的 <strong>事件循环</strong></p><p>talk is cheap show your code, 用代码解释:</p><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;1&#x27;</span>);<span class="hljs-comment">// 记作 set1</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;2&#x27;</span>);    <span class="hljs-comment">// set4</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;3&#x27;</span>);    &#125;);    <span class="hljs-comment">// pro2</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;4&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;5&#x27;</span>);    &#125;);&#125;);<span class="hljs-comment">// 记作 pro1</span><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;6&#x27;</span>);    resolve();&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;7&#x27;</span>);    <span class="hljs-comment">// set3</span>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;8&#x27;</span>);    &#125;);&#125;);<span class="hljs-comment">// 记作 set2</span><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;9&#x27;</span>);    <span class="hljs-comment">// 记作 pro3</span>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;10&#x27;</span>);        resolve();    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;11&#x27;</span>);    &#125;);&#125;);</code></pre><ol><li><p>整体代码 script 为一个大的宏任务,进入执行栈执行, 顺序执行 <code>打印1</code> </p></li><li><p>遇到定时器set1为异步的宏任务不进入主线程执行,注册进入宏任务队列 <code>(set1)</code> </p></li><li><p>继续执行遇到 Promise pro1 先执行其中的同步代码  <code>打印6</code>  , pro1中的<code>then()</code>为异步的微任务不进入主线程执行, 注册进入微任务队列 <code>(pro1)</code>,</p></li><li><p>继续执行遇到定时器 set2 为异步的宏任务不进入主线程执行, 注册进入宏任务队列 <code>(set1 set2)</code>,</p></li><li><p>此时执行栈空,检测任务队列是否有任务等待执行,优先执行微任务 <code>(pro1)</code></p></li><li><p>执行微任务队列 <code>(pro1)</code> pro1的 then()  <code>打印7</code>  </p><ol><li>继续执行遇到定时器set3 不进入主线程执行,注册进入宏任务队列 <code>(set1 set2 set3)</code></li></ol></li><li><p>微任务队列空, 执行宏任务队列 <code>(set1 set2 set3)</code> set1  <code>打印2</code>  ,</p><ol><li>遇到定时器set4为异步的宏任务不进入主线程执行,注册进入宏任务队列 <code>(set2 set3 set4)</code> </li><li>遇到 Promise pro2 先执行其中的同步任务,并且为其then 注册微任务队列 <code>(pro2)</code></li></ol></li><li><p>执行栈继续调用任务队列回调函数执行, 此时微任务队列 (pro2)不为空, pro2 的<code>then()</code>优先执行<code>打印5</code> </p></li><li><p>执行微任务完毕, 继续执行宏任务队列<code>(set2 set3 set4)</code> set2  <code>打印9</code> </p><ol><li>遇到 pro3 同样先执行其中同步代码<code>打印10</code>再为其then 注册微任务队列 <code>(pro3)</code></li></ol></li><li><p>执行栈继续调用任务队列回调函数执行, 优先执行微任务队列<code>(pro3)</code>  pro3的 then() <code>打印11</code>  ,</p></li><li><p>微任务队列空, 执行宏任务队列<code>(set3 set4)</code>set3 <code>打印8</code>  执行set4  <code>打印3</code></p></li></ol><pre><code class="hljs js"><span class="hljs-comment">//打印顺序:1 6 7 2 5 9 10 11 8 3</span></code></pre><p>以上就是JS中的 「事件循环」Event Loop</p><p>执行顺序为 同步(宏)任务-&gt;异步微任务-&gt;异步宏任务-&gt;…</p><h3 id="微任务-microtask"><a href="#微任务-microtask" class="headerlink" title="微任务(microtask)"></a>微任务(microtask)</h3><p>ES6新引入了Promise标准，同时浏览器实现上多了一个<code>microtask</code>微任务概念，在ECMAScript中，<code>microtask</code>也被称为<code>jobs</code></p><p>我们已经知道<code>宏任务</code>结束后，会执行渲染，然后执行下一个<code>宏任务</code>， 而微任务可以理解成在当前<code>宏任务</code>执行后立即执行的任务</p><p>当一个<code>宏任务</code>执行完，会在渲染前，将执行期间所产生的所有<code>微任务</code>都执行完</p><pre><code class="hljs clean">宏任务 -&gt; 微任务 -&gt; GUI渲染 -&gt; 宏任务 -&gt; ...</code></pre><p>图解:</p><p><img src="/images/js_eventloop.jpg" alt="js_eventloop"></p><h1 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h1><p>当 JavaScript 脚本加载完成, 第一次被JavaScript 引擎所读取时, 会默认创建一个「全局执行上下文」, 并将其压入执行栈底, 然后每当引擎遇到一个函数调用, 它都会为该函数创建一个新的「函数执行上下文」并压入栈的顶部。</p><p>引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。</p><p>每一个 JavaScript 程序都有且只有一个默认的「全局执行上下文」, 在浏览器环境中它指向 <code>Window</code></p><p>下面是一段模拟执行栈顺序</p><p>代码:</p><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">first</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);  second();  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">second</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);&#125;first();<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Inside Global Execution Context&#x27;</span>);</code></pre><p>打印台:</p><pre><code class="hljs js"><span class="hljs-comment">//Inside first function</span><span class="hljs-comment">//Inside second function</span><span class="hljs-comment">//Again inside first function</span><span class="hljs-comment">//Inside Global Execution Context</span></code></pre><p>图解执行栈:</p><p><img src="/images/exceute_stack.jpg" alt="exceute_stack"></p>]]></content>
    
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
